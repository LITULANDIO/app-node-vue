{"version":3,"mappings":"mUAAA,MAAMA,GAAiB,oIACjBC,GAAuB,iKACvBC,GAAY,oCAClB,SAASC,GAAmBC,EAAKC,EAAO,CACtC,GAAID,IAAQ,aAGR,MAAQ,eAAiBC,GAAS,OAAOA,GAAU,UAAY,cAAeA,GAGlF,OAAOA,CACT,CACA,SAASC,GAAMD,EAAOE,EAAU,GAAI,CAClC,GAAI,OAAOF,GAAU,SACnB,OAAOA,EAET,MAAMG,EAAQH,EAAM,YAAa,EAAC,KAAI,EACtC,GAAIG,IAAU,OACZ,MAAO,GAET,GAAIA,IAAU,QACZ,MAAO,GAET,GAAIA,IAAU,OACZ,OAAO,KAET,GAAIA,IAAU,MACZ,OAAO,OAAO,IAEhB,GAAIA,IAAU,WACZ,OAAO,OAAO,kBAEhB,GAAIA,IAAU,YAGd,IAAI,CAACN,GAAU,KAAKG,CAAK,EAAG,CAC1B,GAAIE,EAAQ,OACV,MAAM,IAAI,YAAY,cAAc,EAEtC,OAAOF,CACR,CACD,GAAI,CACF,OAAIL,GAAe,KAAKK,CAAK,GAAKJ,GAAqB,KAAKI,CAAK,EACxD,KAAK,MAAMA,EAAOF,EAAkB,EAEtC,KAAK,MAAME,CAAK,CACxB,OAAQI,EAAP,CACA,GAAIF,EAAQ,OACV,MAAME,EAER,OAAOJ,CACR,EACH,CCuCA,MAAMK,GAAU,KACVC,GAAe,KAEfC,GAAW,KAEXC,GAAU,MACVC,GAAe,QACfC,GAAkB,QAElBC,GAAc,QAEdC,GAAe,QAGrB,SAASC,GAAOC,EAAM,CACpB,OAAO,UAAU,GAAKA,CAAI,EAAE,QAAQH,GAAa,GAAG,CACtD,CAIA,SAASI,EAAiBC,EAAO,CAC/B,OAAOH,GAAO,OAAOG,GAAU,SAAWA,EAAQ,KAAK,UAAUA,CAAK,CAAC,EAAE,QAAQR,GAAS,KAAK,EAAE,QAAQI,GAAc,GAAG,EAAE,QAAQP,GAAS,KAAK,EAAE,QAAQC,GAAc,KAAK,EAAE,QAAQI,GAAiB,GAAG,EAAE,QAAQD,GAAc,GAAG,CAC1O,CACA,SAASQ,EAAeH,EAAM,CAC5B,OAAOC,EAAiBD,CAAI,EAAE,QAAQP,GAAU,KAAK,CACvD,CAOA,SAASW,EAAOJ,EAAO,GAAI,CACzB,GAAI,CACF,OAAO,mBAAmB,GAAKA,CAAI,CACvC,MAAI,CACA,MAAO,GAAKA,CACb,CACH,CAIA,SAASK,GAAiBL,EAAM,CAC9B,OAAOI,EAAOJ,EAAK,QAAQN,GAAS,GAAG,CAAC,CAC1C,CAKA,SAASY,GAAWC,EAAmB,GAAI,CACzC,MAAMC,EAAS,GACXD,EAAiB,KAAO,MAC1BA,EAAmBA,EAAiB,MAAM,CAAC,GAE7C,UAAWE,KAAaF,EAAiB,MAAM,GAAG,EAAG,CACnD,MAAMG,EAAID,EAAU,MAAM,eAAe,GAAK,GAC9C,GAAIC,EAAE,OAAS,EACb,SAEF,MAAMzB,EAAMmB,EAAOM,EAAE,EAAE,EACvB,GAAIzB,IAAQ,aAAeA,IAAQ,cACjC,SAEF,MAAMC,EAAQmB,GAAiBK,EAAE,IAAM,EAAE,EACrC,OAAOF,EAAOvB,GAAS,IACrB,MAAM,QAAQuB,EAAOvB,EAAI,EAC3BuB,EAAOvB,GAAK,KAAKC,CAAK,EAEtBsB,EAAOvB,GAAO,CAACuB,EAAOvB,GAAMC,CAAK,EAGnCsB,EAAOvB,GAAOC,CAEjB,CACD,OAAOsB,CACT,CACA,SAASG,GAAgB1B,EAAKC,EAAO,CAInC,OAHI,OAAOA,GAAU,UAAY,OAAOA,GAAU,aAChDA,EAAQ,OAAOA,CAAK,GAEjBA,EAGD,MAAM,QAAQA,CAAK,EACdA,EAAM,IAAK0B,GAAW,GAAGT,EAAelB,CAAG,KAAKgB,EAAiBW,CAAM,GAAG,EAAE,KAAK,GAAG,EAEtF,GAAGT,EAAelB,CAAG,KAAKgB,EAAiBf,CAAK,IAL9CiB,EAAelB,CAAG,CAM7B,CACA,SAAS4B,GAAeC,EAAO,CAC7B,OAAO,OAAO,KAAKA,CAAK,EAAE,OAAQC,GAAMD,EAAMC,KAAO,MAAM,EAAE,IAAKA,GAAMJ,GAAgBI,EAAGD,EAAMC,EAAE,CAAC,EAAE,KAAK,GAAG,CAChH,CAkGA,MAAMC,GAAwB,uBACxBC,GAAiB,sBACjBC,GAA0B,wBAChC,SAASC,EAAYC,EAAaC,EAAO,GAAI,CAI3C,OAHI,OAAOA,GAAS,YAClBA,EAAO,CAAE,eAAgBA,IAEvBA,EAAK,OACAL,GAAsB,KAAKI,CAAW,EAExCH,GAAe,KAAKG,CAAW,IAAMC,EAAK,eAAiBH,GAAwB,KAAKE,CAAW,EAAI,GAChH,CACA,MAAME,GAAoB,WAC1B,SAASC,EAAiBrB,EAAQ,GAAIsB,EAAkB,GAAO,CAC7D,OAAKA,EAGEF,GAAkB,KAAKpB,CAAK,EAF1BA,EAAM,SAAS,GAAG,CAG7B,CACA,SAASuB,GAAqBvB,EAAQ,GAAIsB,EAAkB,GAAO,CACjE,GAAI,CAACA,EACH,OAAQD,EAAiBrB,CAAK,EAAIA,EAAM,MAAM,EAAG,EAAE,EAAIA,IAAU,IAEnE,GAAI,CAACqB,EAAiBrB,EAAO,EAAI,EAC/B,OAAOA,GAAS,IAElB,KAAM,CAACwB,KAAOhB,CAAC,EAAIR,EAAM,MAAM,GAAG,EAClC,OAAQwB,EAAG,MAAM,EAAG,EAAE,GAAK,MAAQhB,EAAE,OAAS,EAAI,IAAIA,EAAE,KAAK,GAAG,IAAM,GACxE,CACA,SAASiB,EAAkBzB,EAAQ,GAAIsB,EAAkB,GAAO,CAC9D,GAAI,CAACA,EACH,OAAOtB,EAAM,SAAS,GAAG,EAAIA,EAAQA,EAAQ,IAE/C,GAAIqB,EAAiBrB,EAAO,EAAI,EAC9B,OAAOA,GAAS,IAElB,KAAM,CAACwB,KAAOhB,CAAC,EAAIR,EAAM,MAAM,GAAG,EAClC,OAAOwB,EAAK,KAAOhB,EAAE,OAAS,EAAI,IAAIA,EAAE,KAAK,GAAG,IAAM,GACxD,CACA,SAASkB,GAAgB1B,EAAQ,GAAI,CACnC,OAAOA,EAAM,WAAW,GAAG,CAC7B,CACA,SAAS2B,GAAoB3B,EAAQ,GAAI,CACvC,OAAQ0B,GAAgB1B,CAAK,EAAIA,EAAM,MAAM,CAAC,EAAIA,IAAU,GAC9D,CACA,SAAS4B,GAAiB5B,EAAQ,GAAI,CACpC,OAAO0B,GAAgB1B,CAAK,EAAIA,EAAQ,IAAMA,CAChD,CAIA,SAAS6B,GAAS7B,EAAO8B,EAAM,CAC7B,GAAIC,GAAWD,CAAI,GAAKb,EAAYjB,CAAK,EACvC,OAAOA,EAET,MAAMgC,EAAQT,GAAqBO,CAAI,EACvC,OAAI9B,EAAM,WAAWgC,CAAK,EACjBhC,EAEFiC,GAAQD,EAAOhC,CAAK,CAC7B,CAYA,SAASkC,GAAUlC,EAAOY,EAAO,CAC/B,MAAMuB,EAASC,EAASpC,CAAK,EACvBqC,EAAc,CAAE,GAAGjC,GAAW+B,EAAO,MAAM,EAAG,GAAGvB,GACvD,SAAO,OAASD,GAAe0B,CAAW,EACnCC,GAAmBH,CAAM,CAClC,CAIA,SAASJ,GAAWQ,EAAK,CACvB,MAAO,CAACA,GAAOA,IAAQ,GACzB,CACA,SAASC,GAAcD,EAAK,CAC1B,OAAOA,GAAOA,IAAQ,GACxB,CACA,SAASN,GAAQH,KAAS9B,EAAO,CAC/B,IAAIuC,EAAMT,GAAQ,GAClB,UAAWW,KAASzC,EAAM,OAAQ0C,GAASF,GAAcE,CAAI,CAAC,EAC5DH,EAAMA,EAAMd,EAAkBc,CAAG,EAAIZ,GAAoBc,CAAK,EAAIA,EAEpE,OAAOF,CACT,CAiCA,SAASI,GAAQC,EAAGC,EAAG3D,EAAU,GAAI,CACnC,OAAKA,EAAQ,gBACX0D,EAAInB,EAAkBmB,CAAC,EACvBC,EAAIpB,EAAkBoB,CAAC,GAEpB3D,EAAQ,eACX0D,EAAIhB,GAAiBgB,CAAC,EACtBC,EAAIjB,GAAiBiB,CAAC,GAEnB3D,EAAQ,WACX0D,EAAI1C,EAAO0C,CAAC,EACZC,EAAI3C,EAAO2C,CAAC,GAEPD,IAAMC,CACf,CAEA,SAAST,EAASpC,EAAQ,GAAI8C,EAAc,CAC1C,GAAI,CAAC7B,EAAYjB,EAAO,CAAE,eAAgB,EAAM,GAC9C,OAAO8C,EAAeV,EAASU,EAAe9C,CAAK,EAAI+C,GAAU/C,CAAK,EAExE,KAAM,CAACgD,EAAW,GAAIC,EAAMC,EAAc,EAAE,GAAKlD,EAAM,QAAQ,MAAO,GAAG,EAAE,MAAM,8BAA8B,GAAK,IAAI,OAAO,CAAC,EAC1H,CAACmD,EAAO,GAAIC,EAAO,EAAE,GAAKF,EAAY,MAAM,gBAAgB,GAAK,CAAE,GAAE,OAAO,CAAC,EAC7E,CAAE,WAAU,SAAQ,MAAM,EAAGH,GACjCK,EAAK,QAAQ,kBAAmB,EAAE,CACtC,EACE,MAAO,CACL,WACA,KAAMH,EAAOA,EAAK,MAAM,EAAG,KAAK,IAAI,EAAGA,EAAK,OAAS,CAAC,CAAC,EAAI,GAC3D,OACA,WACA,SACA,MACJ,CACA,CACA,SAASF,GAAU/C,EAAQ,GAAI,CAC7B,KAAM,CAACqD,EAAW,GAAIC,EAAS,GAAIC,EAAO,EAAE,GAAKvD,EAAM,MAAM,0BAA0B,GAAK,IAAI,OAAO,CAAC,EACxG,MAAO,CACL,WACA,SACA,MACJ,CACA,CAeA,SAASsC,GAAmBH,EAAQ,CAClC,MAAMqB,EAAWrB,EAAO,UAAYA,EAAO,QAAUA,EAAO,OAAO,WAAW,GAAG,EAAI,GAAK,KAAOA,EAAO,OAAS,IAAMA,EAAO,KAC9H,OAAKA,EAAO,SAGLA,EAAO,SAAW,MAAQA,EAAO,KAAOA,EAAO,KAAO,IAAM,IAAMA,EAAO,KAAOqB,EAF9EA,CAGX,CChdA,MAAMC,WAAmB,KAAM,CAC7B,aAAc,CACZ,MAAM,GAAG,SAAS,EAClB,KAAK,KAAO,YACb,CACH,CACA,SAASC,GAAiBC,EAASvE,EAAOwE,EAAU,CAClD,IAAIC,EAAU,GACVzE,IACFyE,EAAUzE,EAAM,SAEduE,GAAWC,EACbC,EAAU,GAAGA,MAAYD,EAAS,UAAUA,EAAS,eAAeD,EAAQ,SAAU,MAC7EA,IACTE,EAAU,GAAGA,MAAYF,EAAQ,SAAQ,MAE3C,MAAMG,EAAa,IAAIL,GAAWI,CAAO,EACzC,cAAO,eAAeC,EAAY,UAAW,CAC3C,KAAM,CACJ,OAAOH,CACR,CACL,CAAG,EACD,OAAO,eAAeG,EAAY,WAAY,CAC5C,KAAM,CACJ,OAAOF,CACR,CACL,CAAG,EACD,OAAO,eAAeE,EAAY,OAAQ,CACxC,KAAM,CACJ,OAAOF,GAAYA,EAAS,KAC7B,CACL,CAAG,EACD,OAAO,eAAeE,EAAY,SAAU,CAC1C,KAAM,CACJ,OAAOF,GAAYA,EAAS,MAC7B,CACL,CAAG,EACD,OAAO,eAAeE,EAAY,aAAc,CAC9C,KAAM,CACJ,OAAOF,GAAYA,EAAS,UAC7B,CACL,CAAG,EACD,OAAO,eAAeE,EAAY,aAAc,CAC9C,KAAM,CACJ,OAAOF,GAAYA,EAAS,MAC7B,CACL,CAAG,EACD,OAAO,eAAeE,EAAY,gBAAiB,CACjD,KAAM,CACJ,OAAOF,GAAYA,EAAS,UAC7B,CACL,CAAG,EACME,CACT,CAEA,MAAMC,GAAiB,IAAI,IACzB,OAAO,OAAO,CAAC,QAAS,OAAQ,MAAO,QAAQ,CAAC,CAClD,EACA,SAASC,GAAgBC,EAAS,MAAO,CACvC,OAAOF,GAAe,IAAIE,EAAO,YAAa,EAChD,CACA,SAASC,GAAmBlF,EAAO,CACjC,GAAIA,IAAU,OACZ,MAAO,GAET,MAAM,EAAI,OAAOA,EACjB,OAAI,IAAM,UAAY,IAAM,UAAY,IAAM,WAAa,IAAM,KACxD,GAEL,IAAM,SACD,GAEL,MAAM,QAAQA,CAAK,EACd,GAEFA,EAAM,aAAeA,EAAM,YAAY,OAAS,UAAY,OAAOA,EAAM,QAAW,UAC7F,CACA,MAAMmF,GAA4B,IAAI,IAAI,CACxC,YACA,kBACA,oBACA,kBACF,CAAC,EACKC,GAAU,oDAChB,SAASC,GAAmBC,EAAe,GAAI,CAC7C,GAAI,CAACA,EACH,MAAO,OAET,MAAMC,EAAcD,EAAa,MAAM,GAAG,EAAE,MAAO,GAAI,GACvD,OAAIF,GAAQ,KAAKG,CAAW,EACnB,OAELJ,GAAU,IAAII,CAAW,GAAKA,EAAY,WAAW,OAAO,EACvD,OAEF,MACT,CAEA,MAAMC,GAAmC,IAAI,IAAI,CAC/C,IAEA,IAEA,IAEA,IAEA,IAEA,IAEA,IAEA,GAEF,CAAC,EACD,SAASC,GAAYC,EAAe,CAClC,KAAM,CAAE,QAAO,SAAS,EAAGA,EAC3B,SAASC,EAAQC,EAAS,CACxB,MAAMC,EAAUD,EAAQ,OAASA,EAAQ,MAAM,OAAS,cAAgB,GACxE,GAAIA,EAAQ,QAAQ,QAAU,IAAS,CAACC,EAAS,CAC/C,IAAIC,EACA,OAAOF,EAAQ,QAAQ,OAAU,SACnCE,EAAUF,EAAQ,QAAQ,MAE1BE,EAAUd,GAAgBY,EAAQ,QAAQ,MAAM,EAAI,EAAI,EAE1D,MAAMG,EAAeH,EAAQ,UAAYA,EAAQ,SAAS,QAAU,IACpE,GAAIE,EAAU,GAAKN,GAAiB,IAAIO,CAAY,EAClD,OAAOC,EAAUJ,EAAQ,QAAS,CAChC,GAAGA,EAAQ,QACX,MAAOE,EAAU,CAC3B,CAAS,CAEJ,CACD,MAAM1F,EAAQsE,GACZkB,EAAQ,QACRA,EAAQ,MACRA,EAAQ,QACd,EACI,MAAI,MAAM,mBACR,MAAM,kBAAkBxF,EAAO4F,CAAS,EAEpC5F,CACP,CACD,MAAM4F,EAAY,eAA0BC,EAAUC,EAAW,GAAI,CACnE,MAAMN,EAAU,CACd,QAASK,EACT,QAAS,CAAE,GAAGP,EAAc,SAAU,GAAGQ,CAAU,EACnD,SAAU,OACV,MAAO,MACb,EACQN,EAAQ,QAAQ,WAClB,MAAMA,EAAQ,QAAQ,UAAUA,CAAO,EAErC,OAAOA,EAAQ,SAAY,WACzBA,EAAQ,QAAQ,UAClBA,EAAQ,QAAU/C,GAAS+C,EAAQ,QAASA,EAAQ,QAAQ,OAAO,IAEjEA,EAAQ,QAAQ,OAASA,EAAQ,QAAQ,UAC3CA,EAAQ,QAAU1C,GAAU0C,EAAQ,QAAS,CAC3C,GAAGA,EAAQ,QAAQ,OACnB,GAAGA,EAAQ,QAAQ,KAC7B,CAAS,GAECA,EAAQ,QAAQ,MAAQZ,GAAgBY,EAAQ,QAAQ,MAAM,GAAKV,GAAmBU,EAAQ,QAAQ,IAAI,IAC5GA,EAAQ,QAAQ,KAAO,OAAOA,EAAQ,QAAQ,MAAS,SAAWA,EAAQ,QAAQ,KAAO,KAAK,UAAUA,EAAQ,QAAQ,IAAI,EAC5HA,EAAQ,QAAQ,QAAU,IAAIO,EAAQP,EAAQ,QAAQ,OAAO,EACxDA,EAAQ,QAAQ,QAAQ,IAAI,cAAc,GAC7CA,EAAQ,QAAQ,QAAQ,IAAI,eAAgB,kBAAkB,EAE3DA,EAAQ,QAAQ,QAAQ,IAAI,QAAQ,GACvCA,EAAQ,QAAQ,QAAQ,IAAI,SAAU,kBAAkB,IAI9DA,EAAQ,SAAW,MAAMQ,EACvBR,EAAQ,QACRA,EAAQ,OACd,EAAM,MAAM,MAAOxF,IACbwF,EAAQ,MAAQxF,EACZwF,EAAQ,QAAQ,gBAClB,MAAMA,EAAQ,QAAQ,eAAeA,CAAO,EAEvCD,EAAQC,CAAO,EACvB,EACD,MAAMS,GAAgBT,EAAQ,QAAQ,cAAgB,OAASA,EAAQ,QAAQ,eAAiBP,GAAmBO,EAAQ,SAAS,QAAQ,IAAI,cAAc,GAAK,EAAE,EACrK,GAAIS,IAAiB,OAAQ,CAC3B,MAAMC,EAAO,MAAMV,EAAQ,SAAS,KAAI,EAClCW,EAAgBX,EAAQ,QAAQ,eAAiB3F,GACvD2F,EAAQ,SAAS,MAAQW,EAAcD,CAAI,CACjD,MAAeD,IAAiB,SAC1BT,EAAQ,SAAS,MAAQA,EAAQ,SAAS,KAE1CA,EAAQ,SAAS,MAAQ,MAAMA,EAAQ,SAASS,KAKlD,OAHIT,EAAQ,QAAQ,YAClB,MAAMA,EAAQ,QAAQ,WAAWA,CAAO,EAEtCA,EAAQ,SAAS,QAAU,KAAOA,EAAQ,SAAS,OAAS,KAC1DA,EAAQ,QAAQ,iBAClB,MAAMA,EAAQ,QAAQ,gBAAgBA,CAAO,EAExCD,EAAQC,CAAO,GAEjBA,EAAQ,QACnB,EACQY,EAAS,SAAiB7B,EAASzE,EAAS,CAChD,OAAO8F,EAAUrB,EAASzE,CAAO,EAAE,KAAMuG,GAAMA,EAAE,KAAK,CAC1D,EACE,SAAO,IAAMT,EACbQ,EAAO,OAASJ,EAChBI,EAAO,OAAS,CAACE,EAAiB,KAAOjB,GAAY,CACnD,GAAGC,EACH,SAAU,CACR,GAAGA,EAAc,SACjB,GAAGgB,CACJ,CACL,CAAG,EACMF,CACT,CC1NA,MAAMG,GAAc,UAAW,CAC7B,GAAI,OAAO,WAAe,IACxB,OAAO,WAET,GAAI,OAAO,KAAS,IAClB,OAAO,KAKT,GAAI,OAAO,OAAW,IACpB,OAAO,OAET,MAAM,IAAI,MAAM,gCAAgC,CAClD,IACMP,GAAQO,GAAY,QAAU,IAAM,QAAQ,OAAO,IAAI,MAAM,yCAAyC,CAAC,GACvGR,GAAUQ,GAAY,QACtBC,GAASnB,GAAY,CAAE,SAAO,UAAS,GACvCe,GAASI,GCrBTC,GAAYC,GAAgB,EAAG,IACxBC,GAAU,IAAMF,GAAU,QCHvC,SAASG,EAAUC,EAAaC,EAAQ,GAAIC,EAAY,CACtD,UAAWpH,KAAOkH,EAAa,CAC7B,MAAMG,EAAUH,EAAYlH,GACtBsH,EAAOF,EAAa,GAAGA,KAAcpH,IAAQA,EAC/C,OAAOqH,GAAY,UAAYA,IAAY,KAC7CJ,EAAUI,EAASF,EAAOG,CAAI,EACrB,OAAOD,GAAY,aAC5BF,EAAMG,GAAQD,EAEjB,CACD,OAAOF,CACT,CA6BA,MAAMI,GAAc,CAAE,IAAMC,GAAcA,EAAW,GAC/CC,GAAc,IAAMF,GACpBG,GAAa,OAAO,QAAQ,WAAe,IAAc,QAAQ,WAAaD,GACpF,SAASE,GAAiBR,EAAOS,EAAM,CACrC,MAAMN,EAAOM,EAAK,QACZC,EAAOH,GAAWJ,CAAI,EAC5B,OAAOH,EAAM,OACX,CAACW,EAASC,IAAiBD,EAAQ,KAAK,IAAMD,EAAK,IAAI,IAAME,EAAa,GAAGH,CAAI,CAAC,CAAC,EACnF,QAAQ,QAAS,CACrB,CACA,CACA,SAASI,GAAmBb,EAAOS,EAAM,CACvC,MAAMN,EAAOM,EAAK,QACZC,EAAOH,GAAWJ,CAAI,EAC5B,OAAO,QAAQ,IAAIH,EAAM,IAAKc,GAASJ,EAAK,IAAI,IAAMI,EAAK,GAAGL,CAAI,CAAC,CAAC,CAAC,CACvE,CAUA,SAASM,EAAaC,EAAWC,EAAM,CACrC,UAAWC,IAAY,CAAC,GAAGF,CAAS,EAClCE,EAASD,CAAI,CAEjB,CAEA,MAAME,EAAS,CACb,aAAc,CACZ,KAAK,OAAS,GACd,KAAK,QAAU,OACf,KAAK,OAAS,OACd,KAAK,oBAAsB,OAC3B,KAAK,iBAAmB,GACxB,KAAK,KAAO,KAAK,KAAK,KAAK,IAAI,EAC/B,KAAK,SAAW,KAAK,SAAS,KAAK,IAAI,EACvC,KAAK,aAAe,KAAK,aAAa,KAAK,IAAI,CAChD,CACD,KAAKhB,EAAME,EAAWrH,EAAU,GAAI,CAClC,GAAI,CAACmH,GAAQ,OAAOE,GAAc,WAChC,MAAO,IAAM,CACnB,EAEI,MAAMe,EAAejB,EACrB,IAAIkB,EACJ,KAAO,KAAK,iBAAiBlB,IAC3BkB,EAAM,KAAK,iBAAiBlB,GAC5BA,EAAOkB,EAAI,GAEb,GAAIA,GAAO,CAACrI,EAAQ,gBAAiB,CACnC,IAAI2E,EAAU0D,EAAI,QACb1D,IACHA,EAAU,GAAGyD,8BAA2CC,EAAI,GAAK,gBAAgBA,EAAI,KAAO,KAEzF,KAAK,sBACR,KAAK,oBAAsC,IAAI,KAE5C,KAAK,oBAAoB,IAAI1D,CAAO,IACvC,QAAQ,KAAKA,CAAO,EACpB,KAAK,oBAAoB,IAAIA,CAAO,EAEvC,CACD,GAAI,CAAC0C,EAAU,KACb,GAAI,CACF,OAAO,eAAeA,EAAW,OAAQ,CACvC,IAAK,IAAM,IAAMF,EAAK,QAAQ,OAAQ,GAAG,EAAI,WAC7C,aAAc,EACxB,CAAS,CACT,MAAQ,CACD,CAEH,YAAK,OAAOA,GAAQ,KAAK,OAAOA,IAAS,GACzC,KAAK,OAAOA,GAAM,KAAKE,CAAS,EACzB,IAAM,CACPA,IACF,KAAK,WAAWF,EAAME,CAAS,EAC/BA,EAAY,OAEpB,CACG,CACD,SAASF,EAAME,EAAW,CACxB,IAAIiB,EACAC,EAAY,IAAIC,KACd,OAAOF,GAAW,YACpBA,IAEFA,EAAS,OACTC,EAAY,OACLlB,EAAU,GAAGmB,CAAU,GAEhC,SAAS,KAAK,KAAKrB,EAAMoB,CAAS,EAC3BD,CACR,CACD,WAAWnB,EAAME,EAAW,CAC1B,GAAI,KAAK,OAAOF,GAAO,CACrB,MAAM5D,EAAQ,KAAK,OAAO4D,GAAM,QAAQE,CAAS,EAC7C9D,IAAU,IACZ,KAAK,OAAO4D,GAAM,OAAO5D,EAAO,CAAC,EAE/B,KAAK,OAAO4D,GAAM,SAAW,GAC/B,OAAO,KAAK,OAAOA,EAEtB,CACF,CACD,cAAcA,EAAMsB,EAAY,CAC9B,KAAK,iBAAiBtB,GAAQ,OAAOsB,GAAe,SAAW,CAAE,GAAIA,CAAY,EAAGA,EACpF,MAAMC,EAAS,KAAK,OAAOvB,IAAS,GACpC,OAAO,KAAK,OAAOA,GACnB,UAAWW,KAAQY,EACjB,KAAK,KAAKvB,EAAMW,CAAI,CAEvB,CACD,eAAea,EAAiB,CAC9B,OAAO,OAAO,KAAK,iBAAkBA,CAAe,EACpD,UAAWxB,KAAQwB,EACjB,KAAK,cAAcxB,EAAMwB,EAAgBxB,EAAK,CAEjD,CACD,SAASJ,EAAa,CACpB,MAAMC,EAAQF,EAAUC,CAAW,EAC7B6B,EAAY,OAAO,KAAK5B,CAAK,EAAE,IAClCnH,GAAQ,KAAK,KAAKA,EAAKmH,EAAMnH,EAAI,CACxC,EACI,MAAO,IAAM,CACX,UAAWgJ,KAASD,EAAU,OAAO,EAAGA,EAAU,MAAM,EACtDC,GAER,CACG,CACD,YAAY9B,EAAa,CACvB,MAAMC,EAAQF,EAAUC,CAAW,EACnC,UAAWlH,KAAOmH,EAChB,KAAK,WAAWnH,EAAKmH,EAAMnH,EAAI,CAElC,CACD,gBAAiB,CACf,UAAWA,KAAO,KAAK,OACrB,OAAO,KAAK,OAAOA,EAEtB,CACD,SAASsH,KAASqB,EAAY,CAC5B,SAAW,QAAQrB,CAAI,EAChB,KAAK,aAAaK,GAAkBL,EAAM,GAAGqB,CAAU,CAC/D,CACD,iBAAiBrB,KAASqB,EAAY,CACpC,SAAW,QAAQrB,CAAI,EAChB,KAAK,aAAaU,GAAoBV,EAAM,GAAGqB,CAAU,CACjE,CACD,aAAaM,EAAQ3B,KAASqB,EAAY,CACxC,MAAMO,EAAQ,KAAK,SAAW,KAAK,OAAS,CAAE,OAAM,KAAMP,EAAY,QAAS,EAAI,EAAG,OAClF,KAAK,SACPT,EAAa,KAAK,QAASgB,CAAK,EAElC,MAAMC,EAASF,EACb3B,KAAQ,KAAK,OAAS,CAAC,GAAG,KAAK,OAAOA,EAAK,EAAI,CAAE,EACjDqB,CACN,EACI,OAAIQ,aAAkB,QACbA,EAAO,QAAQ,IAAM,CACtB,KAAK,QAAUD,GACjBhB,EAAa,KAAK,OAAQgB,CAAK,CAEzC,CAAO,GAEC,KAAK,QAAUA,GACjBhB,EAAa,KAAK,OAAQgB,CAAK,EAE1BC,EACR,CACD,WAAW3B,EAAW,CACpB,YAAK,QAAU,KAAK,SAAW,GAC/B,KAAK,QAAQ,KAAKA,CAAS,EACpB,IAAM,CACX,GAAI,KAAK,UAAY,OAAQ,CAC3B,MAAM9D,EAAQ,KAAK,QAAQ,QAAQ8D,CAAS,EACxC9D,IAAU,IACZ,KAAK,QAAQ,OAAOA,EAAO,CAAC,CAE/B,CACP,CACG,CACD,UAAU8D,EAAW,CACnB,YAAK,OAAS,KAAK,QAAU,GAC7B,KAAK,OAAO,KAAKA,CAAS,EACnB,IAAM,CACX,GAAI,KAAK,SAAW,OAAQ,CAC1B,MAAM9D,EAAQ,KAAK,OAAO,QAAQ8D,CAAS,EACvC9D,IAAU,IACZ,KAAK,OAAO,OAAOA,EAAO,CAAC,CAE9B,CACP,CACG,CACH,CACA,SAAS0F,IAAc,CACrB,OAAO,IAAId,EACb,CChPA,SAASe,GAAcjH,EAAO,GAAI,CAChC,IAAIkH,EACAC,EAAc,GAClB,MAAMC,EAAiBC,GAAa,CAClC,GAAIH,GAAmBA,IAAoBG,EACzC,MAAM,IAAI,MAAM,kBAAkB,CAExC,EACE,IAAIC,EACJ,GAAItH,EAAK,aAAc,CACrB,MAAMuH,EAAqBvH,EAAK,mBAAqB,WAAW,kBAC5DuH,EACFD,EAAM,IAAIC,EAEV,QAAQ,KAAK,8CAA8C,CAE9D,CACD,MAAMC,EAAsB,IAAM,CAChC,GAAIF,GAAOJ,IAAoB,OAAQ,CACrC,MAAMG,EAAWC,EAAI,WACrB,GAAID,IAAa,OACf,OAAOA,CAEV,CACD,OAAOH,CACX,EACE,MAAO,CACL,IAAK,IAAM,CACT,MAAMO,EAAYD,IAClB,GAAIC,IAAc,OAChB,MAAM,IAAI,MAAM,0BAA0B,EAE5C,OAAOA,CACR,EACD,OAAQ,IACCD,EAAmB,EAE5B,IAAK,CAACH,EAAUK,IAAY,CACrBA,GACHN,EAAcC,CAAQ,EAExBH,EAAkBG,EAClBF,EAAc,EACf,EACD,MAAO,IAAM,CACXD,EAAkB,OAClBC,EAAc,EACf,EACD,KAAM,CAACE,EAAUpB,IAAa,CAC5BmB,EAAcC,CAAQ,EACtBH,EAAkBG,EAClB,GAAI,CACF,OAAOC,EAAMA,EAAI,IAAID,EAAUpB,CAAQ,EAAIA,GACnD,QAAgB,CACHkB,IACHD,EAAkB,OAErB,CACF,EACD,MAAM,UAAUG,EAAUpB,EAAU,CAClCiB,EAAkBG,EAClB,MAAMM,EAAY,IAAM,CACtBT,EAAkBG,CAC1B,EACYO,EAAU,IAAMV,IAAoBG,EAAWM,EAAY,OACjEE,GAAc,IAAID,CAAO,EACzB,GAAI,CACF,MAAMtD,EAAIgD,EAAMA,EAAI,IAAID,EAAUpB,CAAQ,EAAIA,IAC9C,OAAKkB,IACHD,EAAkB,QAEb,MAAM5C,CACrB,QAAgB,CACRuD,GAAc,OAAOD,CAAO,CAC7B,CACF,CACL,CACA,CACA,SAASE,GAAgBC,EAAc,GAAI,CACzC,MAAMC,EAAW,GACjB,MAAO,CACL,IAAIpK,EAAKoC,EAAO,GAAI,CAClB,OAAKgI,EAASpK,KACZoK,EAASpK,GAAOqJ,GAAc,CAAE,GAAGc,EAAa,GAAG/H,CAAI,CAAE,GAE3DgI,EAASpK,GACFoK,EAASpK,EACjB,CACL,CACA,CACA,MAAM4G,EAAc,OAAO,WAAe,IAAc,WAAa,OAAO,KAAS,IAAc,KAAO,OAAO,OAAW,IAAc,OAAkD,GACtLyD,GAAY,YACZC,GAAmB1D,EAAYyD,MAAezD,EAAYyD,IAAaH,GAAe,GACtFK,GAAa,CAACvK,EAAKoC,EAAO,KAAOkI,GAAiB,IAAItK,EAAKoC,CAAI,EAE/DoI,GAAmB,2BACnBP,GAAgBrD,EAAY4D,MAAsB5D,EAAY4D,IAAoC,IAAI,KC7FtGC,GAAaF,GAAW,UAAU,EAC3BG,GAAsB,gBAmG5B,SAASC,GAAiBC,EAAU,CA2BzC,OAvBgBA,EAAS,IAAKC,GACxB,OAAOA,GAAW,WAEb,KAELA,EAAO,OAAS,EAEVC,GAAYD,EAAOC,EAASA,EAAQ,OAAO,EAK9CD,CACR,EAAE,OAAO,OAAO,CAWnB,CACO,SAASE,EAAiBF,EAAQ,CACvC,SAAOH,IAAuB,GACvBG,CACT,CAIO,SAASG,EAAaC,EAAMC,EAAOtD,EAAM,CAC9C,MAAMuD,EAAK,IAAMvD,EAAOsD,EAAM,GAAGtD,CAAI,EAAIsD,IAEvC,OAAOT,GAAW,UAAUQ,EAAME,CAAE,CAKxC,CACO,SAASC,GAAa,CAC3B,MAAMC,EAAkBZ,GAAW,SACnC,GAAI,CAACY,EAAiB,CACpB,MAAMC,EAAKC,IACX,GAAI,CAACD,EACH,MAAM,IAAI,MAAM,2BAA2B,EAE7C,OAAOA,EAAG,WAAW,IAAI,KAC1B,CACD,OAAOD,CACT,CACO,SAAStE,IAAmB,CACjC,OAAOqE,EAAY,EAAC,OACtB,CCjKA,SAASI,EAASvL,EAAO,CACvB,OAAOA,IAAU,MAAQ,OAAOA,GAAU,QAC5C,CACA,SAASwL,EAAMC,EAAYC,EAAUC,EAAY,IAAKC,EAAQ,CAC5D,GAAI,CAACL,EAASG,CAAQ,EACpB,OAAOF,EAAMC,EAAY,CAAE,EAAEE,EAAWC,CAAM,EAEhD,MAAMtK,EAAS,OAAO,OAAO,CAAE,EAAEoK,CAAQ,EACzC,UAAW3L,KAAO0L,EAAY,CAC5B,GAAI1L,IAAQ,aAAeA,IAAQ,cACjC,SAEF,MAAMC,EAAQyL,EAAW1L,GACrBC,GAAU,OAGV4L,GAAUA,EAAOtK,EAAQvB,EAAKC,EAAO2L,CAAS,IAG9C,MAAM,QAAQ3L,CAAK,GAAK,MAAM,QAAQsB,EAAOvB,EAAI,EACnDuB,EAAOvB,GAAO,CAAC,GAAGC,EAAO,GAAGsB,EAAOvB,EAAI,EAC9BwL,EAASvL,CAAK,GAAKuL,EAASjK,EAAOvB,EAAI,EAChDuB,EAAOvB,GAAOyL,EACZxL,EACAsB,EAAOvB,IACN4L,EAAY,GAAGA,KAAe,IAAM5L,EAAI,SAAU,EACnD6L,CACR,EAEMtK,EAAOvB,GAAOC,GAEjB,CACD,OAAOsB,CACT,CACA,SAASuK,GAAWD,EAAQ,CAC1B,MAAO,IAAIlD,IAETA,EAAW,OAAO,CAACoD,EAAGC,IAAMP,EAAMM,EAAGC,EAAG,GAAIH,CAAM,EAAG,EAAE,CAE3D,CAEA,MAAMI,GAASH,GAAW,CAACvK,EAAQvB,EAAKkM,IAAiB,CACvD,GAAI,OAAO3K,EAAOvB,GAAS,KAAe,OAAOkM,GAAiB,WAChE,SAAOlM,GAAOkM,EAAa3K,EAAOvB,EAAI,EAC/B,EAEX,CAAC,ECmDD,MAAMmM,UAAgB,KAAM,CAC1B,aAAc,CACZ,MAAM,GAAG,SAAS,EAClB,KAAK,WAAa,IAClB,KAAK,MAAQ,GACb,KAAK,UAAY,GACjB,KAAK,cAAgB,MACtB,CACD,QAAS,CACP,MAAMC,EAAM,CACV,QAAS,KAAK,QACd,WAAYC,EAAmB,KAAK,WAAY,GAAG,CACzD,EACI,OAAI,KAAK,gBACPD,EAAI,cAAgBE,GAAsB,KAAK,aAAa,GAE1D,KAAK,OAAS,SAChBF,EAAI,KAAO,KAAK,MAEXA,CACR,CACH,CACAD,EAAQ,aAAe,GACvB,SAASI,GAAYtL,EAAO,OAC1B,GAAI,OAAOA,GAAU,SACnB,OAAO,IAAIkL,EAAQlL,CAAK,EAE1B,GAAIuL,GAAQvL,CAAK,EACf,OAAOA,EAET,MAAMwL,EAAM,IAAIN,GACdO,IAAM,UAAN,OAAiBzL,EAAM,cAEvBA,EAAM,MAAQ,CAAE,MAAOA,EAAM,KAAO,EAAG,MAC3C,EACE,GAAI,UAAWA,EACb,GAAI,CACF,OAAO,eAAewL,EAAK,QAAS,CAClC,KAAM,CACJ,OAAOxL,EAAM,KACd,CACT,CAAO,CACP,MAAM,CACA,GAAI,CACFwL,EAAI,MAAQxL,EAAM,KAC1B,MAAQ,CACD,CACF,CAeH,GAbIA,EAAM,OACRwL,EAAI,KAAOxL,EAAM,MAEfA,EAAM,WACRwL,EAAI,WAAaJ,EAAmBpL,EAAM,WAAYwL,EAAI,UAAU,EAC3DxL,EAAM,SACfwL,EAAI,WAAaJ,EAAmBpL,EAAM,OAAQwL,EAAI,UAAU,GAE9DxL,EAAM,cACRwL,EAAI,cAAgBxL,EAAM,cACjBA,EAAM,aACfwL,EAAI,cAAgBxL,EAAM,YAExBwL,EAAI,cAAe,CACrB,MAAME,EAAkBF,EAAI,cACHH,GAAsBG,EAAI,aAAa,IACvCE,GACvB,QAAQ,KACN,sJACR,CAEG,CACD,OAAI1L,EAAM,QAAU,SAClBwL,EAAI,MAAQxL,EAAM,OAEhBA,EAAM,YAAc,SACtBwL,EAAI,UAAYxL,EAAM,WAEjBwL,CACT,CAuBA,SAASD,GAAQvL,EAAO,OACtB,QAAOyL,mBAAO,cAAP,cAAoB,gBAAiB,EAC9C,CAmLA,MAAME,GAAQ,CACZ,KAAM,YACN,KAAM,kBACR,EAiFMC,GAA0B,0BAChC,SAASP,GAAsBQ,EAAgB,GAAI,CACjD,OAAOA,EAAc,QAAQD,GAAyB,EAAE,CAC1D,CACA,SAASR,EAAmBU,EAAYC,EAAoB,IAAK,CAO/D,MANI,CAACD,IAGD,OAAOA,GAAe,WACxBA,EAAa,OAAO,SAASA,EAAY,EAAE,GAEzCA,EAAa,KAAOA,EAAa,KAC5BC,EAEFD,CACT,CAuIA,MAAME,GAAQ,OAAO,aAAiB,IAAc,aAAgB9B,GAAOA,IAC3E,SAAS+B,GAAKhE,EAAO3C,EAAM4G,EAAM,CAC/B,OAAIA,GACFC,GAAmBlE,EAAOiE,CAAI,EAEzB,IAAI,QAASE,GAAY,CAC9BJ,GAAM,IAAM,CACV/D,EAAM,KAAK,IAAI,IAAI3C,CAAI,EACvB8G,GACN,CAAK,CACL,CAAG,CACH,CAyBA,SAASD,GAAmBlE,EAAOiE,EAAM,CACnCA,GAAQ,CAACjE,EAAM,KAAK,IAAI,UAAU,cAAc,GAClDA,EAAM,KAAK,IAAI,UAAU,eAAgBiE,CAAI,CAEjD,CACA,SAASG,GAAapE,EAAOqE,EAAUC,EAAO,IAAK,CACjDtE,EAAM,KAAK,IAAI,WAAamD,EAC1BmB,EACAtE,EAAM,KAAK,IAAI,UACnB,EACEA,EAAM,KAAK,IAAI,UAAU,WAAYqE,CAAQ,EAE7C,MAAME,EAAO,yEADMF,EAAS,QAAQ,KAAM,KAAK,oBAE/C,OAAOL,GAAKhE,EAAOuE,EAAMb,GAAM,IAAI,CACrC,CAuBA,SAASc,GAAqBxE,EAAO5B,EAAMrH,EAAO,CAChD,IAAI0N,EAAUzE,EAAM,KAAK,IAAI,UAAU5B,CAAI,EAC3C,GAAI,CAACqG,EAAS,CACZzE,EAAM,KAAK,IAAI,UAAU5B,EAAMrH,CAAK,EACpC,MACD,CACI,MAAM,QAAQ0N,CAAO,IACxBA,EAAU,CAACA,EAAQ,SAAQ,CAAE,GAE/BzE,EAAM,KAAK,IAAI,UAAU5B,EAAM,CAAC,GAAGqG,EAAS1N,CAAK,CAAC,CACpD,CACA,MAAM2N,GAAeF,GCtrBRG,GAAW,IAAMC,GAAM1C,EAAY,EAAC,QAAS,OAAO,EACpD2C,GAAaC,GAAS,CACjC,MAAMvB,EAAMF,GAAYyB,CAAI,EAC5B,GAAI,CACc5C,IACR,SAAS,YAAaqB,CAAG,EACjC,MAAMpM,EAAQwN,KACdxN,EAAM,MAAQA,EAAM,OAASoM,CACjC,MAAI,CACA,MAAMA,CACP,CACD,OAAOA,CACT,EAWO,MAAMF,GAAeE,GAAQ,CAClC,MAAMuB,EAAOC,GAAaxB,CAAG,EAC7B,SAAK,aAAe,GACbuB,CACT,EC5BO,SAASE,MAAYtG,EAAM,CAChC,MAAMuG,EAAU,OAAOvG,EAAKA,EAAK,OAAS,IAAO,SAAWA,EAAK,IAAK,EAAG,OACrE,OAAOA,EAAK,IAAO,UACrBA,EAAK,QAAQuG,CAAO,EAEtB,KAAM,CAACC,EAAMC,CAAI,EAAIzG,EACrB,GAAI,CAACwG,GAAQ,OAAOA,GAAS,SAC3B,MAAM,IAAI,UAAU,2CAA6CA,CAAI,EAEvE,GAAIC,IAAS,QAAU,OAAOA,GAAS,WACrC,MAAM,IAAI,MAAM,8CAAgDA,CAAI,EAEtE,MAAMrO,EAAM,KAAOoO,EACbnD,EAAOG,IACPkD,EAAQR,GAAM7C,EAAK,QAAQ,MAAOjL,CAAG,EAC3C,GAAIsO,EAAM,QAAU,QAAUD,EAAM,CAClC,MAAME,EAAeF,IACrB,GAAIG,GAAMD,CAAY,EACpB,SAAK,QAAQ,MAAMvO,GAAOuO,EACnBA,EAETD,EAAM,MAAQC,CACf,CACD,OAAOD,CACT,CCpBO,MAAMG,GAAY,IAAM,OAC7B,OAAO/B,IAAY,IAAZ,cAAc,OACvB,EAuCagC,GAAa,CAACC,EAAIxO,IAAY,CACpCwO,IACHA,EAAK,KAEP,MAAMC,EAAS,OAAOD,GAAO,SAAWA,EAAKA,EAAG,MAAQ,IAClDE,EAAa3M,EAAY0M,EAAQ,EAAI,EAC3C,GAAIC,GAAc,EAAC1O,WAAS,UAC1B,MAAM,IAAI,MAAM,mGAAmG,EAErH,GAAI0O,GAAcxL,EAASuL,CAAM,EAAE,WAAa,UAC9C,MAAM,IAAI,MAAM,iDAAiD,EAKnE,MAAME,EAASL,KACK,CAClB,MAAM3D,EAAUM,IAChB,GAAIN,EAAQ,YAAcA,EAAQ,WAAW,MAAO,CAClD,MAAMiE,EAAmBF,EAAaD,EAAS1L,GAAQ6D,GAAgB,EAAG,IAAI,QAAS+H,EAAO,QAAQH,CAAE,EAAE,UAAY,GAAG,EACzH,OAAO7D,EAAQ,SAAS,gBAAgB,EAAE,KAAK,IAAMwC,GAAaxC,EAAQ,WAAW,MAAOiE,GAAkB5O,iBAAS,eAAgB,GAAG,CAAC,CAC5I,CACF,CACD,OAAI0O,GACE1O,WAAS,QACX,SAAS,QAAQyO,CAAM,EAEvB,SAAS,KAAOA,EAEX,QAAQ,WAEVzO,WAAS,QAAU2O,EAAO,QAAQH,CAAE,EAAIG,EAAO,KAAKH,CAAE,CAC/D,EC/EMhD,GAAW,CACf,cAAe,GACf,YAAa,GACb,qBAAsB,GACtB,0BAA2B,GAC3B,iBAAkB,GAClB,gBAAiB,GACjB,cAAe,EACjB,EACA,SAASqD,GAAWzN,EAAQpB,EAAU,GAAI,CACxCA,EAAU,CAAE,GAAGwL,GAAU,GAAGxL,CAAO,EACnC,MAAM8O,EAASC,GAAa/O,CAAO,EACnC,SAAO,SAASoB,CAAM,EACf0N,EAAO,UAChB,CACA,SAASC,GAAa/O,EAAS,CAC7B,MAAMgP,EAAO,GACb,IAAItJ,EAAU,GACd,MAAMuJ,EAASC,GAAQ,CACrBF,EAAK,KAAKE,CAAG,CACjB,EACE,MAAO,CACL,UAAW,CACT,OAAOF,EAAK,KAAK,EAAE,CACpB,EACD,YAAa,CACX,OAAOtJ,CACR,EACD,SAAS5F,EAAO,CACd,OAAIE,EAAQ,WACVF,EAAQE,EAAQ,SAASF,CAAK,GAGzB,KAAK,KADCA,IAAU,KAAO,OAAS,OAAOA,IACtBA,CAAK,CAC9B,EACD,QAAQsB,EAAQ,CACd,GAAIA,GAAU,OAAOA,EAAO,QAAW,WACrC,OAAO,KAAK,QAAQA,EAAO,OAAQ,GAErC,MAAM+N,EAAU,kBACVC,EAAY,OAAO,UAAU,SAAS,KAAKhO,CAAM,EACjDiO,EAAWF,EAAQ,KAAKC,CAAS,EACjCE,EAAUD,EAAWA,EAAS,GAAG,YAAa,EAAG,YAAcD,EAAU,YAAW,EAAK,IAC/F,IAAIG,EAAe,KACnB,IAAKA,EAAe7J,EAAQ,QAAQtE,CAAM,IAAM,EAC9C,OAAO,KAAK,SAAS,aAAemO,EAAe,GAAG,EAIxD,GAFE7J,EAAQ,KAAKtE,CAAM,EAEjB,OAAO,OAAW,KAAe,OAAO,UAAY,OAAO,SAASA,CAAM,EAC5E,SAAM,SAAS,EACR6N,EAAM7N,EAAO,SAAS,MAAM,CAAC,EAEtC,GAAIkO,IAAY,UAAYA,IAAY,YAAcA,IAAY,gBAC5D,KAAK,IAAMA,GACb,KAAK,IAAMA,GAASlO,CAAM,EAChBpB,EAAQ,eAClB,KAAK,QAAQoB,EAAQkO,CAAO,MAEzB,CACL,IAAIE,EAAO,OAAO,KAAKpO,CAAM,EACzBpB,EAAQ,mBACVwP,EAAOA,EAAK,QAEVxP,EAAQ,cAAgB,IAAS,CAACyP,GAAiBrO,CAAM,GAC3DoO,EAAK,OAAO,EAAG,EAAG,YAAa,YAAa,WAAW,EAErDxP,EAAQ,cACVwP,EAAOA,EAAK,OAAO,SAAS3P,EAAK,CAC/B,MAAO,CAACG,EAAQ,YAAYH,CAAG,CAC3C,CAAW,GAEHoP,EAAM,UAAYO,EAAK,OAAS,GAAG,EACnC,UAAW3P,KAAO2P,EAChB,KAAK,SAAS3P,CAAG,EACjBoP,EAAM,GAAG,EACJjP,EAAQ,eACX,KAAK,SAASoB,EAAOvB,EAAI,EAE3BoP,EAAM,GAAG,CAEZ,CACF,EACD,OAAOS,EAAKC,EAAW,CAGrB,GAFAA,EAAY,OAAOA,EAAc,IAAcA,EAAY3P,EAAQ,kBAAoB,GACvFiP,EAAM,SAAWS,EAAI,OAAS,GAAG,EAC7B,CAACC,GAAaD,EAAI,QAAU,EAAG,CACjC,UAAWE,KAASF,EAClB,KAAK,SAASE,CAAK,EAErB,MACD,CACD,MAAMC,EAAmB,GACnBC,EAAUJ,EAAI,IAAKE,GAAU,CACjC,MAAMd,EAASC,GAAa/O,CAAO,EACnC,SAAO,SAAS4P,CAAK,EACrBC,EAAiB,KAAKf,EAAO,WAAY,GAClCA,EAAO,UACtB,CAAO,EACD,SAAU,CAAC,GAAGpJ,EAAS,GAAGmK,CAAgB,EAC1CC,EAAQ,KAAI,EACL,KAAK,OAAOA,EAAS,EAAK,CAClC,EACD,MAAMC,EAAM,CACV,OAAOd,EAAM,QAAUc,EAAK,OAAQ,EACrC,EACD,QAAQC,EAAK,CACX,OAAOf,EAAM,UAAYe,EAAI,SAAU,EACxC,EACD,QAAQlQ,EAAOkN,EAAM,CAEnB,GADAiC,EAAMjC,CAAI,EACN,EAAClN,IAGLmP,EAAM,GAAG,EACLnP,GAAS,OAAOA,EAAM,SAAY,YACpC,OAAO,KAAK,OACV,MAAM,KAAKA,EAAM,SAAS,EAC1B,EAEV,CAEK,EACD,OAAOwM,EAAK,CACV,OAAO2C,EAAM,SAAW3C,EAAI,SAAU,EACvC,EACD,SAAS2D,EAAM,CACb,OAAOhB,EAAM,QAAUgB,EAAK,SAAU,EACvC,EACD,QAAQC,EAAQ,CACdjB,EAAM,UAAYiB,EAAO,OAAS,GAAG,EACrCjB,EAAMiB,EAAO,SAAQ,CAAE,CACxB,EACD,UAAUlF,EAAI,CACZiE,EAAM,KAAK,EACPQ,GAAiBzE,CAAE,EACrB,KAAK,SAAS,UAAU,EAExB,KAAK,SAASA,EAAG,SAAU,GAEzBhL,EAAQ,uBAAyB,IACnC,KAAK,SAAS,iBAAmB,OAAOgL,EAAG,IAAI,CAAC,EAE9ChL,EAAQ,2BACV,KAAK,QAAQgL,CAAE,CAElB,EACD,QAAQmF,EAAQ,CACd,OAAOlB,EAAM,UAAYkB,EAAO,SAAU,EAC3C,EACD,KAAKC,EAAK,CACR,OAAOnB,EAAM,OAASmB,EAAI,SAAU,EACrC,EACD,OAAQ,CACN,OAAOnB,EAAM,MAAM,CACpB,EACD,YAAa,CACX,OAAOA,EAAM,WAAW,CACzB,EACD,QAAQoB,EAAO,CACb,OAAOpB,EAAM,SAAWoB,EAAM,SAAU,EACzC,EACD,YAAYX,EAAK,CACf,SAAM,aAAa,EACZ,KAAK,SAAS,MAAM,UAAU,MAAM,KAAKA,CAAG,CAAC,CACrD,EACD,mBAAmBA,EAAK,CACtB,SAAM,oBAAoB,EACnB,KAAK,SAAS,MAAM,UAAU,MAAM,KAAKA,CAAG,CAAC,CACrD,EACD,WAAWA,EAAK,CACd,SAAM,YAAY,EACX,KAAK,SAAS,MAAM,UAAU,MAAM,KAAKA,CAAG,CAAC,CACrD,EACD,aAAaA,EAAK,CAChB,SAAM,cAAc,EACb,KAAK,SAAS,MAAM,UAAU,MAAM,KAAKA,CAAG,CAAC,CACrD,EACD,YAAYA,EAAK,CACf,SAAM,aAAa,EACZ,KAAK,SAAS,MAAM,UAAU,MAAM,KAAKA,CAAG,CAAC,CACrD,EACD,aAAaA,EAAK,CAChB,SAAM,cAAc,EACb,KAAK,SAAS,MAAM,UAAU,MAAM,KAAKA,CAAG,CAAC,CACrD,EACD,YAAYA,EAAK,CACf,SAAM,aAAa,EACZ,KAAK,SAAS,MAAM,UAAU,MAAM,KAAKA,CAAG,CAAC,CACrD,EACD,cAAcA,EAAK,CACjB,SAAM,eAAe,EACd,KAAK,SAAS,MAAM,UAAU,MAAM,KAAKA,CAAG,CAAC,CACrD,EACD,cAAcA,EAAK,CACjB,SAAM,eAAe,EACd,KAAK,SAAS,MAAM,UAAU,MAAM,KAAKA,CAAG,CAAC,CACrD,EACD,aAAaA,EAAK,CAChB,SAAM,cAAc,EACb,KAAK,SAAS,IAAI,WAAWA,CAAG,CAAC,CACzC,EACD,KAAKrM,EAAK,CACR,OAAO4L,EAAM,OAAS5L,EAAI,SAAU,EACrC,EACD,KAAKiN,EAAK,CACRrB,EAAM,MAAM,EACZ,MAAMS,EAAM,CAAC,GAAGY,CAAG,EACnB,OAAO,KAAK,OAAOZ,EAAK1P,EAAQ,gBAAkB,EAAK,CACxD,EACD,KAAKuQ,EAAK,CACRtB,EAAM,MAAM,EACZ,MAAMS,EAAM,CAAC,GAAGa,CAAG,EACnB,OAAO,KAAK,OAAOb,EAAK1P,EAAQ,gBAAkB,EAAK,CACxD,EACD,MAAMwQ,EAAM,CACV,SAAM,OAAO,EACN,KAAK,SAAS,CAACA,EAAK,KAAMA,EAAK,KAAMA,EAAK,KAAMA,EAAK,WAAW,CAAC,CACzE,EACD,OAAQ,CACN,GAAIxQ,EAAQ,cACV,OAAOiP,EAAM,QAAQ,EAEvB,MAAM,IAAI,MACR;AAAA;AAAA,CACR,CACK,EACD,YAAa,CACX,OAAOA,EAAM,WAAW,CACzB,EACD,QAAQkB,EAAQ,CACd,OAAOlB,EAAM,UAAYkB,EAAO,SAAU,EAC3C,EAED,UAAW,CACT,OAAOlB,EAAM,SAAS,CACvB,EACD,QAAS,CACP,OAAOA,EAAM,OAAO,CACrB,EACD,OAAQ,CACN,OAAOA,EAAM,MAAM,CACpB,EACD,MAAO,CACL,OAAOA,EAAM,KAAK,CACnB,EACD,MAAO,CACL,OAAOA,EAAM,KAAK,CACnB,EACD,MAAO,CACL,OAAOA,EAAM,KAAK,CACnB,EACD,cAAe,CACb,OAAOA,EAAM,aAAa,CAC3B,EACD,gBAAiB,CACf,OAAOA,EAAM,eAAe,CAC7B,EACD,aAAc,CACZ,OAAOA,EAAM,YAAY,CAC1B,EACD,OAAQ,CACN,OAAOA,EAAM,MAAM,CACpB,EACD,UAAW,CACT,OAAOA,EAAM,SAAS,CACvB,EACD,aAAc,CACZ,OAAOA,EAAM,YAAY,CAC1B,EACD,aAAc,CACZ,OAAOA,EAAM,YAAY,CAC1B,EACD,WAAY,CACV,OAAOA,EAAM,UAAU,CACxB,EACD,SAAU,CACR,OAAOA,EAAM,QAAQ,CACtB,EACD,UAAW,CACT,OAAOA,EAAM,SAAS,CACvB,EACD,UAAW,CACT,OAAOA,EAAM,SAAS,CACvB,CACL,CACA,CACA,SAASQ,GAAiBgB,EAAG,CAC3B,OAAI,OAAOA,GAAM,WACR,GAEG,uDACD,KAAK,SAAS,UAAU,SAAS,KAAKA,CAAC,CAAC,GAAK,IAC1D,CA6UA,SAAShN,GAAQiN,EAASC,EAASC,EAAc,GAAI,CAInD,OAHIF,IAAYC,GAGZ9B,GAAW6B,EAASE,CAAW,IAAM/B,GAAW8B,EAASC,CAAW,CAI1E,CC1nBA,MAAM5P,GAAS,mBACTL,GAAS,mBACTkQ,GAAkB,MAClBC,EAAqB,wCAC3B,SAASC,GAAM7B,EAAKlP,EAAS,CAC3B,GAAI,OAAOkP,GAAQ,SACjB,MAAM,IAAI,UAAU,+BAA+B,EAErD,IAAIjD,EAAM,GACN+E,EAAMhR,GAAW,GACjBiR,EAAQ/B,EAAI,MAAM2B,EAAe,EACjCK,EAAMF,EAAI,QAAUhQ,GACxB,QAASmQ,EAAI,EAAGA,EAAIF,EAAM,OAAQE,IAAK,CACrC,IAAIC,EAAOH,EAAME,GACbE,EAASD,EAAK,QAAQ,GAAG,EAC7B,GAAIC,EAAS,EACX,SAEF,IAAIxR,EAAMuR,EAAK,OAAO,EAAGC,CAAM,EAAE,OAC7BC,EAAMF,EAAK,OAAO,EAAEC,EAAQD,EAAK,MAAM,EAAE,OACzCE,EAAI,IAAM,MACZA,EAAMA,EAAI,MAAM,EAAG,EAAE,GAEnBrF,EAAIpM,IAAQ,OACdoM,EAAIpM,GAAO0R,GAAUD,EAAKJ,CAAG,EAEhC,CACD,OAAOjF,CACT,CACA,SAASuF,GAAUrK,EAAMrH,EAAOE,EAAS,CACvC,IAAIgR,EAAMhR,GAAW,GACjByR,EAAMT,EAAI,QAAUrQ,GACxB,GAAI,OAAO8Q,GAAQ,WACjB,MAAM,IAAI,UAAU,0BAA0B,EAEhD,GAAI,CAACX,EAAmB,KAAK3J,CAAI,EAC/B,MAAM,IAAI,UAAU,0BAA0B,EAEhD,IAAIuK,EAAeD,EAAI3R,CAAK,EAC5B,GAAI4R,GAAgB,CAACZ,EAAmB,KAAKY,CAAY,EACvD,MAAM,IAAI,UAAU,yBAAyB,EAE/C,IAAIxC,EAAM/H,EAAO,IAAMuK,EACvB,GAAIV,EAAI,QAAU,KAAM,CACtB,IAAIW,EAASX,EAAI,OAAS,EAC1B,GAAI,MAAMW,CAAM,GAAK,CAAC,SAASA,CAAM,EACnC,MAAM,IAAI,UAAU,0BAA0B,EAEhDzC,GAAO,aAAe,KAAK,MAAMyC,CAAM,CACxC,CACD,GAAIX,EAAI,OAAQ,CACd,GAAI,CAACF,EAAmB,KAAKE,EAAI,MAAM,EACrC,MAAM,IAAI,UAAU,0BAA0B,EAEhD9B,GAAO,YAAc8B,EAAI,MAC1B,CACD,GAAIA,EAAI,KAAM,CACZ,GAAI,CAACF,EAAmB,KAAKE,EAAI,IAAI,EACnC,MAAM,IAAI,UAAU,wBAAwB,EAE9C9B,GAAO,UAAY8B,EAAI,IACxB,CACD,GAAIA,EAAI,QAAS,CACf,GAAI,OAAOA,EAAI,QAAQ,aAAgB,WACrC,MAAM,IAAI,UAAU,2BAA2B,EAEjD9B,GAAO,aAAe8B,EAAI,QAAQ,YAAW,CAC9C,CAOD,GANIA,EAAI,WACN9B,GAAO,cAEL8B,EAAI,SACN9B,GAAO,YAEL8B,EAAI,SAEN,OADe,OAAOA,EAAI,UAAa,SAAWA,EAAI,SAAS,YAAW,EAAKA,EAAI,SACnE,CACd,IAAK,GACH9B,GAAO,oBACP,MACF,IAAK,MACHA,GAAO,iBACP,MACF,IAAK,SACHA,GAAO,oBACP,MACF,IAAK,OACHA,GAAO,kBACP,MACF,QACE,MAAM,IAAI,UAAU,4BAA4B,CACnD,CAEH,OAAOA,CACT,CACA,SAASqC,GAAUrC,EAAK0C,EAAS,CAC/B,GAAI,CACF,OAAOA,EAAQ1C,CAAG,CACnB,MAAC,CACA,OAAOA,CACR,CACH,CC1FO,SAAS2C,GAAgBlH,EAAUM,IAAc,OACtD,OAAOsB,IAAQ,aAAR,cAAoB,KAC7B,CCNA,MAAMuF,GAAiB,CACrB,KAAM,IACN,OAASR,GAAQvR,GAAM,mBAAmBuR,CAAG,CAAC,EAC9C,OAASA,GAAQ,mBAAmB,OAAOA,GAAQ,SAAWA,EAAM,KAAK,UAAUA,CAAG,CAAC,CACzF,EACO,SAASS,GAAU5K,EAAM6K,EAAO,SACrC,MAAM/P,EAAO,CAAE,GAAG6P,GAAgB,GAAGE,CAAK,EACpCC,EAAUC,GAAejQ,CAAI,GAAK,GAClCkQ,EAASC,GAAIC,IAAQlL,KAAR,QAAiBoF,IAAK,UAAL,qBAAgB,EAKzB,CACzB,MAAM5B,EAAUM,IACVqH,EAAwB,IAAM,CAC7B7O,GAAQ0O,EAAO,MAAOF,EAAQ9K,EAAK,GACtCoL,GAAkBV,GAAgBlH,CAAO,EAAGxD,EAAMgL,EAAO,MAAOlQ,CAAI,CAE5E,EACUuQ,EAAS7H,EAAQ,MAAM,SAAS,eAAgB2H,CAAqB,EAC3E3H,EAAQ,MAAM,SAAS,iBAAkB,KACvC6H,IACOF,EAAqB,EAC7B,CACF,CACD,OAAOH,CACT,CACA,SAASD,GAAejQ,EAAO,GAAI,OAE/B,OAAO8O,KAAMxE,KAAe,IAAf,cAAmB,IAAI,QAAQ,SAAU,GAAItK,CAAI,CAIlE,CACA,SAASwQ,GAAgBtL,EAAMrH,EAAOmC,EAAO,GAAI,CAC/C,OAAInC,GAAU,KACL0R,GAAUrK,EAAMrH,EAAO,CAAE,GAAGmC,EAAM,OAAQ,EAAE,CAAE,EAEhDuP,GAAUrK,EAAMrH,EAAOmC,CAAI,CACpC,CAMA,SAASsQ,GAAkBxJ,EAAO5B,EAAMrH,EAAOmC,EAAO,GAAI,CACpD8G,GACF0E,GAAa1E,EAAO,aAAc0J,GAAgBtL,EAAMrH,EAAOmC,CAAI,CAAC,CAExE,owBCpDAyQ,iCACAC,yBAcA,eACA,oCAMA,WACA,OACA,OACA,IACA,qBACA,eACA,WACA,EACA,MACA,qBACA,eACA,WACA,EACA,QACA,YACA,eACA,WACA,EACA,KACA,YACA,eACA,WACA,EACA,OACA,aACA,eACA,WACA,EACA,UACA,aACA,eACA,WACA,EACA,YACA,aACA,eACA,WACA,EACA,aACA,YACA,eACA,WACA,EACA,kBACA,YACA,eACA,WACA,EACA,iBACA,YACA,eACA,WACA,EACA,SACA,aACA,eACA,WACA,EACA,kBACA,YACA,eACA,WACA,EACA,UACA,aACA,eACA,WACA,EACA,QACA,aACA,eACA,WACA,CACA,EACA,mBACA,aACAnE,QAEAoE,gBACA,EACAlE,QACAkE,YAGAA,6BACA,GAEA,yBACA,GAEApE,2BACA,EACAqE,QACAC,SAmCA,qBACA,YACA,SACAC,iBACA,CACA,WAGA,WACA,sEACA,yCACA,wDACA,kBACA,oCACA,eACA,EACAC,SACA,EAEA,2GACAC,iBAEAC,8DACAC,gCACA,gBACAH,UAGAA,WACA,OACA,WACA,mBACA,MACA,SACA,mBACA,YACA,gBACA,GAXA,KAaAI,yEACA,CACA,CACA,EACA,CACAC,+BCpMA,MAAMC,GAAe,CAAE,EAIRxH,GAAOwH,EAAY,ECL3B,MAAMC,GAAS,GCFtB;AAAA;AAAA;AAAA;AAAA,IAyBA,MAAMC,GAAsG,OAAM,EAelH,IAAIC,IACH,SAAUA,EAAc,CAQrBA,EAAa,OAAY,SAMzBA,EAAa,YAAiB,eAM9BA,EAAa,cAAmB,gBAEpC,GAAGA,KAAiBA,GAAe,CAAE,EAAC,EAy3BtC,SAASC,IAAc,CACnB,MAAMC,EAAQC,GAAY,EAAI,EAGxBzF,EAAQwF,EAAM,IAAI,IAAMvB,EAAI,CAAE,EAAC,EACrC,IAAIyB,EAAK,GAELC,EAAgB,GACpB,MAAMC,EAAQC,GAAQ,CAClB,QAAQC,EAAK,CAKLF,EAAM,GAAKE,EACXA,EAAI,QAAQT,GAAaO,CAAK,EAC9BE,EAAI,OAAO,iBAAiB,OAASF,EAKrCD,EAAc,QAASpJ,GAAWmJ,EAAG,KAAKnJ,CAAM,CAAC,EACjDoJ,EAAgB,EAEvB,EACD,IAAIpJ,EAAQ,CACR,MAAI,CAAC,KAAK,IAAM,CAAC6I,GACbO,EAAc,KAAKpJ,CAAM,EAGzBmJ,EAAG,KAAKnJ,CAAM,EAEX,IACV,EACD,KAGA,GAAI,KACJ,GAAIiJ,EACJ,GAAI,IAAI,IACR,OACR,CAAK,EAMD,OAAOI,CACX,CCt+BA,MAAMrJ,GAASE,EAAkBD,GAAY,CAC3C,MAAMoJ,EAAQL,KACd,SAAQ,OAAO,IAAIK,CAAK,EAGtBpJ,EAAQ,QAAQ,MAAQoJ,EAAM,MAAM,MAI/B,CACL,QAAS,CACP,OACD,CACL,CACA,CAAC,ECbKG,EAAa,CAAE,EAENC,KAAiBxJ,GAAW,CACzC,UAAWxD,KAAQ+M,EACjBvJ,EAAQ,OAAO,UAAUxD,EAAM+M,EAAW/M,EAAK,EAC/CwD,EAAQ,OAAO,UAAU,OAASxD,EAAM+M,EAAW/M,EAAK,CAE5D,CAAC,ECVD,SAASiN,GAAQtU,EAAO,CACtB,OAAO,MAAM,QAAQA,CAAK,EAAIA,EAAQ,CAACA,CAAK,CAC9C,CAEK,MAACuU,GAAkB,CAAC,OAAQ,OAAQ,MAAM,EACzCC,GAAuB,CAAC,QAAS,SAAU,QAAS,UAAU,EAC9DC,GAAiB,CACrB,OACA,OACA,OACA,QACA,SACA,UACF,EACMC,GAAgB,CACpB,QACA,gBACA,iBACA,OACA,YACA,YACA,OACA,OACA,QACA,SACA,UACF,EACMC,GAAa,CAAC,OAAQ,QAAS,gBAAiB,YAAa,YAAa,gBAAgB,EAC1FC,GAAgB,CAAC,cAAe,cAAe,uBAAwB,YAAa,aAAa,EAMvG,SAASC,GAASrT,EAAG,CACnB,IAAI8R,EAAI,EACR,QAASjC,EAAI,EAAGA,EAAI7P,EAAE,QACpB8R,EAAI,KAAK,KAAKA,EAAI9R,EAAE,WAAW6P,GAAG,EAAG,GAAK,CAAC,EAC7C,QAASiC,EAAIA,IAAM,GAAK,OAAO,SAAS,EAAE,EAAE,UAAU,EAAG,CAAC,EAAE,YAAW,CACzE,CACA,SAASwB,EAAQC,EAAK,CACpB,OAAOF,GAAS,GAAGE,EAAI,OAAOA,EAAI,aAAeA,EAAI,WAAa,MAAM,OAAO,QAAQA,EAAI,KAAK,EAAE,IAAI,CAAC,CAAChV,EAAKC,CAAK,IAAM,GAAGD,KAAO,OAAOC,CAAK,GAAG,EAAE,KAAK,GAAG,GAAG,CAChK,CACA,SAASgV,GAAcC,EAAQ,CAC7B,IAAI3B,EAAI,EACR,UAAW9R,KAAKyT,EACd,QAAS5D,EAAI,EAAGA,EAAI7P,EAAE,QACpB8R,EAAI,KAAK,KAAKA,EAAI9R,EAAE,WAAW6P,GAAG,EAAG,GAAK,CAAC,EAE/C,QAASiC,EAAIA,IAAM,GAAK,OAAO,SAAS,EAAE,EAAE,UAAU,EAAG,CAAC,EAAE,YAAW,CACzE,CAEA,SAAS4B,GAAaH,EAAK7J,EAAI,CAC7B,KAAM,CAAE,QAAO,IAAKiK,CAAO,EAAKJ,EAChC,GAAIJ,GAAW,SAASQ,CAAO,EAC7B,OAAOA,EACT,GAAIA,IAAY,QAAUrC,EAAM,MAAQ,YACtC,MAAO,YACT,GAAIA,EAAM,QACR,MAAO,UACT,MAAMzL,EAAO,CAAC,IAAI,EACd8N,IAAY,QACd9N,EAAK,KAAS,OAAQ,WAAY,YAAa,EACjD,UAAW+N,KAAK/N,EACd,GAAI,OAAOyL,EAAMsC,GAAO,IAAa,CACnC,MAAM5D,EAAM,OAAOsB,EAAMsC,EAAE,EAC3B,OAAIlK,GAAM,CAACA,EAAGsG,CAAG,EACR,GACF,GAAG2D,KAAWC,KAAK5D,GAC3B,CAEH,MAAO,EACT,CAEA,SAAS6D,GAAqBC,EAAUC,EAAO,CAC7C,OAAID,GAAY,KACPC,GAAS,KACd,OAAOD,GAAa,WACfA,EAASC,CAAK,EAChBD,CACT,CC9EA,SAASE,EAASC,EAAKC,EAAW,GAAOC,EAAgB,CACvD,KAAM,CAAE,MAAK,KAAK,EAAGF,EACjB,CAACG,IAEL,OAAO,QAAQb,EAAI,KAAK,EAAE,QAAQ,CAAC,CAAClT,EAAG7B,CAAK,IAAM,CAChDA,EAAQ,OAAOA,CAAK,EACpB,MAAM6V,EAAa,QAAQhU,IAC3B,GAAIA,IAAM,QAAS,CACjB,GAAI,CAAC7B,EACH,OACF,UAAW+L,KAAK/L,EAAM,MAAM,GAAG,EAAG,CAChC,MAAM8V,EAAc,GAAGD,KAAc9J,IACjC4J,GACFA,EAAeF,EAAKK,EAAa,IAAMF,EAAI,UAAU,OAAO7J,CAAC,CAAC,EAC3D6J,EAAI,UAAU,SAAS7J,CAAC,GAC3B6J,EAAI,UAAU,IAAI7J,CAAC,CACtB,CACD,MACD,CACG4J,GAAkB,CAAC9T,EAAE,WAAW,SAAS,GAC3C8T,EAAeF,EAAKI,EAAY,IAAMD,EAAI,gBAAgB/T,CAAC,CAAC,GAC1D6T,GAAYE,EAAI,aAAa/T,CAAC,IAAM7B,IACtC4V,EAAI,aAAa/T,EAAG7B,CAAK,CAC/B,CAAG,EACGwU,GAAqB,SAASO,EAAI,GAAG,IACnCA,EAAI,aAAeA,EAAI,cAAgBa,EAAI,YAC7CA,EAAI,YAAcb,EAAI,YACfA,EAAI,WAAaA,EAAI,YAAca,EAAI,YAC9CA,EAAI,UAAYb,EAAI,YAE1B,CAEA,IAAIgB,EAAW,GACf,eAAeC,GAAcC,EAAM/V,EAAU,GAAI,SAC/C,MAAMgW,EAAkB,CAAE,aAAc,IAExC,GADA,MAAMD,EAAK,MAAM,SAAS,mBAAoBC,CAAe,EACzD,CAACA,EAAgB,aACnB,OACF,MAAMC,EAAMjW,EAAQ,UAAY+V,EAAK,gBAAgB,UAAY,OAAO,SAClEG,GAAe,MAAMH,EAAK,YAAW,GAAI,IAAII,CAAiB,EACpE,GAAIJ,EAAK,gBAAgB,4BACvBF,EAAWA,GAAYE,EAAK,OAAS,GACjCF,GAAU,CACZ,MAAMxR,EAAOyQ,GAAcoB,EAAY,IAAKX,GAAQA,EAAI,IAAI,EAAE,CAAC,EAC/D,GAAIM,IAAaxR,EACf,OACFwR,EAAWxR,CACZ,CAEH,MAAM+R,EAAmBL,EAAK,sBAC9BA,EAAK,cAAc,IAAKnG,GAAUA,EAAM,IAAI,EAAE,QAASyG,GAAQ,CAC7D,OAAO,QAAQA,CAAG,EAAE,QAAQ,CAAC,CAACxW,EAAKmL,CAAE,IAAM,CACzCoL,EAAiBvW,GAAOmL,CAC9B,CAAK,CACL,CAAG,EACD,MAAMyK,EAAiB,CAACF,EAAK1V,EAAKmL,IAAO,CACvCnL,EAAM,GAAG0V,EAAI,YAAY1V,IACrB0V,EAAI,QACNA,EAAI,MAAM,KAAK1V,GAAOmL,GACxB,OAAOoL,EAAiBvW,EAC5B,EACE,SAASsW,EAAkBtB,EAAK,CAC9B,MAAMjF,EAAQmG,EAAK,YAAW,EAAG,KAAMO,GAAMA,EAAE,KAAOzB,EAAI,EAAE,EACtD0B,EAAY,CAChB,SAAU1B,EAAI,IAAMD,EAAQC,CAAG,EAC/B,IAAK,KACL,aAAc,GACd,MACA,QACA,eAAgB,CAAChV,EAAKmL,IAAOyK,EAAec,EAAW1W,EAAKmL,CAAE,CACpE,EACI,OAAOuL,CACR,CACD,MAAMC,EAAU,GACVC,EAAiB,CACrB,KAAM,CAAE,EACR,KAAM,CAAE,CACZ,EACQC,EAAUnB,GAAQ,CACtBQ,EAAK,OAAOR,EAAI,UAAYA,EAAI,IAChCiB,EAAQ,KAAKjB,CAAG,EAChBE,EAAeF,EAAK,KAAM,IAAM,QAC9BhJ,IAAI,MAAJ,QAAS,SACT,OAAOwJ,EAAK,OAAOR,EAAI,SAC7B,CAAK,CACL,EACE,UAAWA,KAAOW,EAAa,CAE7B,GADA,MAAMH,EAAK,MAAM,SAAS,sBAAuBR,CAAG,EAChD,CAACA,EAAI,aACP,SACF,KAAM,CAAE,KAAK,EAAGA,EAChB,GAAIV,EAAI,MAAQ,QAAS,CACvBoB,EAAI,MAAQpB,EAAI,aAAe,GAC/B2B,EAAQ,KAAKjB,CAAG,EAChB,QACD,CACD,GAAIV,EAAI,MAAQ,aAAeA,EAAI,MAAQ,YAAa,CACtDU,EAAI,IAAMU,EAAIpB,EAAI,MAAQ,YAAc,kBAAoB,QAC5DS,EAASC,EAAK,GAAOE,CAAc,EACnCe,EAAQ,KAAKjB,CAAG,EAChB,QACD,CAID,GAHAA,EAAI,IAAMQ,EAAK,OAAOR,EAAI,UACtB,CAACA,EAAI,KAAOV,EAAI,MAClBU,EAAI,IAAMU,EAAI,cAAc,IAAG1J,IAAI,cAAJ,QAAiB,WAAW,QAAU,OAAS,YAAYsI,EAAI,cAAcA,EAAI,KAAK,GACnHU,EAAI,IAAK,CACPA,EAAI,IAAI,IACVD,EAASC,CAAG,EACdmB,EAAOnB,CAAG,EACV,QACD,CACDkB,GAAepE,IAAI,cAAJ,QAAiB,WAAW,QAAU,OAAS,QAAQ,KAAKkD,CAAG,CAC/E,CACD,MAAMoB,EAAY,CAChB,UAAW,OACX,SAAU,OACV,KAAM,MACV,EACE,OAAO,QAAQF,CAAc,EAAE,QAAQ,CAAC,CAACG,EAAKC,CAAK,IAAM,OACvD,GAAI,CAACA,EAAM,OACT,OACF,MAAMC,GAAWvK,mBAAMqK,KAAN,cAAY,SAC7B,GAAI,EAACE,EAEL,WAAWpB,IAAO,CAAC,GAAGoB,CAAQ,EAAE,QAAO,EAAI,CACzC,MAAMC,EAAQrB,EAAI,QAAQ,YAAW,EACrC,GAAI,CAACnB,GAAe,SAASwC,CAAK,EAChC,SACF,MAAMnE,GAAQ8C,EAAI,kBAAiB,EAAG,OAAO,CAACsB,EAAQ7P,KAAU,CAAE,GAAG6P,EAAQ,CAAC7P,GAAOuO,EAAI,aAAavO,CAAI,CAAG,GAAG,EAAE,EAC5G8P,EAAS,CAAE,IAAKF,EAAO,QAAK,EAC9BrB,EAAI,YACNuB,EAAO,UAAYvB,EAAI,WACzB,MAAMwB,GAActC,EAAQqC,CAAM,EAClC,IAAIE,EAAWN,EAAM,UAAWtB,IAAQA,iBAAK,YAAa2B,EAAW,EACrE,GAAIC,IAAa,GAAI,CACnB,MAAMC,EAAepC,GAAaiC,CAAM,EACxCE,EAAWN,EAAM,UAAWtB,IAAQA,iBAAK,IAAI,KAAMA,EAAI,IAAI,KAAO6B,CAAY,CAC/E,CACD,GAAID,IAAa,GAAI,CACnB,MAAM5B,EAAMsB,EAAMM,GAClB5B,EAAI,IAAMG,EACVJ,EAASC,CAAG,EACZmB,EAAOnB,CAAG,EACV,OAAOsB,EAAMM,EACd,CACF,CACDN,EAAM,QAAStB,GAAQ,CACrB,MAAM8B,EAAO9B,EAAI,IAAI,aAAe,OACpCoB,EAAUU,GAAQV,EAAUU,IAASpB,EAAI,yBACpCV,EAAI,MACPA,EAAI,IAAMU,EAAI,cAAcV,EAAI,IAAI,GAAG,EACvCD,EAASC,EAAK,EAAI,GAEpBoB,EAAUU,GAAM,YAAY9B,EAAI,GAAG,EACnCmB,EAAOnB,CAAG,CAChB,CAAK,EACL,CAAG,EACGoB,EAAU,MACZV,EAAI,KAAK,YAAYU,EAAU,IAAI,EACjCA,EAAU,UACZV,EAAI,KAAK,aAAaU,EAAU,SAAUV,EAAI,KAAK,UAAU,EAC3DU,EAAU,WACZV,EAAI,KAAK,YAAYU,EAAU,SAAS,EAC1C,UAAWpB,KAAOiB,EAChB,MAAMT,EAAK,MAAM,SAAS,gBAAiBR,CAAG,EAChD,OAAO,OAAOa,CAAgB,EAAE,QAASpL,GAAOA,EAAE,CAAE,CACtD,CACA,IAAIsM,EAAmB,KACvB,eAAeC,GAAuBxB,EAAM/V,EAAU,GAAI,CACxD,SAASwX,GAAc,CACrB,SAAmB,KACZ1B,GAAcC,EAAM/V,CAAO,CACnC,CACD,MAAMyX,EAAUzX,EAAQ,UAAagL,GAAO,WAAWA,EAAI,EAAE,GAC7D,OAAOsM,EAAmBA,GAAoB,IAAI,QAASpK,GAAYuK,EAAQ,IAAMvK,EAAQsK,EAAa,EAAC,CAAC,CAC9G,CAEA,SAASE,GAA6B1X,EAAS,CAC7C,MAAwB,CACtB,MAAO,CACL,kBAAmB,SAAS+V,EAAM,CAChC,GAAI,OAAO/V,iBAAS,UAAa,IAC/B,OACF,IAAIyX,EAAUzX,iBAAS,QACnB,CAACyX,GAAW,OAAO,sBAA0B,MAC/CA,EAAU,uBACZF,GAAuBxB,EAAM,CAAE,UAAU/V,iBAAS,WAAY,OAAO,SAAU,SAAO,CAAE,CACzF,CACF,CACL,CACA,CAEA,SAAS2X,GAAgBC,EAAU,OACjC,QAAOrL,mBAAU,KAAK,cAAc,6BAA7B,cAAyD,aAAa,aAAc,EAC7F,CChMA,MAAMsL,GAAc,CAElB,SAAU,EACV,KAAM,EACN,IAAK,GAEL,KAAM,GACN,MAAO,EACP,KAAM,EACR,EACA,SAASC,GAAUjD,EAAK,CACtB,GAAI,OAAOA,EAAI,aAAgB,SAC7B,OAAOA,EAAI,YACb,GAAIA,EAAI,MAAQ,OAAQ,CACtB,GAAIA,EAAI,MAAM,QACZ,MAAO,GACT,GAAIA,EAAI,MAAM,gBAAkB,0BAC9B,MAAO,EACV,CACD,MAAMhV,EAAMgV,EAAI,aAAeA,EAAI,IACnC,OAAIhV,KAAOgY,GACFA,GAAYhY,GAEd,EACT,CACA,MAAMkY,GAAgB,CAAC,CAAE,OAAQ,UAAW,OAAQ,IAAM,CAAE,OAAQ,SAAU,OAAQ,CAAG,GACzF,SAASC,IAAiB,CACxB,MAAwB,CACtB,MAAO,CACL,eAAiBzC,GAAQ,CACvB,MAAM0C,EAAqBpY,GAAQ,kBAAI,KAAK,KAAMgV,GAAQA,EAAI,KAAOhV,CAAG,IAArC,cAAwC,IAC3E,SAAW,CAAE,SAAQ,QAAM,IAAMkY,GAC/B,UAAWlD,KAAOU,EAAI,KAAK,OAAQ2C,GAAS,OAAOA,EAAK,aAAgB,UAAYA,EAAK,YAAY,WAAWC,CAAM,CAAC,EAAG,CACxH,MAAMC,EAAWH,EACfpD,EAAI,YAAY,QAAQsD,EAAQ,EAAE,CAChD,EACgB,OAAOC,EAAa,MACtBvD,EAAI,GAAKuD,EAAWC,EACvB,CAEH9C,EAAI,KAAK,KAAK,CAAC7R,EAAGC,IAAMD,EAAE,GAAKC,EAAE,EAAE,EAAE,KAAK,CAACD,EAAGC,IAAMmU,GAAUpU,CAAC,EAAIoU,GAAUnU,CAAC,CAAC,CAChF,CACF,CACL,CACA,CAEA,SAAS2U,IAAsB,CAC7B,MAAwB,CACtB,MAAO,CACL,eAAiB/C,GAAQ,CACvB,KAAM,CAAE,MAAM,EAAGA,EACjB,IAAIgD,EAAmBC,EAAK,UAAWrH,GAAMA,EAAE,MAAQ,eAAe,EACtE,MAAMsH,EAAWD,EAAK,UAAWrH,GAAMA,EAAE,MAAQ,OAAO,EACxD,GAAIsH,IAAa,IAAMF,IAAqB,GAAI,CAC9C,MAAMG,EAAWvD,GACfqD,EAAKD,GAAkB,YACvBC,EAAKC,GAAU,WAC3B,EACcC,IAAa,KACfF,EAAKC,GAAU,YAAcC,GAAYF,EAAKC,GAAU,YAExD,OAAOD,EAAKC,EAExB,SAAmBF,IAAqB,GAAI,CAClC,MAAMG,EAAWvD,GACfqD,EAAKD,GAAkB,WACnC,EACcG,IAAa,OACfF,EAAKD,GAAkB,YAAcG,EACrCF,EAAKD,GAAkB,IAAM,QAC7BA,EAAmB,GAEtB,CACGA,IAAqB,IACvB,OAAOC,EAAKD,GAEdhD,EAAI,KAAOiD,EAAK,OAAO,OAAO,CAC/B,CACF,CACL,CACA,CAEA,SAASG,IAA0B,CACjC,MAAwB,CACtB,MAAO,CACL,gBAAiB,SAAS,CAAE,OAAO,CAC7B,OAAO9D,EAAI,MAAM,KAAS,MAC5BA,EAAI,YAAc,YAClB,OAAOA,EAAI,MAAM,KAEpB,CACF,CACL,CACA,CAEA,MAAM+D,GAAe,CAAC,OAAQ,QAAS,SAAU,UAAU,EAC3D,SAASC,IAAuB,CAC9B,MAAwB,CACtB,MAAO,CACL,gBAAiB,CAAC,CAAE,MAAK,qBAAsB,CACzCC,EAAgB,4BAA8B,KAChDjE,EAAI,GAAKD,EAAQC,CAAG,GAElBA,EAAI,KAAO+D,GAAa,SAAS/D,EAAI,GAAG,IAC1CA,EAAI,GAAKF,GAASE,EAAI,GAAG,EACzBA,EAAI,MAAM,UAAUA,EAAI,MAAQ,GAEnC,CACF,CACL,CACA,CAEA,MAAMkE,GAAiB,CAAC,SAAU,OAAQ,WAAW,EACrD,SAASC,IAAsB,CAC7B,MAAMC,EAAqB,CAACC,EAAMrE,IAAQ,CACxC,MAAMjC,EAAQ,GACRuG,EAAgB,GACtB,OAAO,QAAQtE,EAAI,KAAK,EAAE,QAAQ,CAAC,CAAChV,EAAKC,CAAK,IAAM,CAC9CD,EAAI,WAAW,IAAI,GAAK,OAAOC,GAAU,WAC3CqZ,EAActZ,GAAOC,EAErB8S,EAAM/S,GAAOC,CACrB,CAAK,EACD,IAAIsZ,EACJ,OAAIF,IAAS,OAASrE,EAAI,MAAQ,UAAY,OAAOjC,EAAM,KAAQ,UAAY,OAAOuG,EAAc,OAAW,MAC7GC,EAAaxG,EAAM,IACnB,OAAOA,EAAM,KAER,CAAE,QAAO,gBAAe,aACnC,EACE,MAAwB,CACtB,MAAO,CACL,aAAc,SAAS2C,EAAK,CAC1BA,EAAI,KAAOA,EAAI,KAAK,IAAKV,IACnB,CAACkE,GAAe,SAASlE,EAAI,GAAG,GAEhC,CAAC,OAAO,QAAQA,EAAI,KAAK,EAAE,KAAK,CAAC,CAAChV,EAAKC,CAAK,IAAMD,EAAI,WAAW,IAAI,GAAK,OAAOC,GAAU,UAAU,IAEzG+U,EAAI,MAAQoE,EAAmB,MAAOpE,CAAG,EAAE,OACpCA,EACR,CACF,EACD,sBAAuB,SAASU,EAAK,CAGnC,GAFI,CAACwD,GAAe,SAASxD,EAAI,IAAI,GAAG,GAEpC,CAAC,OAAO,QAAQA,EAAI,IAAI,KAAK,EAAE,KAAK,CAAC,CAAC1V,EAAKC,CAAK,IAAMD,EAAI,WAAW,IAAI,GAAK,OAAOC,GAAU,UAAU,EAC3G,OACF,KAAM,CAAE,QAAO,gBAAe,YAAU,EAAKmZ,EAAmB,MAAO1D,EAAI,GAAG,EAC1E,CAAC,OAAO,KAAK4D,CAAa,EAAE,SAEhC5D,EAAI,IAAI,MAAQ3C,EAChB2C,EAAI,IAAI,eAAiB4D,EACzB5D,EAAI,IAAI,YAAc6D,EACvB,EACD,gBAAiB,SAAS7D,EAAK,CAC7B,MAAMG,EAAMH,EAAI,IAChB,GAAI,CAACA,EAAI,IAAI,gBAAkB,CAACG,EAC9B,OACF,MAAM2D,GAAuB9D,EAAI,IAAI,IAAgEG,GACrG,OAAO,QAAQH,EAAI,IAAI,cAAc,EAAE,QAAQ,CAAC,CAAC5T,EAAG7B,CAAK,IAAM,CAC7D,MAAMwZ,EAAS,GAAG/D,EAAI,IAAI,IAAMA,EAAI,IAAI,MAAM5T,IACxC4X,EAAY5X,EAAE,MAAM,CAAC,EAAE,YAAW,EAClC6X,EAAiB,UAAUD,IAGjC,GAFAhE,EAAI,eAAe+D,EAAQ,IAAM,CAC3C,CAAW,EACG5D,EAAI,aAAa8D,CAAc,EACjC,OACF,MAAMC,EAAU3Z,EAChB4V,EAAI,aAAa8D,EAAgB,EAAE,EACnCH,EAAqB,iBAAiBE,EAAWE,CAAO,EACpDlE,EAAI,QACNA,EAAI,MAAM,KAAK+D,GAAU,IAAM,CAC7BD,EAAqB,oBAAoBE,EAAWE,CAAO,EAC3D/D,EAAI,gBAAgB8D,CAAc,CAChD,EAEA,CAAS,EACGjE,EAAI,IAAI,aACVG,EAAI,aAAa,MAAOH,EAAI,IAAI,WAAW,CAE9C,CACF,CACL,CACA,CAEA,MAAMmE,GAAoB,CAAC,iBAAkB,YAAa,WAAW,EACrE,SAASC,IAAoB,CAC3B,MAAwB,CACtB,MAAO,CACL,gBAAiB,SAAS,CAAE,OAAO,CACjC,CAAC,MAAO,OAAQ,KAAK,EAAE,QAAS9Z,GAAQ,CAClCgV,EAAI,MAAMhV,KACZgV,EAAI,IAAMA,EAAI,MAAMhV,GACpB,OAAOgV,EAAI,MAAMhV,GAE7B,CAAS,EAED,MAAM+Z,EADe5E,GAAaH,CAAG,IACLA,EAAI,IAAM,GAAGA,EAAI,OAAOA,EAAI,MAAQ,IAChE+E,IACF/E,EAAI,GAAK+E,EACZ,EACD,eAAgB,SAASrE,EAAK,CAC5B,MAAMsE,EAAW,GACjBtE,EAAI,KAAK,QAASV,GAAQ,CACxB,MAAMiF,GAAajF,EAAI,IAAM,GAAGA,EAAI,OAAOA,EAAI,MAAQA,EAAI,KAAOA,EAAI,GAChEkF,EAAWF,EAASC,GAC1B,GAAIC,EAAU,CACZ,IAAIC,EAAWnF,iBAAK,qBAGpB,GAFI,CAACmF,GAAYN,GAAkB,SAAS7E,EAAI,GAAG,IACjDmF,EAAW,SACTA,IAAa,QAAS,CACxB,MAAMC,EAAWF,EAAS,MAC1B,CAAC,QAAS,OAAO,EAAE,QAASla,GAAQ,CAC9BgV,EAAI,MAAMhV,IAAQoa,EAASpa,KACzBA,IAAQ,SAAW,CAACoa,EAASpa,GAAK,SAAS,GAAG,IAChDoa,EAASpa,IAAQ,KACnBgV,EAAI,MAAMhV,GAAO,GAAGoa,EAASpa,MAAQgV,EAAI,MAAMhV,KAEjE,CAAe,EACDga,EAASC,GAAW,MAAQ,CAC1B,GAAGG,EACH,GAAGpF,EAAI,KACvB,EACc,MACD,SAAUA,EAAI,KAAOkF,EAAS,GAAI,CACjCA,EAAS,OAASA,EAAS,QAAU,GACrClF,EAAI,GAAK,GAAGkF,EAAS,MAAMA,EAAS,OAAO,OAAS,IACpDA,EAAS,OAAO,KAAKlF,CAAG,EACxB,MACD,CACF,CACD,MAAMqF,EAAY,OAAO,KAAKrF,EAAI,KAAK,EAAE,QAAUA,EAAI,UAAY,EAAI,IAAMA,EAAI,YAAc,EAAI,GACnG,GAAIN,GAAe,SAASM,EAAI,GAAG,GAAKqF,IAAc,EAAG,CACvD,OAAOL,EAASC,GAChB,MACD,CACDD,EAASC,GAAajF,CAChC,CAAS,EACD,MAAMsF,EAAU,GAChB,OAAO,OAAON,CAAQ,EAAE,QAAShF,GAAQ,CACvC,MAAMuF,EAAQvF,EAAI,OAClB,OAAOA,EAAI,OACXsF,EAAQ,KAAKtF,CAAG,EACZuF,GACFD,EAAQ,KAAK,GAAGC,CAAK,CACjC,CAAS,EACD7E,EAAI,KAAO4E,CACZ,CACF,CACL,CACA,CAEA,SAASE,EAAsB/Y,EAAGgZ,EAAQ,CACxC,SAASC,EAAIC,EAAO,CAClB,GAAI,CAAC,IAAK,WAAW,EAAE,SAASA,CAAK,EACnC,OAAOF,EAAO,UAChB,IAAIhJ,EACJ,OAAIkJ,EAAM,SAAS,GAAG,EACpBlJ,EAAMkJ,EAAM,MAAM,GAAG,EAAE,OAAO,CAACC,EAAK5a,IAAQ4a,GAAMA,EAAI5a,IAAQ,OAAiBya,CAAM,EAErFhJ,EAAMgJ,EAAOE,GAER,OAAOlJ,EAAQ,IAAcA,GAAO,GAAK,EACjD,CACD,IAAIoJ,EAAUpZ,EACd,GAAI,CACFoZ,EAAU,UAAUpZ,CAAC,CACzB,MAAI,CACD,CAED,OADgBoZ,EAAQ,MAAM,sBAAsB,GAAK,IAAI,OAAO,UAC7D,QAASF,GAAU,CACxB,MAAMG,EAAKJ,EAAIC,EAAM,MAAM,CAAC,CAAC,EACzB,OAAOG,GAAO,WAChBrZ,EAAIA,EAAE,QAAQ,IAAI,OAAO,KAAKkZ,WAAgB,GAAG,EAAG,GAAGG,KAAM,EAAE,OAErE,CAAG,EACGL,EAAO,YACLhZ,EAAE,SAASgZ,EAAO,SAAS,IAC7BhZ,EAAIA,EAAE,MAAM,EAAG,CAACgZ,EAAO,UAAU,MAAM,EAAE,QACvChZ,EAAE,WAAWgZ,EAAO,SAAS,IAC/BhZ,EAAIA,EAAE,MAAMgZ,EAAO,UAAU,MAAM,EAAE,QACvChZ,EAAIA,EAAE,QAAQ,IAAI,OAAO,KAAKgZ,EAAO,kBAAkBA,EAAO,YAAa,GAAG,EAAGA,EAAO,SAAS,GAE5FhZ,CACT,CACA,SAASsZ,IAAuB,CAC9B,MAAwB,CACtB,MAAO,CACL,eAAiBrF,GAAQ,OACvB,KAAM,CAAE,MAAM,EAAGA,EACXF,GAAQ9I,IAAK,KAAMsI,GAAQA,EAAI,MAAQ,OAAO,IAAtC,cAAyC,YACjDgG,EAAMrC,EAAK,UAAW3D,GAAQA,EAAI,MAAQ,gBAAgB,EAC1DiG,EAASD,IAAQ,GAAKrC,EAAKqC,GAAK,MAAQ,GAC9CC,EAAO,UAAYA,EAAO,WAAazF,GAAS,GAChD,UAAWR,KAAO2D,EAChB,GAAI,CAAC,gBAAiB,OAAO,EAAE,SAAS3D,EAAI,GAAG,GAAK,OAAOA,EAAI,aAAgB,SAC7EA,EAAI,YAAcwF,EAAsBxF,EAAI,YAAaiG,CAAM,UACtDjG,EAAI,MAAQ,QAAU,OAAOA,EAAI,MAAM,SAAY,SAC5DA,EAAI,MAAM,QAAUwF,EAAsBxF,EAAI,MAAM,QAASiG,CAAM,UAC1DjG,EAAI,MAAQ,QAAU,OAAOA,EAAI,MAAM,MAAS,SACzDA,EAAI,MAAM,KAAOwF,EAAsBxF,EAAI,MAAM,KAAMiG,CAAM,UACpDjG,EAAI,MAAQ,UAAY,CAAC,mBAAoB,qBAAqB,EAAE,SAASA,EAAI,MAAM,IAAI,GAAK,OAAOA,EAAI,WAAc,SAClI,GAAI,CACFA,EAAI,UAAY,KAAK,UAAU,KAAK,MAAMA,EAAI,SAAS,EAAG,CAAChV,EAAKyR,IAC1D,OAAOA,GAAQ,SACV+I,EAAsB/I,EAAKwJ,CAAM,EACnCxJ,CACR,CACf,MAAc,CACD,CAGLiE,EAAI,KAAOiD,EAAK,OAAQ3D,GAAQA,EAAI,MAAQ,gBAAgB,CAC7D,CACF,CACL,CACA,CAIA,IAAIkG,GACJ,SAASC,GAAcjF,EAAM,CAC3B,OAAOgF,GAAahF,CACtB,CACA,SAASkF,IAAgB,CACvB,OAAOF,EACT,CA+WA,eAAeG,GAAajG,EAASnU,EAAO,CAC1C,MAAM+T,EAAM,CAAE,IAAKI,EAAS,MAAO,CAAE,GACrC,OAAIA,IAAY,kBACdJ,EAAI,MAAQ/T,EACL+T,GAEL,CAAC,QAAS,eAAe,EAAE,SAASI,CAAO,GAC7CJ,EAAI,YAAc/T,aAAiB,QAAU,MAAMA,EAAQA,EACpD+T,GAEL,OAAO/T,GAAU,SACd,CAAC,SAAU,WAAY,OAAO,EAAE,SAASmU,CAAO,GAEjDA,IAAY,WAAa,kBAAkB,KAAKnU,CAAK,GAAKA,EAAM,WAAW,GAAG,GAChF+T,EAAI,MAAM,IAAM/T,EAEhB+T,EAAI,UAAY/T,EACX+T,GALE,IAOXA,EAAI,MAAQ,MAAMsG,GAAelG,EAAS,CAAE,GAAGnU,CAAK,CAAE,EAClD+T,EAAI,MAAM,WACZA,EAAI,MAAM,UAAYA,EAAI,MAAM,UAElC,OAAOA,EAAI,MAAM,SACjB,OAAO,KAAKA,EAAI,KAAK,EAAE,OAAQlT,GAAM+S,GAAc,SAAS/S,CAAC,CAAC,EAAE,QAASA,GAAM,EACzE,CAAC,CAAC,YAAa,aAAa,EAAE,SAASA,CAAC,GAAK2S,GAAqB,SAASO,EAAI,GAAG,KACpFA,EAAIlT,GAAKkT,EAAI,MAAMlT,IAErB,OAAOkT,EAAI,MAAMlT,EACrB,CAAG,EACD,CAAC,YAAa,aAAa,EAAE,QAASA,GAAM,CAC1C,GAAIkT,EAAI,MAAQ,UAAY,OAAOA,EAAIlT,IAAO,UAAY,CAAC,sBAAuB,kBAAkB,EAAE,SAASkT,EAAI,MAAM,IAAI,EAC3H,GAAI,CACFA,EAAIlT,GAAK,KAAK,MAAMkT,EAAIlT,EAAE,CAC3B,MAAC,CACAkT,EAAIlT,GAAK,EACV,CAEC,OAAOkT,EAAIlT,IAAO,WACpBkT,EAAIlT,GAAK,KAAK,UAAUkT,EAAIlT,EAAE,EACpC,CAAG,EACGkT,EAAI,MAAM,QACZA,EAAI,MAAM,MAAQuG,GAAmBvG,EAAI,MAAM,KAAK,GAClDA,EAAI,MAAM,SAAW,MAAM,QAAQA,EAAI,MAAM,OAAO,EAC/CA,EAAI,MAAM,QAAQ,IAAKwG,IAAO,CAAE,GAAGxG,EAAK,MAAO,CAAE,GAAGA,EAAI,MAAO,QAASwG,CAAC,CAAI,EAAC,EAChFxG,EACT,CACA,SAASuG,GAAmBC,EAAG,CAC7B,OAAI,OAAOA,GAAM,UAAY,CAAC,MAAM,QAAQA,CAAC,IAC3CA,EAAI,OAAO,KAAKA,CAAC,EAAE,OAAQ1Z,GAAM0Z,EAAE1Z,EAAE,IAE/B,MAAM,QAAQ0Z,CAAC,EAAIA,EAAE,KAAK,GAAG,EAAIA,GAAG,MAAM,GAAG,EAAE,OAAQxP,GAAMA,EAAE,KAAM,GAAE,OAAO,OAAO,EAAE,KAAK,GAAG,CACzG,CACA,eAAesP,GAAelG,EAASrC,EAAO,CAC5C,UAAWjR,KAAK,OAAO,KAAKiR,CAAK,EAAG,CAClC,MAAM0I,EAAY3Z,EAAE,WAAW,OAAO,EAClCiR,EAAMjR,aAAc,UACtBiR,EAAMjR,GAAK,MAAMiR,EAAMjR,IAErB,OAAOiR,EAAMjR,EAAE,IAAM,OACvBiR,EAAMjR,GAAK2Z,EAAY,OAAS,GACvB,OAAO1I,EAAMjR,EAAE,IAAM,UAC1B2Z,EACF1I,EAAMjR,GAAK,QAEX,OAAOiR,EAAMjR,GAGlB,CACD,OAAOiR,CACT,CACA,MAAM2I,GAAgB,GACtB,eAAeC,GAAmB,EAAG,CACnC,MAAMC,EAAc,GACpB,cAAO,QAAQ,EAAE,aAAa,EAAE,OAAO,CAAC,CAAC9Z,EAAG0Z,CAAC,IAAM,OAAOA,EAAM,KAAe7G,GAAc,SAAS7S,CAAC,CAAC,EAAE,QAAQ,CAAC,CAACA,EAAG7B,CAAK,IAAM,CAChI,MAAMub,EAAIK,GAAU5b,CAAK,EACzB2b,EAAY,KAAK,GAAGJ,EAAE,IAAKzI,GAAUsI,GAAavZ,EAAGiR,CAAK,CAAC,EAAE,KAAM,EACvE,CAAG,GACO,MAAM,QAAQ,IAAI6I,CAAW,GAAG,KAAI,EAAG,OAAO,OAAO,EAAE,IAAI,CAACE,EAAGxK,KACrEwK,EAAE,GAAK,EAAE,GACTA,EAAE,IAAM,EAAE,IAAMJ,IAAiBpK,EAC1BwK,EACR,CACH,CA0GA,SAASC,IAAc,CACrB,MAAO,CAELjC,GAAmB,EACnB3B,GAAgB,EAChB4C,GAAsB,EACtBtC,GAAqB,EACrBO,GAAsB,EACtBG,GAAqB,EACrBL,GAAyB,CAC7B,CACA,CACA,SAASkD,GAAW7b,EAAU,GAAI,CAChC,MAAO,CACL0X,GAA6B,CAAE,SAAU1X,iBAAS,SAAU,QAASA,iBAAS,WAAY,CAC9F,CACA,CACA,SAAS8b,GAAW9b,EAAU,GAAI,CAChC,MAAM+V,EAAOgG,GAAe,CAC1B,GAAG/b,EACH,QAAS,CAAC,GAAG6b,GAAW7b,CAAO,EAAG,IAAGA,iBAAS,UAAW,EAAE,CAC/D,CAAG,EACD,OAAIA,EAAQ,2BAA6B+V,EAAK,gBAAgB,WAC5DA,EAAK,MAAQ4B,GAAgB5B,EAAK,gBAAgB,QAAQ,GAC5DiF,GAAcjF,CAAI,EACXA,CACT,CAMA,SAASgG,GAAe/b,EAAU,GAAI,CACpC,IAAI8P,EAAU,GACVkM,EAAO,GACPC,EAAO,EACX,MAAMjV,EAAQiC,KACVjJ,WAAS,OACXgH,EAAM,SAAShH,EAAQ,KAAK,EAC9BA,EAAQ,QAAU,CAChB,GAAG4b,GAAa,EAChB,IAAG5b,iBAAS,UAAW,CAAE,CAC7B,EACEA,EAAQ,QAAQ,QAAS4L,GAAMA,EAAE,OAAS5E,EAAM,SAAS4E,EAAE,KAAK,CAAC,EACjE5L,EAAQ,SAAWA,EAAQ,UAAoC,OAC/D,MAAMkc,EAAU,IAAMlV,EAAM,SAAS,kBAAmB+O,CAAI,EACtDA,EAAO,CACX,gBAAiB/V,EACjB,aAAc,CACZ,OAAO8P,CACR,EACD,IAAI,OAAQ,CACV,OAAO9I,CACR,EACD,IAAI0D,EAAQ,CACNA,EAAO,OACT1D,EAAM,SAAS0D,EAAO,KAAK,CAC9B,EACD,KAAK5J,EAAOqb,EAAU,CACpB,MAAMC,EAAc,CAClB,GAAIH,IACJ,QACA,KAAM,CAAE,CAChB,EACM,OAAIE,WAAU,OACZC,EAAY,GAAKD,iBAAU,MACzBA,WAAU,YACZC,EAAY,GAAKD,iBAAU,WAE7BrM,EAAQ,KAAKsM,CAAW,EACxBF,IACO,CACL,SAAU,CACRpM,EAAUA,EAAQ,OAAQwG,GACpBA,EAAE,KAAO8F,EAAY,GAChB,IACTJ,EAAO,CAAE,GAAGA,EAAM,GAAG1F,EAAE,MAAQ,IAC/BA,EAAE,KAAO,GACT4F,IACO,GACR,CACF,EAED,MAAMG,EAAQ,CACZvM,EAAUA,EAAQ,IAAKwG,IACjBA,EAAE,KAAO8F,EAAY,KACvBA,EAAY,MAAQ9F,EAAE,MAAQ+F,EAC9BH,KAEK5F,EACR,CACF,CACT,CACK,EACD,MAAM,aAAc,CAClB,MAAMgG,EAAa,CAAE,KAAM,GAAI,QAAS,CAAC,GAAGxM,CAAO,GACnD,MAAM9I,EAAM,SAAS,kBAAmBsV,CAAU,EAClD,UAAW1M,KAAS0M,EAAW,QAAS,CACtC,MAAMC,EAAc3M,EAAM,KAAQuB,GAAMA,GAExC,GADAvB,EAAM,cAAgB2M,EAAY3M,EAAM,eAAiBA,EAAM,KAAK,EAChEA,EAAM,cACR,UAAWiF,KAAO,MAAM2G,GAAmB5L,CAAK,EAAG,CACjD,MAAM4M,EAAS,CAAE,MAAK,QAAO,gBAAiBzG,EAAK,iBACnD,MAAM/O,EAAM,SAAS,gBAAiBwV,CAAM,EAC5CF,EAAW,KAAK,KAAKE,EAAO,GAAG,CAChC,CAEJ,CACD,aAAMxV,EAAM,SAAS,eAAgBsV,CAAU,EACxCA,EAAW,IACnB,EACD,qBAAsB,CACpB,MAAMjG,EAAM,CAAE,GAAG2F,GACjB,SAAO,GACA3F,CACR,EACD,OAAQ,CAAE,CACd,EACE,SAAK,MAAM,SAAS,OAAQN,CAAI,EACzBA,CACT,CAKA,MAAM0G,GAAkB,CACtB,UACA,aACA,cACA,gBACA,mBACA,oBAEA,cACA,aACA,aACA,iBACA,aACA,eACA,cACA,iBACA,eACA,eACA,mBACA,oBACA,mBACA,mBACA,uBACA,mBACA,qBACA,oBACA,uBACA,qBACA,qBACA,wBACF,EC7gCA,eACA,qCACA,CACA,mBACA,wBACA,SACA,cACA,aACAC,EACA,iBACAA,iBACA,mBACA,mBACA,+BACA/a,wCACA,UACA,UACA,CACA,EAEA+a,CACA,CAEA,4BAGAC,aACA,cACA,wBACA,CACA,eAUA,MATA,CACA,WACAC,KACA3I,oCACAA,kCACAA,gBAEA,CACA,EACA,OACA,CAYA,kBACA,YACA,KAEA,6CACA,SACA4I,KACA,iCACA,CACA,GACA,uBACA9G,CACA,CAEA,cACA,OACA,OACA,8BACA,yBACAnG,0BACA,CACA,CACA,CACA,CAEA,oBACA,aACAkN,QACAC,QACAC,QACAD,uBACA,GACA,0BACA,gBACAnN,UACA,GACAxE,IAYAwE,CACA,CAEA,oBAEA,OADAqN,KACA,SACA,CAEA,0BACA,aACA,MACA,oDACA,mDACA,OACAC,iBACA,CACA,CCwBA,MAAMC,GAAsB,CAC1B,YACF,EAEiB,CAAC,GAAGA,GAAqB,GAAGV,EAAe,EC/I5D,iBACA,kBACAW,GACA,SACA,WACAC,qBACApJ,kCACAA,uBAEA,EACA,OACAqJ,QACA,EACA,cACA,sBACA,EACA,cACA,sBACA,EACA,WACA,sBACA,EACA,UACA,kBACA,EACA,cACA,kBACA,EACA,iBACA,kBACA,EACA,sBACA,gBACA,oBACAC,UACA,KACA,CACA,EACA,iBACA,EACA,eACAC,EACA1H,mBAEAyB,oDACA,EACA,sBACA,OACA,gBACA,mBACA,qBACA,CACA,EACA,mCACA+F,wBACAA,oCACA,qCACAxV,WACAyN,kBAEA,GACAkI,GACAL,iBACAA,CACA,CAKAC,oBCrEO,MAAMK,GAAU,CAAC,KAAO,CAAC,CAAC,KAAO,WAAW,QAAU,qCAAqC,EAAE,CAAC,QAAU,OAAO,CAAC,EAAE,KAAO,GAAG,MAAQ,GAAG,OAAS,GAAG,SAAW,CAAE,GCHvKC,GAAe/S,EAAkBD,GAAY,CAC3C,MAAMoL,EAAO+F,KACb/F,EAAK,KAAK2H,EAAO,EACjB/S,EAAQ,OAAO,IAAIoL,CAAI,EAgBvBpL,EAAQ,SAAWiT,GAEjBjT,EAAQ,WAAW,WAAa,SAAY,CAC1C,KAAM,CAAE,eAAe,EAAG,MAAMkT,cAAO,6BAAa,oBAC9CC,EAAO,MAAMC,EAAchI,EAAK,MAAM,EAC5C,MAAO,CACL,GAAG+H,EACH,mBAAoBA,EAAK,aACzB,YAAaA,EAAK,QAC1B,CACA,CAEA,CAAC,EClCYE,GAAmB,GCMhC,SAASC,EAAiBC,EAAU,CAC9B,OAAOA,GAAa,WACtBA,EAAW9a,GAAmB,CAC5B,SAAU8a,EAAS,MAAQ,GAC3B,OAAQzc,GAAeyc,EAAS,OAAS,EAAE,EAC3C,KAAMA,EAAS,MAAQ,EAC7B,CAAK,GAEH,MAAM7a,EAAMH,EAASgb,EAAS,SAAU,GACxC,MAAO,CACL,KAAM7a,EAAI,SACV,WACA,MAAOnC,GAAWmC,EAAI,MAAM,EAC5B,KAAMA,EAAI,KACV,OAAQ,CAAE,EACV,KAAM,OACN,QAAS,CAAE,EACX,eAAgB,OAChB,KAAM,CAAE,EACR,KAAM6a,CACV,CACA,CACA,SAAetT,EAAkBD,GAAY,CAC3C,MAAMwT,EAAsJxT,EAAQ,WAAW,IACzKyT,EAAS,GACTpX,EAAQ,CACZ,kBAAmB,CAAE,EACrB,iBAAkB,CAAE,EACpB,iBAAkB,CAAE,EACpB,MAAO,CAAE,CACb,EACQqX,EAAe,CAACvW,EAAMwW,KAC1BtX,EAAMc,GAAM,KAAKwW,CAAK,EACf,IAAMtX,EAAMc,GAAM,OAAOd,EAAMc,GAAM,QAAQwW,CAAK,EAAG,CAAC,GAEzDzX,EAAUD,KAAmB,IAAI,QACjC2X,EAAQC,GAASP,EAAiBE,CAAU,CAAC,EACnD,eAAeM,EAAiBpb,EAAKsG,EAAS,CAC5C,GAAI,CACF,MAAM6E,EAAKyP,EAAiB5a,CAAG,EAC/B,UAAWqb,KAAc1X,EAAM,mBAAoB,CACjD,MAAMgC,EAAS,MAAM0V,EAAWlQ,EAAI+P,CAAK,EACzC,GAAIvV,IAAW,IAASA,aAAkB,MACxC,OAEF,GAAIA,EACF,OAAOyV,EAAiBzV,EAAQ,EAAI,CAEvC,CACD,UAAWyQ,KAAWzS,EAAM,kBAC1B,MAAMyS,EAAQjL,EAAI+P,CAAK,EAEzB,OAAO,OAAOA,EAAO/P,CAAE,EAOvB,UAAWkQ,KAAc1X,EAAM,kBAC7B,MAAM0X,EAAWlQ,EAAI+P,CAAK,CAE7B,OAAQjS,EAAP,CAIA,UAAWmN,KAAWzS,EAAM,MAC1B,MAAMyS,EAAQnN,CAAG,CAEpB,CACF,CACD,MAAMqC,EAAS,CACb,aAAc4P,EACd,QAAS,IAAM,QAAQ,QAAS,EAChC,QAAS,CAAE,EACX,QAAS,IAAM,QAAQ,QAAS,EAChC,KAAOlb,GAAQob,EAAiBpb,EAAK,EAAK,EAC1C,QAAUA,GAAQob,EAAiBpb,EAAK,EAAI,EAC5C,KAAM,IAAM,OAAO,QAAQ,GAAG,EAAE,EAChC,GAAKsb,GAAU,OAAO,QAAQ,GAAGA,CAAK,EACtC,QAAS,IAAM,OAAO,QAAQ,GAAG,CAAC,EAClC,cAAgBL,GAAUD,EAAa,iBAAkBC,CAAK,EAC9D,WAAaA,GAAUD,EAAa,kBAAmBC,CAAK,EAC5D,UAAYA,GAAUD,EAAa,iBAAkBC,CAAK,EAC1D,QAAU7E,GAAY4E,EAAa,QAAS5E,CAAO,EACnD,QAASwE,EACT,SAAU,CAAChX,EAAY2X,IAAW,CAChCR,EAAO,KAAKQ,CAAM,CACnB,EACD,UAAW,IAAMR,EACjB,SAAWjX,GAASiX,EAAO,KAAMQ,GAAWA,EAAO,OAASzX,CAAI,EAChE,YAAcA,GAAS,CACrB,MAAM5D,EAAQ6a,EAAO,UAAWQ,GAAWA,EAAO,OAASzX,CAAI,EAC3D5D,IAAU,IACZ6a,EAAO,OAAO7a,EAAO,CAAC,CAEzB,CACL,EACEoH,EAAQ,OAAO,UAAU,aAAc,CACrC,WAAY,GACZ,MAAO,CACL,GAAI,OACJ,OAAQ,QACR,QAAS,QACT,YAAa,OACb,iBAAkB,OAClB,iBAAkB,MACnB,EACD,MAAO,CAACiI,EAAO,CAAE,WAAY,CAC3B,MAAMO,EAAW,IAAMsL,EAAiB7L,EAAM,GAAIA,EAAM,OAAO,EAC/D,MAAO,IAAM,OACX,MAAMgM,EAASjQ,EAAO,QAAQiE,EAAM,EAAE,EACtC,OAAOA,EAAM,QAASrG,IAAM,UAAN,qBAAgB,CAAE,KAAMqG,EAAM,GAAI,WAAU,MAAOgM,IAAYxL,EAAE,IAAK,CAAE,KAAMR,EAAM,GAAI,QAAU0D,IACtHA,EAAE,eAAc,EACTnD,EAAQ,EACd,EAAEH,CAAK,CAClB,CACK,CACL,CAAG,EAODrI,EAAQ,OAAS4T,EACjB5T,EAAQ,YAAcA,EAAQ,aAAe,CAC3C,OAAQ,CAAE,EACV,MAAO,CAAE,CACb,EACE,MAAMkU,EAAgB9Q,GAAS,SAAS,EACxC,SAAQ,MAAM,SAAS,cAAe,SAAY,CAChDY,EAAO,WAAW,MAAOH,EAAIsQ,IAAS,OACpCtQ,EAAG,KAAOgQ,GAAShQ,EAAG,MAAQ,CAAE,GAC5B7D,EAAQ,cACV6D,EAAG,KAAK,QAASjC,IAAc,QAAd,OAAuBiC,EAAG,KAAK,QAElD7D,EAAQ,sBAAwB,GAChC,MAAMoU,EAAoC,IAAI,IAAI,CAAC,GAAGf,GAAkB,GAAGrT,EAAQ,YAAY,MAAM,CAAC,EACtG,UAAW+T,KAAcK,EAAmB,CAC1C,MAAM/V,EAAS,MAAM6B,EAAaF,EAAS+T,EAAY,CAAClQ,EAAIsQ,CAAI,CAAC,EAE/D,GAAI9V,IAAW,IAASA,aAAkB,MAAO,CAC/C,MAAM9I,EAAQ8I,GAAUoD,GAAY,CAClC,WAAY,IACZ,cAAe,mBAAmB+R,GAChD,CAAa,EACD,OAAOtT,EAAaF,EAASiD,GAAW,CAAC1N,CAAK,CAAC,CAChD,CAEH,GAAI8I,GAAUA,IAAW,GACvB,OAAOA,CAEV,CACP,CAAK,EACD2F,EAAO,UAAU,IAAM,CACrB,OAAOhE,EAAQ,qBACrB,CAAK,EACD,MAAMgE,EAAO,QAAQwP,CAAU,EAC1B1a,GAAQ8a,EAAM,SAAUJ,CAAU,GACrC,MAAMtT,EAAaF,EAAS4D,GAAY,CAACgQ,EAAM,QAAQ,CAAC,CAE9D,CAAG,EACM,CACL,QAAS,CACP,QACA,QACD,CACL,CACA,CAAC,EC9KKS,GAA4BC,IAAmB,CACnD,QAAUpf,GACDkS,GAAUlS,EAAK,CACpB,GAAGof,EACH,OAAQ,mBACR,OAAQ,kBACT,GAAE,MAEL,QAAS,CAACpf,EAAKC,IAAU,CACvBiS,GAAUlS,EAAK,CACb,GAAGof,EACH,OAAQ,mBACR,OAAQ,kBACd,CAAK,EAAE,MAAQnf,CACZ,CACH,GACMof,GAAgC,KAAO,CAC3C,QAAUrf,GACAoL,EAAU,EAAG,WAAyC,KAA5B,aAAa,QAAQpL,CAAG,EAE5D,QAAS,CAACA,EAAKC,IAAU,CAClBmL,EAAU,EAAG,YAChB,aAAa,QAAQpL,EAAKC,CAAK,CAClC,CACH,GACMqf,GAAkC,KAAO,CAC7C,QAAUtf,GACAoL,EAAU,EAAG,WAA2C,KAA9B,eAAe,QAAQpL,CAAG,EAE9D,QAAS,CAACA,EAAKC,IAAU,CAClBmL,EAAU,EAAG,YAChB,eAAe,QAAQpL,EAAKC,CAAK,CACpC,CACH,GACasf,GAAiB,CAC5B,aAAcF,GAA+B,EAC7C,eAAgBC,GAAiC,EACjD,QAASH,GAA0B,EACnC,mBAAoBA,EACtB,ECvCA,SAAS3T,GAASgQ,EAAG,CACnB,OAAO,OAAOA,GAAM,UAAYA,IAAM,IACxC,CACA,SAASgE,GAAiBrf,EAASsf,EAAgB,CACjD,SAAUjU,GAASrL,CAAO,EAAIA,EAA0B,OAAO,OAAO,IAAI,EACnE,IAAI,MAAMA,EAAS,CACxB,IAAIiT,EAAQpT,EAAK0f,EAAU,CACzB,OAAI1f,IAAQ,MACH,QAAQ,IAAIoT,EAAQpT,EAAK0f,CAAQ,EACnC,QAAQ,IAAItM,EAAQpT,EAAK0f,CAAQ,GAAK,QAAQ,IAAID,EAAgBzf,EAAK0f,CAAQ,CACvF,CACL,CAAG,CACH,CAGA,SAASC,GAAIrR,EAAOjK,EAAM,CACxB,OAAOA,EAAK,OAAO,CAAC+H,EAAKL,IAChBK,GAAO,KAAO,OAASA,EAAIL,GACjCuC,CAAK,CACV,CACA,SAASoC,GAAIpC,EAAOjK,EAAMoN,EAAK,CAC7B,OAAOpN,EAAK,MAAM,EAAG,EAAE,EAAE,OAAO,CAAC+H,EAAKL,IAChC,gBAAgB,KAAKA,CAAC,EACjB,GAEAK,EAAIL,GAAKK,EAAIL,IAAM,GAC3BuC,CAAK,EAAEjK,EAAKA,EAAK,OAAS,IAAMoN,EAAKnD,CAC1C,CACA,SAASsR,GAAKC,EAAWC,EAAO,CAC9B,OAAOA,EAAM,OAAO,CAACC,EAAU1b,IAAS,CACtC,MAAM2b,EAAY3b,EAAK,MAAM,GAAG,EAChC,OAAOqM,GAAIqP,EAAUC,EAAWL,GAAIE,EAAWG,CAAS,CAAC,CAC1D,EAAE,CAAE,EACP,CAGA,SAASC,GAAaC,EAAO,CAAE,UAAS,aAAY,MAAK,SAAS,CAChE,GAAI,CACF,MAAMC,EAAcC,GAAW,KAAO,OAASA,EAAQ,QAAQpgB,CAAG,EAC9DmgB,GACFD,EAAM,OAAOG,GAAc,KAAO,OAASA,EAAW,YAAYF,CAAW,CAAC,CACjF,OAAQ9f,EAAP,CACIigB,GACF,QAAQ,MAAMjgB,CAAK,CACtB,CACH,CACA,SAASkgB,GAAajS,EAAO,CAAE,UAAS,aAAY,MAAK,QAAO,SAAS,CACvE,GAAI,CACF,MAAMkS,EAAU,MAAM,QAAQV,CAAK,EAAIF,GAAKtR,EAAOwR,CAAK,EAAIxR,EAC5D8R,EAAQ,QAAQpgB,EAAKqgB,EAAW,UAAUG,CAAO,CAAC,CACnD,OAAQngB,EAAP,CACIigB,GACF,QAAQ,MAAMjgB,CAAK,CACtB,CACH,CACA,SAASogB,GAAqBhB,EAAiB,GAAI,CACjD,OAAQ5Z,GAAY,CAClB,KAAM,CAAE,OAAO,EAAO,EAAG4Z,EACnB,CACJ,QAAS,CAAE,UAAUiB,CAAM,EAC3B,OACD,EAAG7a,EACJ,GAAI,CAAC8a,EACH,OACF,MAAMC,GAAgB,MAAM,QAAQD,CAAO,EAAIA,EAAQ,IAAK5U,GAAMyT,GAAiBzT,EAAG0T,CAAc,CAAC,EAAI,CAACD,GAAiBmB,EAASlB,CAAc,CAAC,GAAG,IACpJ,CAAC,CACC,UAAU,aACV,gBAAgB,KAChB,eAAe,KACf,aAAa,CACX,UAAW,KAAK,UAChB,YAAa,KAAK,KACnB,EACD,MAAMS,EAAM,IACZ,QAAQ,KACR,QAAQ,EAChB,IAAY,CACJ,IAAIxT,EACJ,MAAO,CACL,UACA,gBACA,eACA,aACA,MAAOA,EAAK+S,EAAe,MAAQ,KAAO/S,EAAM5K,GAAMA,GAAG9B,CAAG,EAC5D,QACA,OACV,CACO,CACP,EACIkgB,EAAM,SAAW,IAAM,CACrBU,EAAa,QAASC,GAAgB,CACpCN,GAAaL,EAAM,OAAQW,CAAW,CAC9C,CAAO,CACP,EACIX,EAAM,SAAW,CAAC,CAAE,WAAW,EAAI,EAAK,KAAO,CAC7CU,EAAa,QAASC,GAAgB,CACpC,KAAM,CAAE,gBAAe,cAAc,EAAGA,EACpCC,IACFC,GAAiB,MAAgBA,EAAclb,CAAO,GACxDoa,GAAaC,EAAOW,CAAW,EAC3BC,IACFE,GAAgB,MAAgBA,EAAanb,CAAO,EAC9D,CAAO,CACP,EACI+a,EAAa,QAASC,GAAgB,CACpC,KAAM,CAAE,gBAAe,cAAc,EAAGA,EACxCE,GAAiB,MAAgBA,EAAclb,CAAO,EACtDoa,GAAaC,EAAOW,CAAW,EAC/BG,GAAgB,MAAgBA,EAAanb,CAAO,EACpDqa,EAAM,WACJ,CAACe,EAAW3S,IAAU,CACpBiS,GAAajS,EAAOuS,CAAW,CAChC,EACD,CACE,SAAU,EACX,CACT,CACA,CAAK,CACL,CACA,CCrHA,eACA,oEACA/V,SACA,QACA,qDACA,OACA,GACA,GCLeF,IACbsW,GACA5M,GACAwJ,GACAqD,GACAC,EACF,ECVeC,GAAgB,CAC7B,KAAM,WACN,MAAMC,EAAGvO,EAAO,CAId,MAAO,aAAM,cAAM,OAAM,UAAZ,sBACd,CACH,CAAC,ECPDsO,IACA,4BACA,OACA,UACA,YACA,WACA,EACA,UACA,YACA,WACA,EACA,QACA,YACA,SACA,EACA,OACA,YACA,iFACA,CACA,EACA,mBACA,YACA,oBACA,mBACA,GACAvW,MACA,oCACkDA,+BAElD,aACA,+BACA,OACA,iBACA,MACA,QACA,OACA,qBACA,6BACA,uBACA,8BACA,mBACA,mDACA,mDACA,aACA,CACA,IACA,CACA,GACA,eACA,aACAyW,QACAC,sBACA,WACAC,OACA,aACAC,IACAC,UACAJ,WACAnf,UAOA,CACA,aACAuf,YACAC,GACA,CACA,aACA,iBACA,gBACAC,OACAJ,MACA,CAIA,aACAC,GASA,CAQA,OACA,WACA,YACA,QACA,SACA,OACA,CACA,CClGK,WAAW,SACd,WAAW,OAASjb,GAAO,OAAO,CAChC,QAASO,GAAS,CACtB,CAAG,GAGa2D,GAAiBC,EAAQ","names":["suspectProtoRx","suspectConstructorRx","JsonSigRx","jsonParseTransform","key","value","destr","options","_lval","error","HASH_RE","AMPERSAND_RE","EQUAL_RE","PLUS_RE","ENC_CARET_RE","ENC_BACKTICK_RE","ENC_PIPE_RE","ENC_SPACE_RE","encode","text","encodeQueryValue","input","encodeQueryKey","decode","decodeQueryValue","parseQuery","parametersString","object","parameter","s","encodeQueryItem","_value","stringifyQuery","query","k","PROTOCOL_STRICT_REGEX","PROTOCOL_REGEX","PROTOCOL_RELATIVE_REGEX","hasProtocol","inputString","opts","TRAILING_SLASH_RE","hasTrailingSlash","queryParameters","withoutTrailingSlash","s0","withTrailingSlash","hasLeadingSlash","withoutLeadingSlash","withLeadingSlash","withBase","base","isEmptyURL","_base","joinURL","withQuery","parsed","parseURL","mergedQuery","stringifyParsedURL","url","isNonEmptyURL","index","url2","isEqual","a","b","defaultProto","parsePath","protocol","auth","hostAndPath","host","path","pathname","search","hash","fullpath","FetchError","createFetchError","request","response","message","fetchError","payloadMethods","isPayloadMethod","method","isJSONSerializable","textTypes","JSON_RE","detectResponseType","_contentType","contentType","retryStatusCodes","createFetch","globalOptions","onError","context","isAbort","retries","responseCode","$fetchRaw","_request","_options","Headers","fetch","responseType","data","parseFunction","$fetch","r","defaultOptions","_globalThis","ofetch","appConfig","useRuntimeConfig","baseURL","flatHooks","configHooks","hooks","parentName","subHook","name","defaultTask","function_","_createTask","createTask","serialTaskCaller","args","task","promise","hookFunction","parallelTaskCaller","hook","callEachWith","callbacks","arg0","callback","Hookable","originalName","dep","_unreg","_function","arguments_","deprecated","_hooks","deprecatedHooks","removeFns","unreg","caller","event","result","createHooks","createContext","currentInstance","isSingleton","checkConflict","instance","als","_AsyncLocalStorage","_getCurrentInstance","_instance","replace","onRestore","onLeave","asyncHandlers","createNamespace","defaultOpts","contexts","globalKey","defaultNamespace","getContext","asyncHandlersKey","nuxtAppCtx","NuxtPluginIndicator","normalizePlugins","_plugins","plugin","nuxtApp","defineNuxtPlugin","callWithNuxt","nuxt","setup","fn","useNuxtApp","nuxtAppInstance","vm","getCurrentInstance","isObject","_defu","baseObject","defaults","namespace","merger","createDefu","p","c","defuFn","currentValue","H3Error","obj","sanitizeStatusCode","sanitizeStatusMessage","createError","isError","err","_a","originalMessage","MIMES","DISALLOWED_STATUS_CHARS","statusMessage","statusCode","defaultStatusCode","defer","send","type","defaultContentType","resolve","sendRedirect","location","code","html","appendResponseHeader","current","appendHeader","useError","toRef","showError","_err","_createError","useState","autoKey","_key","init","state","initialValue","isRef","useRouter","navigateTo","to","toPath","isExternal","router","redirectLocation","objectHash","hasher","createHasher","buff","write","str","pattern","objString","_objType","objType","objectNumber","keys","isNativeFunction","arr","unordered","entry","contextAdditions","entries","date","sym","bool","string","number","xml","regex","map","set","file","f","object1","object2","hashOptions","pairSplitRegExp","fieldContentRegExp","parse","opt","pairs","dec","i","pair","eq_idx","val","tryDecode","serialize","enc","encodedValue","maxAge","decode2","useRequestEvent","CookieDefaults","useCookie","_opts","cookies","readRawCookies","cookie","ref","_b","writeFinalCookieValue","writeServerCookie","unhook","serializeCookie","firstNonUndefined","DEFAULT_EXTERNAL_REL_ATTRIBUTE","props","prefetched","el","resolveComponent","slots","target","rel","navigate","h","defineNuxtLink","inlineConfig","isVue2","piniaSymbol","MutationType","createPinia","scope","effectScope","_p","toBeInstalled","pinia","markRaw","app","components","_nuxt_components_plugin_mjs_KR1HBZs4kY","asArray","SelfClosingTags","TagsWithInnerContent","HasElementTags","ValidHeadTags","UniqueTags","TagConfigKeys","hashCode","hashTag","tag","computeHashes","hashes","tagDedupeKey","tagName","n","resolveTitleTemplate","template","title","setAttrs","ctx","newEntry","markSideEffect","$el","attrSdeKey","classSdeKey","prevHash","renderDOMHead","head","beforeRenderCtx","dom","tagContexts","setupTagRenderCtx","staleSideEffects","sde","e","renderCtx","renders","pendingRenders","markEl","fragments","pos","queue","children","elTag","props2","tmpTag","tmpRenderId","matchIdx","tmpDedupeKey","pos2","domUpdatePromise","debouncedRenderDOMHead","doDomUpdate","delayFn","PatchDomOnEntryUpdatesPlugin","maybeGetSSRHash","document","TAG_WEIGHTS","tagWeight","SortModifiers","SortTagsPlugin","tagPositionForKey","tag2","prefix","position","offset","TitleTemplatePlugin","titleTemplateIdx","tags","titleIdx","newTitle","DeprecatedTagAttrPlugin","DupeableTags","ProvideTagHashPlugin","resolvedOptions","ValidEventTags","EventHandlersPlugin","stripEventHandlers","mode","eventHandlers","delayedSrc","$eventListenerTarget","sdeKey","eventName","eventDedupeKey","handler","UsesMergeStrategy","DedupesTagsPlugin","dedupe","deduping","dedupeKey","dupedTag","strategy","oldProps","propCount","newTags","dupes","processTemplateParams","config","sub","token","acc","decoded","re","TemplateParamsPlugin","idx","params","activeHead","setActiveHead","getActiveHead","normaliseTag","normaliseProps","normaliseClassProp","v","isDataKey","TagEntityBits","normaliseEntryTags","tagPromises","asArray$1","t","CorePlugins","DOMPlugins","createHead","createHeadCore","_sde","_eid","updated","options2","activeEntry","input2","resolveCtx","transformer","tagCtx","composableNames","root","headSymbol","Vue3","VueReactiveUseHeadPlugin","deactivated","resolvedInput","watchEffect","injectHead","isBrowser","coreComposableNames","legacyHead","version","unhead","api","force","initHeadObject","appHead","node_modules_nuxt_dist_head_runtime_lib_vueuse_head_plugin_mjs_D7WGfuP1A0","useHead","__vitePreload","meta","renderSSRHead","globalMiddleware","getRouteFromPath","fullPath","initialURL","routes","registerHook","guard","route","reactive","handleNavigation","middleware","delta","route2","initialLayout","from","middlewareEntries","usePersistedstateCookies","cookieOptions","usePersistedstateLocalStorage","usePersistedstateSessionStorage","persistedState","normalizeOptions","factoryOptions","receiver","get","pick","baseState","paths","substate","pathArray","hydrateStore","store","fromStorage","storage","serializer","debug","persistState","toStore","createPersistedState","auto","persist","persistences","persistence","runHooks","beforeRestore","afterRestore","_mutation","node_modules__64pinia_nuxt_dist_runtime_plugin_vue3_mjs_A0OWXRrUgq","node_modules_nuxt_dist_app_plugins_router_mjs_PJLmOmdFeM","node_modules__64pinia_plugin_persistedstate_nuxt_dist_runtime_plugin_mjs_1UohGbtF8v","defineComponent","_","isLoading","computed","_throttle","clear","progress","_hide","_timer"],"sources":["../../../node_modules/destr/dist/index.mjs","../../../node_modules/ufo/dist/index.mjs","../../../node_modules/ofetch/dist/shared/ofetch.502a4799.mjs","../../../node_modules/ofetch/dist/index.mjs","../../../virtual:nuxt:/Users/carlesfarpierres/Documents/workspace/app-node-vue/client/.nuxt/paths.mjs","../../../node_modules/hookable/dist/index.mjs","../../../node_modules/unctx/dist/index.mjs","../../../node_modules/nuxt/dist/app/nuxt.mjs","../../../node_modules/defu/dist/defu.mjs","../../../node_modules/h3/dist/index.mjs","../../../node_modules/nuxt/dist/app/composables/error.mjs","../../../node_modules/nuxt/dist/app/composables/state.mjs","../../../node_modules/nuxt/dist/app/composables/router.mjs","../../../node_modules/ohash/dist/index.mjs","../../../node_modules/cookie-es/dist/index.mjs","../../../node_modules/nuxt/dist/app/composables/ssr.mjs","../../../node_modules/nuxt/dist/app/composables/cookie.mjs","../../../node_modules/nuxt/dist/app/components/nuxt-link.mjs","../../app.config.mjs","../../../node_modules/nuxt/dist/app/compat/vue-demi.mjs","../../../node_modules/pinia/dist/pinia.mjs","../../../node_modules/@pinia/nuxt/dist/runtime/plugin.vue3.mjs","../../../virtual:nuxt:/Users/carlesfarpierres/Documents/workspace/app-node-vue/client/.nuxt/components.plugin.mjs","../../../node_modules/@unhead/shared/dist/index.mjs","../../../node_modules/@unhead/dom/dist/index.mjs","../../../node_modules/unhead/dist/index.mjs","../../../node_modules/@unhead/vue/dist/shared/vue.505b826e.mjs","../../../node_modules/@unhead/vue/dist/index.mjs","../../../node_modules/@vueuse/head/dist/index.mjs","../../../virtual:nuxt:/Users/carlesfarpierres/Documents/workspace/app-node-vue/client/.nuxt/nuxt.config.mjs","../../../node_modules/nuxt/dist/head/runtime/lib/vueuse-head.plugin.mjs","../../../virtual:nuxt:/Users/carlesfarpierres/Documents/workspace/app-node-vue/client/.nuxt/middleware.mjs","../../../node_modules/nuxt/dist/app/plugins/router.mjs","../../../node_modules/@pinia-plugin-persistedstate/nuxt/dist/runtime/storages.mjs","../../../node_modules/pinia-plugin-persistedstate/dist/index.mjs","../../../node_modules/@pinia-plugin-persistedstate/nuxt/dist/runtime/plugin.mjs","../../../virtual:nuxt:/Users/carlesfarpierres/Documents/workspace/app-node-vue/client/.nuxt/plugins/server.mjs","../../../node_modules/nuxt/dist/pages/runtime/page-placeholder.mjs","../../../node_modules/nuxt/dist/app/components/nuxt-loading-indicator.mjs","../../../node_modules/nuxt/dist/app/entry.mjs"],"sourcesContent":["const suspectProtoRx = /\"(?:_|\\\\u0{2}5[Ff]){2}(?:p|\\\\u0{2}70)(?:r|\\\\u0{2}72)(?:o|\\\\u0{2}6[Ff])(?:t|\\\\u0{2}74)(?:o|\\\\u0{2}6[Ff])(?:_|\\\\u0{2}5[Ff]){2}\"\\s*:/;\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/;\nconst JsonSigRx = /^\\s*[\"[{]|^\\s*-?\\d[\\d.]{0,14}\\s*$/;\nfunction jsonParseTransform(key, value) {\n  if (key === \"__proto__\") {\n    return;\n  }\n  if (key === \"constructor\" && value && typeof value === \"object\" && \"prototype\" in value) {\n    return;\n  }\n  return value;\n}\nfunction destr(value, options = {}) {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n  const _lval = value.toLowerCase().trim();\n  if (_lval === \"true\") {\n    return true;\n  }\n  if (_lval === \"false\") {\n    return false;\n  }\n  if (_lval === \"null\") {\n    return null;\n  }\n  if (_lval === \"nan\") {\n    return Number.NaN;\n  }\n  if (_lval === \"infinity\") {\n    return Number.POSITIVE_INFINITY;\n  }\n  if (_lval === \"undefined\") {\n    return void 0;\n  }\n  if (!JsonSigRx.test(value)) {\n    if (options.strict) {\n      throw new SyntaxError(\"Invalid JSON\");\n    }\n    return value;\n  }\n  try {\n    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {\n      return JSON.parse(value, jsonParseTransform);\n    }\n    return JSON.parse(value);\n  } catch (error) {\n    if (options.strict) {\n      throw error;\n    }\n    return value;\n  }\n}\n\nexport { destr as default };\n","const n = /[^\\0-\\x7E]/;\nconst t = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\nconst o = {\n  overflow: \"Overflow Error\",\n  \"not-basic\": \"Illegal Input\",\n  \"invalid-input\": \"Invalid Input\"\n};\nconst e = Math.floor;\nconst r = String.fromCharCode;\nfunction s(n2) {\n  throw new RangeError(o[n2]);\n}\nconst c = function(n2, t2) {\n  return n2 + 22 + 75 * (n2 < 26) - ((t2 != 0) << 5);\n};\nconst u = function(n2, t2, o2) {\n  let r2 = 0;\n  for (n2 = o2 ? e(n2 / 700) : n2 >> 1, n2 += e(n2 / t2); n2 > 455; r2 += 36) {\n    n2 = e(n2 / 35);\n  }\n  return e(r2 + 36 * n2 / (n2 + 38));\n};\nfunction toASCII(o2) {\n  return function(n2, o3) {\n    const e2 = n2.split(\"@\");\n    let r2 = \"\";\n    e2.length > 1 && (r2 = e2[0] + \"@\", n2 = e2[1]);\n    const s2 = function(n3, t2) {\n      const o4 = [];\n      let e3 = n3.length;\n      for (; e3--; ) {\n        o4[e3] = t2(n3[e3]);\n      }\n      return o4;\n    }((n2 = n2.replace(t, \".\")).split(\".\"), o3).join(\".\");\n    return r2 + s2;\n  }(o2, function(t2) {\n    return n.test(t2) ? \"xn--\" + function(n2) {\n      const t3 = [];\n      const o3 = (n2 = function(n3) {\n        const t4 = [];\n        let o4 = 0;\n        const e2 = n3.length;\n        for (; o4 < e2; ) {\n          const r2 = n3.charCodeAt(o4++);\n          if (r2 >= 55296 && r2 <= 56319 && o4 < e2) {\n            const e3 = n3.charCodeAt(o4++);\n            (64512 & e3) == 56320 ? t4.push(((1023 & r2) << 10) + (1023 & e3) + 65536) : (t4.push(r2), o4--);\n          } else {\n            t4.push(r2);\n          }\n        }\n        return t4;\n      }(n2)).length;\n      let f = 128;\n      let i = 0;\n      let l = 72;\n      for (const o4 of n2) {\n        o4 < 128 && t3.push(r(o4));\n      }\n      const h = t3.length;\n      let p = h;\n      for (h && t3.push(\"-\"); p < o3; ) {\n        let o4 = 2147483647;\n        for (const t4 of n2) {\n          t4 >= f && t4 < o4 && (o4 = t4);\n        }\n        const a = p + 1;\n        o4 - f > e((2147483647 - i) / a) && s(\"overflow\"), i += (o4 - f) * a, f = o4;\n        for (const o5 of n2) {\n          if (o5 < f && ++i > 2147483647 && s(\"overflow\"), o5 == f) {\n            let n3 = i;\n            for (let o6 = 36; ; o6 += 36) {\n              const s2 = o6 <= l ? 1 : o6 >= l + 26 ? 26 : o6 - l;\n              if (n3 < s2) {\n                break;\n              }\n              const u2 = n3 - s2;\n              const f2 = 36 - s2;\n              t3.push(r(c(s2 + u2 % f2, 0))), n3 = e(u2 / f2);\n            }\n            t3.push(r(c(n3, 0))), l = u(i, a, p == h), i = 0, ++p;\n          }\n        }\n        ++i, ++f;\n      }\n      return t3.join(\"\");\n    }(t2) : t2;\n  });\n}\n\nconst HASH_RE = /#/g;\nconst AMPERSAND_RE = /&/g;\nconst SLASH_RE = /\\//g;\nconst EQUAL_RE = /=/g;\nconst IM_RE = /\\?/g;\nconst PLUS_RE = /\\+/g;\nconst ENC_CARET_RE = /%5e/gi;\nconst ENC_BACKTICK_RE = /%60/gi;\nconst ENC_CURLY_OPEN_RE = /%7b/gi;\nconst ENC_PIPE_RE = /%7c/gi;\nconst ENC_CURLY_CLOSE_RE = /%7d/gi;\nconst ENC_SPACE_RE = /%20/gi;\nconst ENC_SLASH_RE = /%2f/gi;\nconst ENC_ENC_SLASH_RE = /%252f/gi;\nfunction encode(text) {\n  return encodeURI(\"\" + text).replace(ENC_PIPE_RE, \"|\");\n}\nfunction encodeHash(text) {\n  return encode(text).replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryValue(input) {\n  return encode(typeof input === \"string\" ? input : JSON.stringify(input)).replace(PLUS_RE, \"%2B\").replace(ENC_SPACE_RE, \"+\").replace(HASH_RE, \"%23\").replace(AMPERSAND_RE, \"%26\").replace(ENC_BACKTICK_RE, \"`\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, \"%3D\");\n}\nfunction encodePath(text) {\n  return encode(text).replace(HASH_RE, \"%23\").replace(IM_RE, \"%3F\").replace(ENC_ENC_SLASH_RE, \"%2F\").replace(AMPERSAND_RE, \"%26\").replace(PLUS_RE, \"%2B\");\n}\nfunction encodeParam(text) {\n  return encodePath(text).replace(SLASH_RE, \"%2F\");\n}\nfunction decode(text = \"\") {\n  try {\n    return decodeURIComponent(\"\" + text);\n  } catch {\n    return \"\" + text;\n  }\n}\nfunction decodePath(text) {\n  return decode(text.replace(ENC_SLASH_RE, \"%252F\"));\n}\nfunction decodeQueryValue(text) {\n  return decode(text.replace(PLUS_RE, \" \"));\n}\nfunction encodeHost(name = \"\") {\n  return toASCII(name);\n}\n\nfunction parseQuery(parametersString = \"\") {\n  const object = {};\n  if (parametersString[0] === \"?\") {\n    parametersString = parametersString.slice(1);\n  }\n  for (const parameter of parametersString.split(\"&\")) {\n    const s = parameter.match(/([^=]+)=?(.*)/) || [];\n    if (s.length < 2) {\n      continue;\n    }\n    const key = decode(s[1]);\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = decodeQueryValue(s[2] || \"\");\n    if (typeof object[key] !== \"undefined\") {\n      if (Array.isArray(object[key])) {\n        object[key].push(value);\n      } else {\n        object[key] = [object[key], value];\n      }\n    } else {\n      object[key] = value;\n    }\n  }\n  return object;\n}\nfunction encodeQueryItem(key, value) {\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    value = String(value);\n  }\n  if (!value) {\n    return encodeQueryKey(key);\n  }\n  if (Array.isArray(value)) {\n    return value.map((_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`).join(\"&\");\n  }\n  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;\n}\nfunction stringifyQuery(query) {\n  return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).join(\"&\");\n}\n\nclass $URL {\n  constructor(input = \"\") {\n    this.query = {};\n    if (typeof input !== \"string\") {\n      throw new TypeError(\n        `URL input should be string received ${typeof input} (${input})`\n      );\n    }\n    const parsed = parseURL(input);\n    this.protocol = decode(parsed.protocol);\n    this.host = decode(parsed.host);\n    this.auth = decode(parsed.auth);\n    this.pathname = decodePath(parsed.pathname);\n    this.query = parseQuery(parsed.search);\n    this.hash = decode(parsed.hash);\n  }\n  get hostname() {\n    return parseHost(this.host).hostname;\n  }\n  get port() {\n    return parseHost(this.host).port || \"\";\n  }\n  get username() {\n    return parseAuth(this.auth).username;\n  }\n  get password() {\n    return parseAuth(this.auth).password || \"\";\n  }\n  get hasProtocol() {\n    return this.protocol.length;\n  }\n  get isAbsolute() {\n    return this.hasProtocol || this.pathname[0] === \"/\";\n  }\n  get search() {\n    const q = stringifyQuery(this.query);\n    return q.length > 0 ? \"?\" + q : \"\";\n  }\n  get searchParams() {\n    const p = new URLSearchParams();\n    for (const name in this.query) {\n      const value = this.query[name];\n      if (Array.isArray(value)) {\n        for (const v of value) {\n          p.append(name, v);\n        }\n      } else {\n        p.append(\n          name,\n          typeof value === \"string\" ? value : JSON.stringify(value)\n        );\n      }\n    }\n    return p;\n  }\n  get origin() {\n    return (this.protocol ? this.protocol + \"//\" : \"\") + encodeHost(this.host);\n  }\n  get fullpath() {\n    return encodePath(this.pathname) + this.search + encodeHash(this.hash);\n  }\n  get encodedAuth() {\n    if (!this.auth) {\n      return \"\";\n    }\n    const { username, password } = parseAuth(this.auth);\n    return encodeURIComponent(username) + (password ? \":\" + encodeURIComponent(password) : \"\");\n  }\n  get href() {\n    const auth = this.encodedAuth;\n    const originWithAuth = (this.protocol ? this.protocol + \"//\" : \"\") + (auth ? auth + \"@\" : \"\") + encodeHost(this.host);\n    return this.hasProtocol && this.isAbsolute ? originWithAuth + this.fullpath : this.fullpath;\n  }\n  append(url) {\n    if (url.hasProtocol) {\n      throw new Error(\"Cannot append a URL with protocol\");\n    }\n    Object.assign(this.query, url.query);\n    if (url.pathname) {\n      this.pathname = withTrailingSlash(this.pathname) + withoutLeadingSlash(url.pathname);\n    }\n    if (url.hash) {\n      this.hash = url.hash;\n    }\n  }\n  toJSON() {\n    return this.href;\n  }\n  toString() {\n    return this.href;\n  }\n}\n\nfunction isRelative(inputString) {\n  return [\"./\", \"../\"].some((string_) => inputString.startsWith(string_));\n}\nconst PROTOCOL_STRICT_REGEX = /^\\w{2,}:([/\\\\]{1,2})/;\nconst PROTOCOL_REGEX = /^\\w{2,}:([/\\\\]{2})?/;\nconst PROTOCOL_RELATIVE_REGEX = /^([/\\\\]\\s*){2,}[^/\\\\]/;\nfunction hasProtocol(inputString, opts = {}) {\n  if (typeof opts === \"boolean\") {\n    opts = { acceptRelative: opts };\n  }\n  if (opts.strict) {\n    return PROTOCOL_STRICT_REGEX.test(inputString);\n  }\n  return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);\n}\nconst TRAILING_SLASH_RE = /\\/$|\\/\\?/;\nfunction hasTrailingSlash(input = \"\", queryParameters = false) {\n  if (!queryParameters) {\n    return input.endsWith(\"/\");\n  }\n  return TRAILING_SLASH_RE.test(input);\n}\nfunction withoutTrailingSlash(input = \"\", queryParameters = false) {\n  if (!queryParameters) {\n    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || \"/\";\n  }\n  if (!hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  const [s0, ...s] = input.split(\"?\");\n  return (s0.slice(0, -1) || \"/\") + (s.length > 0 ? `?${s.join(\"?\")}` : \"\");\n}\nfunction withTrailingSlash(input = \"\", queryParameters = false) {\n  if (!queryParameters) {\n    return input.endsWith(\"/\") ? input : input + \"/\";\n  }\n  if (hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  const [s0, ...s] = input.split(\"?\");\n  return s0 + \"/\" + (s.length > 0 ? `?${s.join(\"?\")}` : \"\");\n}\nfunction hasLeadingSlash(input = \"\") {\n  return input.startsWith(\"/\");\n}\nfunction withoutLeadingSlash(input = \"\") {\n  return (hasLeadingSlash(input) ? input.slice(1) : input) || \"/\";\n}\nfunction withLeadingSlash(input = \"\") {\n  return hasLeadingSlash(input) ? input : \"/\" + input;\n}\nfunction cleanDoubleSlashes(input = \"\") {\n  return input.split(\"://\").map((string_) => string_.replace(/\\/{2,}/g, \"/\")).join(\"://\");\n}\nfunction withBase(input, base) {\n  if (isEmptyURL(base) || hasProtocol(input)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (input.startsWith(_base)) {\n    return input;\n  }\n  return joinURL(_base, input);\n}\nfunction withoutBase(input, base) {\n  if (isEmptyURL(base)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (!input.startsWith(_base)) {\n    return input;\n  }\n  const trimmed = input.slice(_base.length);\n  return trimmed[0] === \"/\" ? trimmed : \"/\" + trimmed;\n}\nfunction withQuery(input, query) {\n  const parsed = parseURL(input);\n  const mergedQuery = { ...parseQuery(parsed.search), ...query };\n  parsed.search = stringifyQuery(mergedQuery);\n  return stringifyParsedURL(parsed);\n}\nfunction getQuery(input) {\n  return parseQuery(parseURL(input).search);\n}\nfunction isEmptyURL(url) {\n  return !url || url === \"/\";\n}\nfunction isNonEmptyURL(url) {\n  return url && url !== \"/\";\n}\nfunction joinURL(base, ...input) {\n  let url = base || \"\";\n  for (const index of input.filter((url2) => isNonEmptyURL(url2))) {\n    url = url ? withTrailingSlash(url) + withoutLeadingSlash(index) : index;\n  }\n  return url;\n}\nfunction withHttp(input) {\n  return withProtocol(input, \"http://\");\n}\nfunction withHttps(input) {\n  return withProtocol(input, \"https://\");\n}\nfunction withoutProtocol(input) {\n  return withProtocol(input, \"\");\n}\nfunction withProtocol(input, protocol) {\n  const match = input.match(PROTOCOL_REGEX);\n  if (!match) {\n    return protocol + input;\n  }\n  return protocol + input.slice(match[0].length);\n}\nfunction createURL(input) {\n  return new $URL(input);\n}\nfunction normalizeURL(input) {\n  return createURL(input).toString();\n}\nfunction resolveURL(base, ...input) {\n  const url = createURL(base);\n  for (const index of input.filter((url2) => isNonEmptyURL(url2))) {\n    url.append(createURL(index));\n  }\n  return url.toString();\n}\nfunction isSamePath(p1, p2) {\n  return decode(withoutTrailingSlash(p1)) === decode(withoutTrailingSlash(p2));\n}\nfunction isEqual(a, b, options = {}) {\n  if (!options.trailingSlash) {\n    a = withTrailingSlash(a);\n    b = withTrailingSlash(b);\n  }\n  if (!options.leadingSlash) {\n    a = withLeadingSlash(a);\n    b = withLeadingSlash(b);\n  }\n  if (!options.encoding) {\n    a = decode(a);\n    b = decode(b);\n  }\n  return a === b;\n}\n\nfunction parseURL(input = \"\", defaultProto) {\n  if (!hasProtocol(input, { acceptRelative: true })) {\n    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);\n  }\n  const [protocol = \"\", auth, hostAndPath = \"\"] = (input.replace(/\\\\/g, \"/\").match(/([^/:]+:)?\\/\\/([^/@]+@)?(.*)/) || []).splice(1);\n  const [host = \"\", path = \"\"] = (hostAndPath.match(/([^#/?]*)(.*)?/) || []).splice(1);\n  const { pathname, search, hash } = parsePath(\n    path.replace(/\\/(?=[A-Za-z]:)/, \"\")\n  );\n  return {\n    protocol,\n    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : \"\",\n    host,\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parsePath(input = \"\") {\n  const [pathname = \"\", search = \"\", hash = \"\"] = (input.match(/([^#?]*)(\\?[^#]*)?(#.*)?/) || []).splice(1);\n  return {\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parseAuth(input = \"\") {\n  const [username, password] = input.split(\":\");\n  return {\n    username: decode(username),\n    password: decode(password)\n  };\n}\nfunction parseHost(input = \"\") {\n  const [hostname, port] = (input.match(/([^/:]*):?(\\d+)?/) || []).splice(1);\n  return {\n    hostname: decode(hostname),\n    port\n  };\n}\nfunction stringifyParsedURL(parsed) {\n  const fullpath = parsed.pathname + (parsed.search ? (parsed.search.startsWith(\"?\") ? \"\" : \"?\") + parsed.search : \"\") + parsed.hash;\n  if (!parsed.protocol) {\n    return fullpath;\n  }\n  return parsed.protocol + \"//\" + (parsed.auth ? parsed.auth + \"@\" : \"\") + parsed.host + fullpath;\n}\n\nexport { $URL, cleanDoubleSlashes, createURL, decode, decodePath, decodeQueryValue, encode, encodeHash, encodeHost, encodeParam, encodePath, encodeQueryItem, encodeQueryKey, encodeQueryValue, getQuery, hasLeadingSlash, hasProtocol, hasTrailingSlash, isEmptyURL, isEqual, isNonEmptyURL, isRelative, isSamePath, joinURL, normalizeURL, parseAuth, parseHost, parsePath, parseQuery, parseURL, resolveURL, stringifyParsedURL, stringifyQuery, withBase, withHttp, withHttps, withLeadingSlash, withProtocol, withQuery, withTrailingSlash, withoutBase, withoutLeadingSlash, withoutProtocol, withoutTrailingSlash };\n","import destr from 'destr';\nimport { withBase, withQuery } from 'ufo';\n\nclass FetchError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"FetchError\";\n  }\n}\nfunction createFetchError(request, error, response) {\n  let message = \"\";\n  if (error) {\n    message = error.message;\n  }\n  if (request && response) {\n    message = `${message} (${response.status} ${response.statusText} (${request.toString()}))`;\n  } else if (request) {\n    message = `${message} (${request.toString()})`;\n  }\n  const fetchError = new FetchError(message);\n  Object.defineProperty(fetchError, \"request\", {\n    get() {\n      return request;\n    }\n  });\n  Object.defineProperty(fetchError, \"response\", {\n    get() {\n      return response;\n    }\n  });\n  Object.defineProperty(fetchError, \"data\", {\n    get() {\n      return response && response._data;\n    }\n  });\n  Object.defineProperty(fetchError, \"status\", {\n    get() {\n      return response && response.status;\n    }\n  });\n  Object.defineProperty(fetchError, \"statusText\", {\n    get() {\n      return response && response.statusText;\n    }\n  });\n  Object.defineProperty(fetchError, \"statusCode\", {\n    get() {\n      return response && response.status;\n    }\n  });\n  Object.defineProperty(fetchError, \"statusMessage\", {\n    get() {\n      return response && response.statusText;\n    }\n  });\n  return fetchError;\n}\n\nconst payloadMethods = new Set(\n  Object.freeze([\"PATCH\", \"POST\", \"PUT\", \"DELETE\"])\n);\nfunction isPayloadMethod(method = \"GET\") {\n  return payloadMethods.has(method.toUpperCase());\n}\nfunction isJSONSerializable(value) {\n  if (value === void 0) {\n    return false;\n  }\n  const t = typeof value;\n  if (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n    return true;\n  }\n  if (t !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return true;\n  }\n  return value.constructor && value.constructor.name === \"Object\" || typeof value.toJSON === \"function\";\n}\nconst textTypes = /* @__PURE__ */ new Set([\n  \"image/svg\",\n  \"application/xml\",\n  \"application/xhtml\",\n  \"application/html\"\n]);\nconst JSON_RE = /^application\\/(?:[\\w!#$%&*.^`~-]*\\+)?json(;.+)?$/i;\nfunction detectResponseType(_contentType = \"\") {\n  if (!_contentType) {\n    return \"json\";\n  }\n  const contentType = _contentType.split(\";\").shift() || \"\";\n  if (JSON_RE.test(contentType)) {\n    return \"json\";\n  }\n  if (textTypes.has(contentType) || contentType.startsWith(\"text/\")) {\n    return \"text\";\n  }\n  return \"blob\";\n}\n\nconst retryStatusCodes = /* @__PURE__ */ new Set([\n  408,\n  // Request Timeout\n  409,\n  // Conflict\n  425,\n  // Too Early\n  429,\n  // Too Many Requests\n  500,\n  // Internal Server Error\n  502,\n  // Bad Gateway\n  503,\n  // Service Unavailable\n  504\n  //  Gateway Timeout\n]);\nfunction createFetch(globalOptions) {\n  const { fetch, Headers } = globalOptions;\n  function onError(context) {\n    const isAbort = context.error && context.error.name === \"AbortError\" || false;\n    if (context.options.retry !== false && !isAbort) {\n      let retries;\n      if (typeof context.options.retry === \"number\") {\n        retries = context.options.retry;\n      } else {\n        retries = isPayloadMethod(context.options.method) ? 0 : 1;\n      }\n      const responseCode = context.response && context.response.status || 500;\n      if (retries > 0 && retryStatusCodes.has(responseCode)) {\n        return $fetchRaw(context.request, {\n          ...context.options,\n          retry: retries - 1\n        });\n      }\n    }\n    const error = createFetchError(\n      context.request,\n      context.error,\n      context.response\n    );\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(error, $fetchRaw);\n    }\n    throw error;\n  }\n  const $fetchRaw = async function $fetchRaw2(_request, _options = {}) {\n    const context = {\n      request: _request,\n      options: { ...globalOptions.defaults, ..._options },\n      response: void 0,\n      error: void 0\n    };\n    if (context.options.onRequest) {\n      await context.options.onRequest(context);\n    }\n    if (typeof context.request === \"string\") {\n      if (context.options.baseURL) {\n        context.request = withBase(context.request, context.options.baseURL);\n      }\n      if (context.options.query || context.options.params) {\n        context.request = withQuery(context.request, {\n          ...context.options.params,\n          ...context.options.query\n        });\n      }\n      if (context.options.body && isPayloadMethod(context.options.method) && isJSONSerializable(context.options.body)) {\n        context.options.body = typeof context.options.body === \"string\" ? context.options.body : JSON.stringify(context.options.body);\n        context.options.headers = new Headers(context.options.headers);\n        if (!context.options.headers.has(\"content-type\")) {\n          context.options.headers.set(\"content-type\", \"application/json\");\n        }\n        if (!context.options.headers.has(\"accept\")) {\n          context.options.headers.set(\"accept\", \"application/json\");\n        }\n      }\n    }\n    context.response = await fetch(\n      context.request,\n      context.options\n    ).catch(async (error) => {\n      context.error = error;\n      if (context.options.onRequestError) {\n        await context.options.onRequestError(context);\n      }\n      return onError(context);\n    });\n    const responseType = (context.options.parseResponse ? \"json\" : context.options.responseType) || detectResponseType(context.response.headers.get(\"content-type\") || \"\");\n    if (responseType === \"json\") {\n      const data = await context.response.text();\n      const parseFunction = context.options.parseResponse || destr;\n      context.response._data = parseFunction(data);\n    } else if (responseType === \"stream\") {\n      context.response._data = context.response.body;\n    } else {\n      context.response._data = await context.response[responseType]();\n    }\n    if (context.options.onResponse) {\n      await context.options.onResponse(context);\n    }\n    if (context.response.status >= 400 && context.response.status < 600) {\n      if (context.options.onResponseError) {\n        await context.options.onResponseError(context);\n      }\n      return onError(context);\n    }\n    return context.response;\n  };\n  const $fetch = function $fetch2(request, options) {\n    return $fetchRaw(request, options).then((r) => r._data);\n  };\n  $fetch.raw = $fetchRaw;\n  $fetch.native = fetch;\n  $fetch.create = (defaultOptions = {}) => createFetch({\n    ...globalOptions,\n    defaults: {\n      ...globalOptions.defaults,\n      ...defaultOptions\n    }\n  });\n  return $fetch;\n}\n\nexport { FetchError as F, createFetchError as a, createFetch as c };\n","import { c as createFetch } from './shared/ofetch.502a4799.mjs';\nexport { F as FetchError, a as createFetchError } from './shared/ofetch.502a4799.mjs';\nimport 'destr';\nimport 'ufo';\n\nconst _globalThis = function() {\n  if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw new Error(\"unable to locate global object\");\n}();\nconst fetch = _globalThis.fetch || (() => Promise.reject(new Error(\"[ofetch] global.fetch is not supported!\")));\nconst Headers = _globalThis.Headers;\nconst ofetch = createFetch({ fetch, Headers });\nconst $fetch = ofetch;\n\nexport { $fetch, Headers, createFetch, fetch, ofetch };\n","import { joinURL } from '/Users/carlesfarpierres/Documents/workspace/app-node-vue/client/node_modules/ufo/dist/index.mjs'\nimport { useRuntimeConfig } from '#internal/nitro'\nconst appConfig = useRuntimeConfig().app\nexport const baseURL = () => appConfig.baseURL\nexport const buildAssetsDir = () => appConfig.buildAssetsDir\nexport const buildAssetsURL = (...path) => joinURL(publicAssetsURL(), buildAssetsDir(), ...path)\nexport const publicAssetsURL = (...path) => {\n  const publicBase = appConfig.cdnURL || appConfig.baseURL\n  return path.length ? joinURL(publicBase, ...path) : publicBase\n}\nif (process.client) {\n  globalThis.__buildAssetsURL = buildAssetsURL\n  globalThis.__publicAssetsURL = publicAssetsURL\n}","function flatHooks(configHooks, hooks = {}, parentName) {\n  for (const key in configHooks) {\n    const subHook = configHooks[key];\n    const name = parentName ? `${parentName}:${key}` : key;\n    if (typeof subHook === \"object\" && subHook !== null) {\n      flatHooks(subHook, hooks, name);\n    } else if (typeof subHook === \"function\") {\n      hooks[name] = subHook;\n    }\n  }\n  return hooks;\n}\nfunction mergeHooks(...hooks) {\n  const finalHooks = {};\n  for (const hook of hooks) {\n    const flatenHook = flatHooks(hook);\n    for (const key in flatenHook) {\n      if (finalHooks[key]) {\n        finalHooks[key].push(flatenHook[key]);\n      } else {\n        finalHooks[key] = [flatenHook[key]];\n      }\n    }\n  }\n  for (const key in finalHooks) {\n    if (finalHooks[key].length > 1) {\n      const array = finalHooks[key];\n      finalHooks[key] = (...arguments_) => serial(array, (function_) => function_(...arguments_));\n    } else {\n      finalHooks[key] = finalHooks[key][0];\n    }\n  }\n  return finalHooks;\n}\nfunction serial(tasks, function_) {\n  return tasks.reduce(\n    (promise, task) => promise.then(() => function_(task)),\n    Promise.resolve()\n  );\n}\nconst defaultTask = { run: (function_) => function_() };\nconst _createTask = () => defaultTask;\nconst createTask = typeof console.createTask !== \"undefined\" ? console.createTask : _createTask;\nfunction serialTaskCaller(hooks, args) {\n  const name = args.shift();\n  const task = createTask(name);\n  return hooks.reduce(\n    (promise, hookFunction) => promise.then(() => task.run(() => hookFunction(...args))),\n    Promise.resolve()\n  );\n}\nfunction parallelTaskCaller(hooks, args) {\n  const name = args.shift();\n  const task = createTask(name);\n  return Promise.all(hooks.map((hook) => task.run(() => hook(...args))));\n}\nfunction serialCaller(hooks, arguments_) {\n  return hooks.reduce(\n    (promise, hookFunction) => promise.then(() => hookFunction(...arguments_ || [])),\n    Promise.resolve()\n  );\n}\nfunction parallelCaller(hooks, args) {\n  return Promise.all(hooks.map((hook) => hook(...args || [])));\n}\nfunction callEachWith(callbacks, arg0) {\n  for (const callback of [...callbacks]) {\n    callback(arg0);\n  }\n}\n\nclass Hookable {\n  constructor() {\n    this._hooks = {};\n    this._before = void 0;\n    this._after = void 0;\n    this._deprecatedMessages = void 0;\n    this._deprecatedHooks = {};\n    this.hook = this.hook.bind(this);\n    this.callHook = this.callHook.bind(this);\n    this.callHookWith = this.callHookWith.bind(this);\n  }\n  hook(name, function_, options = {}) {\n    if (!name || typeof function_ !== \"function\") {\n      return () => {\n      };\n    }\n    const originalName = name;\n    let dep;\n    while (this._deprecatedHooks[name]) {\n      dep = this._deprecatedHooks[name];\n      name = dep.to;\n    }\n    if (dep && !options.allowDeprecated) {\n      let message = dep.message;\n      if (!message) {\n        message = `${originalName} hook has been deprecated` + (dep.to ? `, please use ${dep.to}` : \"\");\n      }\n      if (!this._deprecatedMessages) {\n        this._deprecatedMessages = /* @__PURE__ */ new Set();\n      }\n      if (!this._deprecatedMessages.has(message)) {\n        console.warn(message);\n        this._deprecatedMessages.add(message);\n      }\n    }\n    if (!function_.name) {\n      try {\n        Object.defineProperty(function_, \"name\", {\n          get: () => \"_\" + name.replace(/\\W+/g, \"_\") + \"_hook_cb\",\n          configurable: true\n        });\n      } catch {\n      }\n    }\n    this._hooks[name] = this._hooks[name] || [];\n    this._hooks[name].push(function_);\n    return () => {\n      if (function_) {\n        this.removeHook(name, function_);\n        function_ = void 0;\n      }\n    };\n  }\n  hookOnce(name, function_) {\n    let _unreg;\n    let _function = (...arguments_) => {\n      if (typeof _unreg === \"function\") {\n        _unreg();\n      }\n      _unreg = void 0;\n      _function = void 0;\n      return function_(...arguments_);\n    };\n    _unreg = this.hook(name, _function);\n    return _unreg;\n  }\n  removeHook(name, function_) {\n    if (this._hooks[name]) {\n      const index = this._hooks[name].indexOf(function_);\n      if (index !== -1) {\n        this._hooks[name].splice(index, 1);\n      }\n      if (this._hooks[name].length === 0) {\n        delete this._hooks[name];\n      }\n    }\n  }\n  deprecateHook(name, deprecated) {\n    this._deprecatedHooks[name] = typeof deprecated === \"string\" ? { to: deprecated } : deprecated;\n    const _hooks = this._hooks[name] || [];\n    delete this._hooks[name];\n    for (const hook of _hooks) {\n      this.hook(name, hook);\n    }\n  }\n  deprecateHooks(deprecatedHooks) {\n    Object.assign(this._deprecatedHooks, deprecatedHooks);\n    for (const name in deprecatedHooks) {\n      this.deprecateHook(name, deprecatedHooks[name]);\n    }\n  }\n  addHooks(configHooks) {\n    const hooks = flatHooks(configHooks);\n    const removeFns = Object.keys(hooks).map(\n      (key) => this.hook(key, hooks[key])\n    );\n    return () => {\n      for (const unreg of removeFns.splice(0, removeFns.length)) {\n        unreg();\n      }\n    };\n  }\n  removeHooks(configHooks) {\n    const hooks = flatHooks(configHooks);\n    for (const key in hooks) {\n      this.removeHook(key, hooks[key]);\n    }\n  }\n  removeAllHooks() {\n    for (const key in this._hooks) {\n      delete this._hooks[key];\n    }\n  }\n  callHook(name, ...arguments_) {\n    arguments_.unshift(name);\n    return this.callHookWith(serialTaskCaller, name, ...arguments_);\n  }\n  callHookParallel(name, ...arguments_) {\n    arguments_.unshift(name);\n    return this.callHookWith(parallelTaskCaller, name, ...arguments_);\n  }\n  callHookWith(caller, name, ...arguments_) {\n    const event = this._before || this._after ? { name, args: arguments_, context: {} } : void 0;\n    if (this._before) {\n      callEachWith(this._before, event);\n    }\n    const result = caller(\n      name in this._hooks ? [...this._hooks[name]] : [],\n      arguments_\n    );\n    if (result instanceof Promise) {\n      return result.finally(() => {\n        if (this._after && event) {\n          callEachWith(this._after, event);\n        }\n      });\n    }\n    if (this._after && event) {\n      callEachWith(this._after, event);\n    }\n    return result;\n  }\n  beforeEach(function_) {\n    this._before = this._before || [];\n    this._before.push(function_);\n    return () => {\n      if (this._before !== void 0) {\n        const index = this._before.indexOf(function_);\n        if (index !== -1) {\n          this._before.splice(index, 1);\n        }\n      }\n    };\n  }\n  afterEach(function_) {\n    this._after = this._after || [];\n    this._after.push(function_);\n    return () => {\n      if (this._after !== void 0) {\n        const index = this._after.indexOf(function_);\n        if (index !== -1) {\n          this._after.splice(index, 1);\n        }\n      }\n    };\n  }\n}\nfunction createHooks() {\n  return new Hookable();\n}\n\nconst isBrowser = typeof window !== \"undefined\";\nfunction createDebugger(hooks, _options = {}) {\n  const options = {\n    inspect: isBrowser,\n    group: isBrowser,\n    filter: () => true,\n    ..._options\n  };\n  const _filter = options.filter;\n  const filter = typeof _filter === \"string\" ? (name) => name.startsWith(_filter) : _filter;\n  const _tag = options.tag ? `[${options.tag}] ` : \"\";\n  const logPrefix = (event) => _tag + event.name + \"\".padEnd(event._id, \"\\0\");\n  const _idCtr = {};\n  const unsubscribeBefore = hooks.beforeEach((event) => {\n    if (filter !== void 0 && !filter(event.name)) {\n      return;\n    }\n    _idCtr[event.name] = _idCtr[event.name] || 0;\n    event._id = _idCtr[event.name]++;\n    console.time(logPrefix(event));\n  });\n  const unsubscribeAfter = hooks.afterEach((event) => {\n    if (filter !== void 0 && !filter(event.name)) {\n      return;\n    }\n    if (options.group) {\n      console.groupCollapsed(event.name);\n    }\n    if (options.inspect) {\n      console.timeLog(logPrefix(event), event.args);\n    } else {\n      console.timeEnd(logPrefix(event));\n    }\n    if (options.group) {\n      console.groupEnd();\n    }\n    _idCtr[event.name]--;\n  });\n  return {\n    /** Stop debugging and remove listeners */\n    close: () => {\n      unsubscribeBefore();\n      unsubscribeAfter();\n    }\n  };\n}\n\nexport { Hookable, createDebugger, createHooks, flatHooks, mergeHooks, parallelCaller, serial, serialCaller };\n","function createContext(opts = {}) {\n  let currentInstance;\n  let isSingleton = false;\n  const checkConflict = (instance) => {\n    if (currentInstance && currentInstance !== instance) {\n      throw new Error(\"Context conflict\");\n    }\n  };\n  let als;\n  if (opts.asyncContext) {\n    const _AsyncLocalStorage = opts.AsyncLocalStorage || globalThis.AsyncLocalStorage;\n    if (_AsyncLocalStorage) {\n      als = new _AsyncLocalStorage();\n    } else {\n      console.warn(\"[unctx] `AsyncLocalStorage` is not provided.\");\n    }\n  }\n  const _getCurrentInstance = () => {\n    if (als && currentInstance === void 0) {\n      const instance = als.getStore();\n      if (instance !== void 0) {\n        return instance;\n      }\n    }\n    return currentInstance;\n  };\n  return {\n    use: () => {\n      const _instance = _getCurrentInstance();\n      if (_instance === void 0) {\n        throw new Error(\"Context is not available\");\n      }\n      return _instance;\n    },\n    tryUse: () => {\n      return _getCurrentInstance();\n    },\n    set: (instance, replace) => {\n      if (!replace) {\n        checkConflict(instance);\n      }\n      currentInstance = instance;\n      isSingleton = true;\n    },\n    unset: () => {\n      currentInstance = void 0;\n      isSingleton = false;\n    },\n    call: (instance, callback) => {\n      checkConflict(instance);\n      currentInstance = instance;\n      try {\n        return als ? als.run(instance, callback) : callback();\n      } finally {\n        if (!isSingleton) {\n          currentInstance = void 0;\n        }\n      }\n    },\n    async callAsync(instance, callback) {\n      currentInstance = instance;\n      const onRestore = () => {\n        currentInstance = instance;\n      };\n      const onLeave = () => currentInstance === instance ? onRestore : void 0;\n      asyncHandlers.add(onLeave);\n      try {\n        const r = als ? als.run(instance, callback) : callback();\n        if (!isSingleton) {\n          currentInstance = void 0;\n        }\n        return await r;\n      } finally {\n        asyncHandlers.delete(onLeave);\n      }\n    }\n  };\n}\nfunction createNamespace(defaultOpts = {}) {\n  const contexts = {};\n  return {\n    get(key, opts = {}) {\n      if (!contexts[key]) {\n        contexts[key] = createContext({ ...defaultOpts, ...opts });\n      }\n      contexts[key];\n      return contexts[key];\n    }\n  };\n}\nconst _globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : {};\nconst globalKey = \"__unctx__\";\nconst defaultNamespace = _globalThis[globalKey] || (_globalThis[globalKey] = createNamespace());\nconst getContext = (key, opts = {}) => defaultNamespace.get(key, opts);\nconst useContext = (key, opts = {}) => getContext(key, opts).use;\nconst asyncHandlersKey = \"__unctx_async_handlers__\";\nconst asyncHandlers = _globalThis[asyncHandlersKey] || (_globalThis[asyncHandlersKey] = /* @__PURE__ */ new Set());\nfunction executeAsync(function_) {\n  const restores = [];\n  for (const leaveHandler of asyncHandlers) {\n    const restore2 = leaveHandler();\n    if (restore2) {\n      restores.push(restore2);\n    }\n  }\n  const restore = () => {\n    for (const restore2 of restores) {\n      restore2();\n    }\n  };\n  let awaitable = function_();\n  if (awaitable && typeof awaitable === \"object\" && \"catch\" in awaitable) {\n    awaitable = awaitable.catch((error) => {\n      restore();\n      throw error;\n    });\n  }\n  return [awaitable, restore];\n}\nfunction withAsyncContext(function_, transformed) {\n  if (!transformed) {\n    console.warn(\n      \"[unctx] `withAsyncContext` needs transformation for async context support in\",\n      function_,\n      \"\\n\",\n      function_.toString()\n    );\n  }\n  return function_;\n}\n\nexport { createContext, createNamespace, defaultNamespace, executeAsync, getContext, useContext, withAsyncContext };\n","import { getCurrentInstance, reactive } from \"vue\";\nimport { createHooks } from \"hookable\";\nimport { getContext } from \"unctx\";\nconst nuxtAppCtx = getContext(\"nuxt-app\");\nexport const NuxtPluginIndicator = \"__nuxt_plugin\";\nexport function createNuxtApp(options) {\n  let hydratingCount = 0;\n  const nuxtApp = {\n    provide: void 0,\n    globalName: \"nuxt\",\n    payload: reactive({\n      data: {},\n      state: {},\n      _errors: {},\n      ...process.client ? window.__NUXT__ : { serverRendered: true }\n    }),\n    static: {\n      data: {}\n    },\n    isHydrating: process.client,\n    deferHydration() {\n      if (!nuxtApp.isHydrating) {\n        return () => {\n        };\n      }\n      hydratingCount++;\n      let called = false;\n      return () => {\n        if (called) {\n          return;\n        }\n        called = true;\n        hydratingCount--;\n        if (hydratingCount === 0) {\n          nuxtApp.isHydrating = false;\n          return nuxtApp.callHook(\"app:suspense:resolve\");\n        }\n      };\n    },\n    _asyncDataPromises: {},\n    _asyncData: {},\n    ...options\n  };\n  nuxtApp.hooks = createHooks();\n  nuxtApp.hook = nuxtApp.hooks.hook;\n  nuxtApp.callHook = nuxtApp.hooks.callHook;\n  nuxtApp.provide = (name, value) => {\n    const $name = \"$\" + name;\n    defineGetter(nuxtApp, $name, value);\n    defineGetter(nuxtApp.vueApp.config.globalProperties, $name, value);\n  };\n  defineGetter(nuxtApp.vueApp, \"$nuxt\", nuxtApp);\n  defineGetter(nuxtApp.vueApp.config.globalProperties, \"$nuxt\", nuxtApp);\n  if (process.server) {\n    if (nuxtApp.ssrContext) {\n      nuxtApp.ssrContext.nuxt = nuxtApp;\n    }\n    nuxtApp.ssrContext = nuxtApp.ssrContext || {};\n    if (nuxtApp.ssrContext.payload) {\n      Object.assign(nuxtApp.payload, nuxtApp.ssrContext.payload);\n    }\n    nuxtApp.ssrContext.payload = nuxtApp.payload;\n    nuxtApp.payload.config = {\n      public: options.ssrContext.runtimeConfig.public,\n      app: options.ssrContext.runtimeConfig.app\n    };\n  }\n  const runtimeConfig = process.server ? options.ssrContext.runtimeConfig : reactive(nuxtApp.payload.config);\n  const compatibilityConfig = new Proxy(runtimeConfig, {\n    get(target, prop) {\n      if (prop === \"public\") {\n        return target.public;\n      }\n      return target[prop] ?? target.public[prop];\n    },\n    set(target, prop, value) {\n      if (process.server || prop === \"public\" || prop === \"app\") {\n        return false;\n      }\n      target[prop] = value;\n      target.public[prop] = value;\n      return true;\n    }\n  });\n  nuxtApp.provide(\"config\", compatibilityConfig);\n  return nuxtApp;\n}\nexport async function applyPlugin(nuxtApp, plugin) {\n  if (typeof plugin !== \"function\") {\n    return;\n  }\n  const { provide } = await callWithNuxt(nuxtApp, plugin, [nuxtApp]) || {};\n  if (provide && typeof provide === \"object\") {\n    for (const key in provide) {\n      nuxtApp.provide(key, provide[key]);\n    }\n  }\n}\nexport async function applyPlugins(nuxtApp, plugins) {\n  for (const plugin of plugins) {\n    await applyPlugin(nuxtApp, plugin);\n  }\n}\nexport function normalizePlugins(_plugins) {\n  const unwrappedPlugins = [];\n  const legacyInjectPlugins = [];\n  const invalidPlugins = [];\n  const plugins = _plugins.map((plugin) => {\n    if (typeof plugin !== \"function\") {\n      invalidPlugins.push(plugin);\n      return null;\n    }\n    if (plugin.length > 1) {\n      legacyInjectPlugins.push(plugin);\n      return (nuxtApp) => plugin(nuxtApp, nuxtApp.provide);\n    }\n    if (!isNuxtPlugin(plugin)) {\n      unwrappedPlugins.push(plugin);\n    }\n    return plugin;\n  }).filter(Boolean);\n  if (process.dev && legacyInjectPlugins.length) {\n    console.warn(\"[warn] [nuxt] You are using a plugin with legacy Nuxt 2 format (context, inject) which is likely to be broken. In the future they will be ignored:\", legacyInjectPlugins.map((p) => p.name || p).join(\",\"));\n  }\n  if (process.dev && invalidPlugins.length) {\n    console.warn(\"[warn] [nuxt] Some plugins are not exposing a function and skipped:\", invalidPlugins);\n  }\n  if (process.dev && unwrappedPlugins.length) {\n    console.warn(\"[warn] [nuxt] You are using a plugin that has not been wrapped in `defineNuxtPlugin`. It is advised to wrap your plugins as in the future this may enable enhancements:\", unwrappedPlugins.map((p) => p.name || p).join(\",\"));\n  }\n  return plugins;\n}\nexport function defineNuxtPlugin(plugin) {\n  plugin[NuxtPluginIndicator] = true;\n  return plugin;\n}\nexport function isNuxtPlugin(plugin) {\n  return typeof plugin === \"function\" && NuxtPluginIndicator in plugin;\n}\nexport function callWithNuxt(nuxt, setup, args) {\n  const fn = () => args ? setup(...args) : setup();\n  if (process.server) {\n    return nuxtAppCtx.callAsync(nuxt, fn);\n  } else {\n    nuxtAppCtx.set(nuxt);\n    return fn();\n  }\n}\nexport function useNuxtApp() {\n  const nuxtAppInstance = nuxtAppCtx.tryUse();\n  if (!nuxtAppInstance) {\n    const vm = getCurrentInstance();\n    if (!vm) {\n      throw new Error(\"nuxt instance unavailable\");\n    }\n    return vm.appContext.app.$nuxt;\n  }\n  return nuxtAppInstance;\n}\nexport function useRuntimeConfig() {\n  return useNuxtApp().$config;\n}\nfunction defineGetter(obj, key, val) {\n  Object.defineProperty(obj, key, { get: () => val });\n}\nexport function defineAppConfig(config) {\n  return config;\n}\n","function isObject(value) {\n  return value !== null && typeof value === \"object\";\n}\nfunction _defu(baseObject, defaults, namespace = \".\", merger) {\n  if (!isObject(defaults)) {\n    return _defu(baseObject, {}, namespace, merger);\n  }\n  const object = Object.assign({}, defaults);\n  for (const key in baseObject) {\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = baseObject[key];\n    if (value === null || value === void 0) {\n      continue;\n    }\n    if (merger && merger(object, key, value, namespace)) {\n      continue;\n    }\n    if (Array.isArray(value) && Array.isArray(object[key])) {\n      object[key] = [...value, ...object[key]];\n    } else if (isObject(value) && isObject(object[key])) {\n      object[key] = _defu(\n        value,\n        object[key],\n        (namespace ? `${namespace}.` : \"\") + key.toString(),\n        merger\n      );\n    } else {\n      object[key] = value;\n    }\n  }\n  return object;\n}\nfunction createDefu(merger) {\n  return (...arguments_) => (\n    // eslint-disable-next-line unicorn/no-array-reduce\n    arguments_.reduce((p, c) => _defu(p, c, \"\", merger), {})\n  );\n}\nconst defu = createDefu();\nconst defuFn = createDefu((object, key, currentValue) => {\n  if (typeof object[key] !== \"undefined\" && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\nconst defuArrayFn = createDefu((object, key, currentValue) => {\n  if (Array.isArray(object[key]) && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\n\nexport { createDefu, defu as default, defu, defuArrayFn, defuFn };\n","import { withoutTrailingSlash, withoutBase, getQuery as getQuery$1 } from 'ufo';\nimport { createRouter as createRouter$1 } from 'radix3';\nimport destr from 'destr';\nimport { parse as parse$1, serialize } from 'cookie-es';\nimport crypto from 'uncrypto';\nimport { seal, defaults, unseal } from 'iron-webcrypto';\nimport { defu } from 'defu';\n\nfunction useBase(base, handler) {\n  base = withoutTrailingSlash(base);\n  if (!base) {\n    return handler;\n  }\n  return eventHandler((event) => {\n    event.node.req.originalUrl = event.node.req.originalUrl || event.node.req.url || \"/\";\n    event.node.req.url = withoutBase(event.node.req.url || \"/\", base);\n    return handler(event);\n  });\n}\n\nfunction parse(multipartBodyBuffer, boundary) {\n  let lastline = \"\";\n  let state = 0 /* INIT */;\n  let buffer = [];\n  const allParts = [];\n  let currentPartHeaders = [];\n  for (let i = 0; i < multipartBodyBuffer.length; i++) {\n    const prevByte = i > 0 ? multipartBodyBuffer[i - 1] : null;\n    const currByte = multipartBodyBuffer[i];\n    const newLineChar = currByte === 10 || currByte === 13;\n    if (!newLineChar) {\n      lastline += String.fromCodePoint(currByte);\n    }\n    const newLineDetected = currByte === 10 && prevByte === 13;\n    if (0 /* INIT */ === state && newLineDetected) {\n      if (\"--\" + boundary === lastline) {\n        state = 1 /* READING_HEADERS */;\n      }\n      lastline = \"\";\n    } else if (1 /* READING_HEADERS */ === state && newLineDetected) {\n      if (lastline.length > 0) {\n        const i2 = lastline.indexOf(\":\");\n        if (i2 > 0) {\n          const name = lastline.slice(0, i2).toLowerCase();\n          const value = lastline.slice(i2 + 1).trim();\n          currentPartHeaders.push([name, value]);\n        }\n      } else {\n        state = 2 /* READING_DATA */;\n        buffer = [];\n      }\n      lastline = \"\";\n    } else if (2 /* READING_DATA */ === state) {\n      if (lastline.length > boundary.length + 4) {\n        lastline = \"\";\n      }\n      if (\"--\" + boundary === lastline) {\n        const j = buffer.length - lastline.length;\n        const part = buffer.slice(0, j - 1);\n        allParts.push(process(part, currentPartHeaders));\n        buffer = [];\n        currentPartHeaders = [];\n        lastline = \"\";\n        state = 3 /* READING_PART_SEPARATOR */;\n      } else {\n        buffer.push(currByte);\n      }\n      if (newLineDetected) {\n        lastline = \"\";\n      }\n    } else if (3 /* READING_PART_SEPARATOR */ === state && newLineDetected) {\n      state = 1 /* READING_HEADERS */;\n    }\n  }\n  return allParts;\n}\nfunction process(data, headers) {\n  const dataObj = {};\n  const contentDispositionHeader = headers.find((h) => h[0] === \"content-disposition\")?.[1] || \"\";\n  for (const i of contentDispositionHeader.split(\";\")) {\n    const s = i.split(\"=\");\n    if (s.length !== 2) {\n      continue;\n    }\n    const key = (s[0] || \"\").trim();\n    if (key === \"name\" || key === \"filename\") {\n      dataObj[key] = (s[1] || \"\").trim().replace(/\"/g, \"\");\n    }\n  }\n  const contentType = headers.find((h) => h[0] === \"content-type\")?.[1] || \"\";\n  if (contentType) {\n    dataObj.type = contentType;\n  }\n  dataObj.data = Buffer.from(data);\n  return dataObj;\n}\n\nclass H3Error extends Error {\n  constructor() {\n    super(...arguments);\n    this.statusCode = 500;\n    this.fatal = false;\n    this.unhandled = false;\n    this.statusMessage = void 0;\n  }\n  toJSON() {\n    const obj = {\n      message: this.message,\n      statusCode: sanitizeStatusCode(this.statusCode, 500)\n    };\n    if (this.statusMessage) {\n      obj.statusMessage = sanitizeStatusMessage(this.statusMessage);\n    }\n    if (this.data !== void 0) {\n      obj.data = this.data;\n    }\n    return obj;\n  }\n}\nH3Error.__h3_error__ = true;\nfunction createError(input) {\n  if (typeof input === \"string\") {\n    return new H3Error(input);\n  }\n  if (isError(input)) {\n    return input;\n  }\n  const err = new H3Error(\n    input.message ?? input.statusMessage,\n    // @ts-ignore\n    input.cause ? { cause: input.cause } : void 0\n  );\n  if (\"stack\" in input) {\n    try {\n      Object.defineProperty(err, \"stack\", {\n        get() {\n          return input.stack;\n        }\n      });\n    } catch {\n      try {\n        err.stack = input.stack;\n      } catch {\n      }\n    }\n  }\n  if (input.data) {\n    err.data = input.data;\n  }\n  if (input.statusCode) {\n    err.statusCode = sanitizeStatusCode(input.statusCode, err.statusCode);\n  } else if (input.status) {\n    err.statusCode = sanitizeStatusCode(input.status, err.statusCode);\n  }\n  if (input.statusMessage) {\n    err.statusMessage = input.statusMessage;\n  } else if (input.statusText) {\n    err.statusMessage = input.statusText;\n  }\n  if (err.statusMessage) {\n    const originalMessage = err.statusMessage;\n    const sanitizedMessage = sanitizeStatusMessage(err.statusMessage);\n    if (sanitizedMessage !== originalMessage) {\n      console.warn(\n        \"[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future `statusMessage` will be sanitized by default.\"\n      );\n    }\n  }\n  if (input.fatal !== void 0) {\n    err.fatal = input.fatal;\n  }\n  if (input.unhandled !== void 0) {\n    err.unhandled = input.unhandled;\n  }\n  return err;\n}\nfunction sendError(event, error, debug) {\n  if (event.node.res.writableEnded) {\n    return;\n  }\n  const h3Error = isError(error) ? error : createError(error);\n  const responseBody = {\n    statusCode: h3Error.statusCode,\n    statusMessage: h3Error.statusMessage,\n    stack: [],\n    data: h3Error.data\n  };\n  if (debug) {\n    responseBody.stack = (h3Error.stack || \"\").split(\"\\n\").map((l) => l.trim());\n  }\n  if (event.node.res.writableEnded) {\n    return;\n  }\n  const _code = Number.parseInt(h3Error.statusCode);\n  setResponseStatus(event, _code, h3Error.statusMessage);\n  event.node.res.setHeader(\"content-type\", MIMES.json);\n  event.node.res.end(JSON.stringify(responseBody, void 0, 2));\n}\nfunction isError(input) {\n  return input?.constructor?.__h3_error__ === true;\n}\n\nfunction getQuery(event) {\n  return getQuery$1(event.node.req.url || \"\");\n}\nfunction getRouterParams(event) {\n  return event.context.params || {};\n}\nfunction getRouterParam(event, name) {\n  const params = getRouterParams(event);\n  return params[name];\n}\nfunction getMethod(event, defaultMethod = \"GET\") {\n  return (event.node.req.method || defaultMethod).toUpperCase();\n}\nfunction isMethod(event, expected, allowHead) {\n  const method = getMethod(event);\n  if (allowHead && method === \"HEAD\") {\n    return true;\n  }\n  if (typeof expected === \"string\") {\n    if (method === expected) {\n      return true;\n    }\n  } else if (expected.includes(method)) {\n    return true;\n  }\n  return false;\n}\nfunction assertMethod(event, expected, allowHead) {\n  if (!isMethod(event, expected, allowHead)) {\n    throw createError({\n      statusCode: 405,\n      statusMessage: \"HTTP method is not allowed.\"\n    });\n  }\n}\nfunction getRequestHeaders(event) {\n  const _headers = {};\n  for (const key in event.node.req.headers) {\n    const val = event.node.req.headers[key];\n    _headers[key] = Array.isArray(val) ? val.filter(Boolean).join(\", \") : val;\n  }\n  return _headers;\n}\nconst getHeaders = getRequestHeaders;\nfunction getRequestHeader(event, name) {\n  const headers = getRequestHeaders(event);\n  const value = headers[name.toLowerCase()];\n  return value;\n}\nconst getHeader = getRequestHeader;\nfunction getRequestHost(event, opts = {}) {\n  if (opts.xForwardedHost) {\n    const xForwardedHost = event.node.req.headers[\"x-forwarded-host\"];\n    if (xForwardedHost) {\n      return xForwardedHost;\n    }\n  }\n  return event.node.req.headers.host || \"localhost\";\n}\nfunction getRequestProtocol(event, opts = {}) {\n  if (opts.xForwardedProto !== false && event.node.req.headers[\"x-forwarded-proto\"] === \"https\") {\n    return \"https\";\n  }\n  return event.node.req.connection.encrypted ? \"https\" : \"http\";\n}\nconst DOUBLE_SLASH_RE = /[/\\\\]{2,}/g;\nfunction getRequestPath(event) {\n  const path = (event.node.req.url || \"/\").replace(DOUBLE_SLASH_RE, \"/\");\n  return path;\n}\nfunction getRequestURL(event, opts = {}) {\n  const host = getRequestHost(event, opts);\n  const protocol = getRequestProtocol(event);\n  const path = getRequestPath(event);\n  return new URL(path, `${protocol}://${host}`);\n}\n\nconst RawBodySymbol = Symbol.for(\"h3RawBody\");\nconst ParsedBodySymbol = Symbol.for(\"h3ParsedBody\");\nconst PayloadMethods$1 = [\"PATCH\", \"POST\", \"PUT\", \"DELETE\"];\nfunction readRawBody(event, encoding = \"utf8\") {\n  assertMethod(event, PayloadMethods$1);\n  const _rawBody = event.node.req[RawBodySymbol] || event.node.req.body;\n  if (_rawBody) {\n    const promise2 = Promise.resolve(_rawBody).then(\n      (_resolved) => Buffer.isBuffer(_resolved) ? _resolved : Buffer.from(_resolved)\n    );\n    return encoding ? promise2.then((buff) => buff.toString(encoding)) : promise2;\n  }\n  if (!Number.parseInt(event.node.req.headers[\"content-length\"] || \"\")) {\n    return Promise.resolve(void 0);\n  }\n  const promise = event.node.req[RawBodySymbol] = new Promise(\n    (resolve, reject) => {\n      const bodyData = [];\n      event.node.req.on(\"error\", (err) => {\n        reject(err);\n      }).on(\"data\", (chunk) => {\n        bodyData.push(chunk);\n      }).on(\"end\", () => {\n        resolve(Buffer.concat(bodyData));\n      });\n    }\n  );\n  const result = encoding ? promise.then((buff) => buff.toString(encoding)) : promise;\n  return result;\n}\nasync function readBody(event) {\n  if (ParsedBodySymbol in event.node.req) {\n    return event.node.req[ParsedBodySymbol];\n  }\n  const body = await readRawBody(event, \"utf8\");\n  if (event.node.req.headers[\"content-type\"] === \"application/x-www-form-urlencoded\") {\n    const form = new URLSearchParams(body);\n    const parsedForm = /* @__PURE__ */ Object.create(null);\n    for (const [key, value] of form.entries()) {\n      if (key in parsedForm) {\n        if (!Array.isArray(parsedForm[key])) {\n          parsedForm[key] = [parsedForm[key]];\n        }\n        parsedForm[key].push(value);\n      } else {\n        parsedForm[key] = value;\n      }\n    }\n    return parsedForm;\n  }\n  const json = destr(body);\n  event.node.req[ParsedBodySymbol] = json;\n  return json;\n}\nasync function readMultipartFormData(event) {\n  const contentType = getRequestHeader(event, \"content-type\");\n  if (!contentType || !contentType.startsWith(\"multipart/form-data\")) {\n    return;\n  }\n  const boundary = contentType.match(/boundary=([^;]*)(;|$)/i)?.[1];\n  if (!boundary) {\n    return;\n  }\n  const body = await readRawBody(event, false);\n  if (!body) {\n    return;\n  }\n  return parse(body, boundary);\n}\n\nfunction handleCacheHeaders(event, opts) {\n  const cacheControls = [\"public\", ...opts.cacheControls || []];\n  let cacheMatched = false;\n  if (opts.maxAge !== void 0) {\n    cacheControls.push(`max-age=${+opts.maxAge}`, `s-maxage=${+opts.maxAge}`);\n  }\n  if (opts.modifiedTime) {\n    const modifiedTime = new Date(opts.modifiedTime);\n    const ifModifiedSince = event.node.req.headers[\"if-modified-since\"];\n    event.node.res.setHeader(\"last-modified\", modifiedTime.toUTCString());\n    if (ifModifiedSince && new Date(ifModifiedSince) >= opts.modifiedTime) {\n      cacheMatched = true;\n    }\n  }\n  if (opts.etag) {\n    event.node.res.setHeader(\"etag\", opts.etag);\n    const ifNonMatch = event.node.req.headers[\"if-none-match\"];\n    if (ifNonMatch === opts.etag) {\n      cacheMatched = true;\n    }\n  }\n  event.node.res.setHeader(\"cache-control\", cacheControls.join(\", \"));\n  if (cacheMatched) {\n    event.node.res.statusCode = 304;\n    event.node.res.end();\n    return true;\n  }\n  return false;\n}\n\nconst MIMES = {\n  html: \"text/html\",\n  json: \"application/json\"\n};\n\nfunction parseCookies(event) {\n  return parse$1(event.node.req.headers.cookie || \"\");\n}\nfunction getCookie(event, name) {\n  return parseCookies(event)[name];\n}\nfunction setCookie(event, name, value, serializeOptions) {\n  const cookieStr = serialize(name, value, {\n    path: \"/\",\n    ...serializeOptions\n  });\n  let setCookies = event.node.res.getHeader(\"set-cookie\");\n  if (!Array.isArray(setCookies)) {\n    setCookies = [setCookies];\n  }\n  setCookies = setCookies.filter((cookieValue) => {\n    return cookieValue && !cookieValue.startsWith(name + \"=\");\n  });\n  event.node.res.setHeader(\"set-cookie\", [...setCookies, cookieStr]);\n}\nfunction deleteCookie(event, name, serializeOptions) {\n  setCookie(event, name, \"\", {\n    ...serializeOptions,\n    maxAge: 0\n  });\n}\nfunction splitCookiesString(cookiesString) {\n  if (typeof cookiesString !== \"string\") {\n    return [];\n  }\n  const cookiesStrings = [];\n  let pos = 0;\n  let start;\n  let ch;\n  let lastComma;\n  let nextStart;\n  let cookiesSeparatorFound;\n  function skipWhitespace() {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  }\n  function notSpecialChar() {\n    ch = cookiesString.charAt(pos);\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  }\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        lastComma = pos;\n        pos += 1;\n        skipWhitespace();\n        nextStart = pos;\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          cookiesSeparatorFound = true;\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.slice(start, lastComma));\n          start = pos;\n        } else {\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.slice(start, cookiesString.length));\n    }\n  }\n  return cookiesStrings;\n}\n\nconst DISALLOWED_STATUS_CHARS = /[^\\u0009\\u0020-\\u007E]/g;\nfunction sanitizeStatusMessage(statusMessage = \"\") {\n  return statusMessage.replace(DISALLOWED_STATUS_CHARS, \"\");\n}\nfunction sanitizeStatusCode(statusCode, defaultStatusCode = 200) {\n  if (!statusCode) {\n    return defaultStatusCode;\n  }\n  if (typeof statusCode === \"string\") {\n    statusCode = Number.parseInt(statusCode, 10);\n  }\n  if (statusCode < 100 || statusCode > 999) {\n    return defaultStatusCode;\n  }\n  return statusCode;\n}\n\nconst PayloadMethods = /* @__PURE__ */ new Set([\"PATCH\", \"POST\", \"PUT\", \"DELETE\"]);\nconst ignoredHeaders = /* @__PURE__ */ new Set([\n  \"transfer-encoding\",\n  \"connection\",\n  \"keep-alive\",\n  \"upgrade\",\n  \"expect\",\n  \"host\"\n]);\nasync function proxyRequest(event, target, opts = {}) {\n  const method = getMethod(event);\n  let body;\n  if (PayloadMethods.has(method)) {\n    body = await readRawBody(event).catch(() => void 0);\n  }\n  const headers = getProxyRequestHeaders(event);\n  if (opts.fetchOptions?.headers) {\n    Object.assign(headers, opts.fetchOptions.headers);\n  }\n  if (opts.headers) {\n    Object.assign(headers, opts.headers);\n  }\n  return sendProxy(event, target, {\n    ...opts,\n    fetchOptions: {\n      headers,\n      method,\n      body,\n      ...opts.fetchOptions\n    }\n  });\n}\nasync function sendProxy(event, target, opts = {}) {\n  const response = await _getFetch(opts.fetch)(target, {\n    headers: opts.headers,\n    ...opts.fetchOptions\n  });\n  event.node.res.statusCode = sanitizeStatusCode(\n    response.status,\n    event.node.res.statusCode\n  );\n  event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);\n  for (const [key, value] of response.headers.entries()) {\n    if (key === \"content-encoding\") {\n      continue;\n    }\n    if (key === \"content-length\") {\n      continue;\n    }\n    if (key === \"set-cookie\") {\n      const cookies = splitCookiesString(value).map((cookie) => {\n        if (opts.cookieDomainRewrite) {\n          cookie = rewriteCookieProperty(\n            cookie,\n            opts.cookieDomainRewrite,\n            \"domain\"\n          );\n        }\n        if (opts.cookiePathRewrite) {\n          cookie = rewriteCookieProperty(\n            cookie,\n            opts.cookiePathRewrite,\n            \"path\"\n          );\n        }\n        return cookie;\n      });\n      event.node.res.setHeader(\"set-cookie\", cookies);\n      continue;\n    }\n    event.node.res.setHeader(key, value);\n  }\n  if (response._data !== void 0) {\n    return response._data;\n  }\n  if (opts.sendStream === false) {\n    const data = new Uint8Array(await response.arrayBuffer());\n    return event.node.res.end(data);\n  }\n  for await (const chunk of response.body) {\n    event.node.res.write(chunk);\n  }\n  return event.node.res.end();\n}\nfunction getProxyRequestHeaders(event) {\n  const headers = /* @__PURE__ */ Object.create(null);\n  const reqHeaders = getRequestHeaders(event);\n  for (const name in reqHeaders) {\n    if (!ignoredHeaders.has(name)) {\n      headers[name] = reqHeaders[name];\n    }\n  }\n  return headers;\n}\nfunction fetchWithEvent(event, req, init, options) {\n  return _getFetch(options?.fetch)(req, {\n    ...init,\n    context: init?.context || event.context,\n    headers: {\n      ...getProxyRequestHeaders(event),\n      ...init?.headers\n    }\n  });\n}\nfunction _getFetch(_fetch) {\n  if (_fetch) {\n    return _fetch;\n  }\n  if (globalThis.fetch) {\n    return globalThis.fetch;\n  }\n  throw new Error(\n    \"fetch is not available. Try importing `node-fetch-native/polyfill` for Node.js.\"\n  );\n}\nfunction rewriteCookieProperty(header, map, property) {\n  const _map = typeof map === \"string\" ? { \"*\": map } : map;\n  return header.replace(\n    new RegExp(`(;\\\\s*${property}=)([^;]+)`, \"gi\"),\n    (match, prefix, previousValue) => {\n      let newValue;\n      if (previousValue in _map) {\n        newValue = _map[previousValue];\n      } else if (\"*\" in _map) {\n        newValue = _map[\"*\"];\n      } else {\n        return match;\n      }\n      return newValue ? prefix + newValue : \"\";\n    }\n  );\n}\n\nconst defer = typeof setImmediate !== \"undefined\" ? setImmediate : (fn) => fn();\nfunction send(event, data, type) {\n  if (type) {\n    defaultContentType(event, type);\n  }\n  return new Promise((resolve) => {\n    defer(() => {\n      event.node.res.end(data);\n      resolve();\n    });\n  });\n}\nfunction sendNoContent(event, code = 204) {\n  event.node.res.statusCode = sanitizeStatusCode(code, 204);\n  if (event.node.res.statusCode === 204) {\n    event.node.res.removeHeader(\"content-length\");\n  }\n  event.node.res.end();\n}\nfunction setResponseStatus(event, code, text) {\n  if (code) {\n    event.node.res.statusCode = sanitizeStatusCode(\n      code,\n      event.node.res.statusCode\n    );\n  }\n  if (text) {\n    event.node.res.statusMessage = sanitizeStatusMessage(text);\n  }\n}\nfunction getResponseStatus(event) {\n  return event.node.res.statusCode;\n}\nfunction getResponseStatusText(event) {\n  return event.node.res.statusMessage;\n}\nfunction defaultContentType(event, type) {\n  if (type && !event.node.res.getHeader(\"content-type\")) {\n    event.node.res.setHeader(\"content-type\", type);\n  }\n}\nfunction sendRedirect(event, location, code = 302) {\n  event.node.res.statusCode = sanitizeStatusCode(\n    code,\n    event.node.res.statusCode\n  );\n  event.node.res.setHeader(\"location\", location);\n  const encodedLoc = location.replace(/\"/g, \"%22\");\n  const html = `<!DOCTYPE html><html><head><meta http-equiv=\"refresh\" content=\"0; url=${encodedLoc}\"></head></html>`;\n  return send(event, html, MIMES.html);\n}\nfunction getResponseHeaders(event) {\n  return event.node.res.getHeaders();\n}\nfunction getResponseHeader(event, name) {\n  return event.node.res.getHeader(name);\n}\nfunction setResponseHeaders(event, headers) {\n  for (const [name, value] of Object.entries(headers)) {\n    event.node.res.setHeader(name, value);\n  }\n}\nconst setHeaders = setResponseHeaders;\nfunction setResponseHeader(event, name, value) {\n  event.node.res.setHeader(name, value);\n}\nconst setHeader = setResponseHeader;\nfunction appendResponseHeaders(event, headers) {\n  for (const [name, value] of Object.entries(headers)) {\n    appendResponseHeader(event, name, value);\n  }\n}\nconst appendHeaders = appendResponseHeaders;\nfunction appendResponseHeader(event, name, value) {\n  let current = event.node.res.getHeader(name);\n  if (!current) {\n    event.node.res.setHeader(name, value);\n    return;\n  }\n  if (!Array.isArray(current)) {\n    current = [current.toString()];\n  }\n  event.node.res.setHeader(name, [...current, value]);\n}\nconst appendHeader = appendResponseHeader;\nfunction isStream(data) {\n  return data && typeof data === \"object\" && typeof data.pipe === \"function\" && typeof data.on === \"function\";\n}\nfunction sendStream(event, data) {\n  return new Promise((resolve, reject) => {\n    data.pipe(event.node.res);\n    data.on(\"end\", () => resolve());\n    data.on(\"error\", (error) => reject(createError(error)));\n  });\n}\nconst noop = () => {\n};\nfunction writeEarlyHints(event, hints, cb = noop) {\n  if (!event.node.res.socket) {\n    cb();\n    return;\n  }\n  if (typeof hints === \"string\" || Array.isArray(hints)) {\n    hints = { link: hints };\n  }\n  if (hints.link) {\n    hints.link = Array.isArray(hints.link) ? hints.link : hints.link.split(\",\");\n  }\n  const headers = Object.entries(hints).map(\n    (e) => [e[0].toLowerCase(), e[1]]\n  );\n  if (headers.length === 0) {\n    cb();\n    return;\n  }\n  let hint = \"HTTP/1.1 103 Early Hints\";\n  if (hints.link) {\n    hint += `\\r\nLink: ${hints.link.join(\", \")}`;\n  }\n  for (const [header, value] of headers) {\n    if (header === \"link\") {\n      continue;\n    }\n    hint += `\\r\n${header}: ${value}`;\n  }\n  if (event.node.res.socket) {\n    event.node.res.socket.write(\n      `${hint}\\r\n\\r\n`,\n      \"utf8\",\n      cb\n    );\n  } else {\n    cb();\n  }\n}\n\nconst DEFAULT_NAME = \"h3\";\nconst DEFAULT_COOKIE = {\n  path: \"/\",\n  secure: true,\n  httpOnly: true\n};\nasync function useSession(event, config) {\n  const sessionName = config.name || DEFAULT_NAME;\n  await getSession(event, config);\n  const sessionManager = {\n    get id() {\n      return event.context.sessions?.[sessionName]?.id;\n    },\n    get data() {\n      return event.context.sessions?.[sessionName]?.data || {};\n    },\n    update: async (update) => {\n      await updateSession(event, config, update);\n      return sessionManager;\n    },\n    clear: async () => {\n      await clearSession(event, config);\n      return sessionManager;\n    }\n  };\n  return sessionManager;\n}\nasync function getSession(event, config) {\n  const sessionName = config.name || DEFAULT_NAME;\n  if (!event.context.sessions) {\n    event.context.sessions = /* @__PURE__ */ Object.create(null);\n  }\n  if (event.context.sessions[sessionName]) {\n    return event.context.sessions[sessionName];\n  }\n  const session = {\n    id: \"\",\n    createdAt: 0,\n    data: /* @__PURE__ */ Object.create(null)\n  };\n  event.context.sessions[sessionName] = session;\n  let sealedSession;\n  if (config.sessionHeader !== false) {\n    const headerName = typeof config.sessionHeader === \"string\" ? config.sessionHeader.toLowerCase() : `x-${sessionName.toLowerCase()}-session`;\n    const headerValue = event.node.req.headers[headerName];\n    if (typeof headerValue === \"string\") {\n      sealedSession = headerValue;\n    }\n  }\n  if (!sealedSession) {\n    sealedSession = getCookie(event, sessionName);\n  }\n  if (sealedSession) {\n    const unsealed = await unsealSession(event, config, sealedSession).catch(\n      () => {\n      }\n    );\n    Object.assign(session, unsealed);\n  }\n  if (!session.id) {\n    session.id = (config.crypto || crypto).randomUUID();\n    session.createdAt = Date.now();\n    await updateSession(event, config);\n  }\n  return session;\n}\nasync function updateSession(event, config, update) {\n  const sessionName = config.name || DEFAULT_NAME;\n  const session = event.context.sessions?.[sessionName] || await getSession(event, config);\n  if (typeof update === \"function\") {\n    update = update(session.data);\n  }\n  if (update) {\n    Object.assign(session.data, update);\n  }\n  if (config.cookie !== false) {\n    const sealed = await sealSession(event, config);\n    setCookie(event, sessionName, sealed, {\n      ...DEFAULT_COOKIE,\n      expires: config.maxAge ? new Date(session.createdAt + config.maxAge * 1e3) : void 0,\n      ...config.cookie\n    });\n  }\n  return session;\n}\nasync function sealSession(event, config) {\n  const sessionName = config.name || DEFAULT_NAME;\n  const session = event.context.sessions?.[sessionName] || await getSession(event, config);\n  const sealed = await seal(config.crypto || crypto, session, config.password, {\n    ...defaults,\n    ttl: config.maxAge ? config.maxAge * 1e3 : 0,\n    ...config.seal\n  });\n  return sealed;\n}\nasync function unsealSession(_event, config, sealed) {\n  const unsealed = await unseal(\n    config.crypto || crypto,\n    sealed,\n    config.password,\n    {\n      ...defaults,\n      ttl: config.maxAge ? config.maxAge * 1e3 : 0,\n      ...config.seal\n    }\n  );\n  if (config.maxAge) {\n    const age = Date.now() - (unsealed.createdAt || Number.NEGATIVE_INFINITY);\n    if (age > config.maxAge * 1e3) {\n      throw new Error(\"Session expired!\");\n    }\n  }\n  return unsealed;\n}\nasync function clearSession(event, config) {\n  const sessionName = config.name || DEFAULT_NAME;\n  if (event.context.sessions?.[sessionName]) {\n    delete event.context.sessions[sessionName];\n  }\n  await setCookie(event, sessionName, \"\", {\n    ...DEFAULT_COOKIE,\n    ...config.cookie\n  });\n}\n\nfunction resolveCorsOptions(options = {}) {\n  const defaultOptions = {\n    origin: \"*\",\n    methods: \"*\",\n    allowHeaders: \"*\",\n    exposeHeaders: \"*\",\n    credentials: false,\n    maxAge: false,\n    preflight: {\n      statusCode: 204\n    }\n  };\n  return defu(options, defaultOptions);\n}\nfunction isPreflightRequest(event) {\n  const method = getMethod(event);\n  const origin = getRequestHeader(event, \"origin\");\n  const accessControlRequestMethod = getRequestHeader(\n    event,\n    \"access-control-request-method\"\n  );\n  return method === \"OPTIONS\" && !!origin && !!accessControlRequestMethod;\n}\nfunction isCorsOriginAllowed(origin, options) {\n  const { origin: originOption } = options;\n  if (!origin || !originOption || originOption === \"*\" || originOption === \"null\") {\n    return true;\n  }\n  if (Array.isArray(originOption)) {\n    return originOption.some((_origin) => {\n      if (_origin instanceof RegExp) {\n        return _origin.test(origin);\n      }\n      return origin === _origin;\n    });\n  }\n  return originOption(origin);\n}\nfunction createOriginHeaders(event, options) {\n  const { origin: originOption } = options;\n  const origin = getRequestHeader(event, \"origin\");\n  if (!origin || !originOption || originOption === \"*\") {\n    return { \"access-control-allow-origin\": \"*\" };\n  }\n  if (typeof originOption === \"string\") {\n    return { \"access-control-allow-origin\": originOption, vary: \"origin\" };\n  }\n  return isCorsOriginAllowed(origin, options) ? { \"access-control-allow-origin\": origin, vary: \"origin\" } : {};\n}\nfunction createMethodsHeaders(options) {\n  const { methods } = options;\n  if (!methods) {\n    return {};\n  }\n  if (methods === \"*\") {\n    return { \"access-control-allow-methods\": \"*\" };\n  }\n  return methods.length > 0 ? { \"access-control-allow-methods\": methods.join(\",\") } : {};\n}\nfunction createCredentialsHeaders(options) {\n  const { credentials } = options;\n  if (credentials) {\n    return { \"access-control-allow-credentials\": \"true\" };\n  }\n  return {};\n}\nfunction createAllowHeaderHeaders(event, options) {\n  const { allowHeaders } = options;\n  if (!allowHeaders || allowHeaders === \"*\" || allowHeaders.length === 0) {\n    const header = getRequestHeader(event, \"access-control-request-headers\");\n    return header ? {\n      \"access-control-allow-headers\": header,\n      vary: \"access-control-request-headers\"\n    } : {};\n  }\n  return {\n    \"access-control-allow-headers\": allowHeaders.join(\",\"),\n    vary: \"access-control-request-headers\"\n  };\n}\nfunction createExposeHeaders(options) {\n  const { exposeHeaders } = options;\n  if (!exposeHeaders) {\n    return {};\n  }\n  if (exposeHeaders === \"*\") {\n    return { \"access-control-expose-headers\": exposeHeaders };\n  }\n  return { \"access-control-expose-headers\": exposeHeaders.join(\",\") };\n}\nfunction appendCorsPreflightHeaders(event, options) {\n  appendHeaders(event, createOriginHeaders(event, options));\n  appendHeaders(event, createCredentialsHeaders(options));\n  appendHeaders(event, createExposeHeaders(options));\n  appendHeaders(event, createMethodsHeaders(options));\n  appendHeaders(event, createAllowHeaderHeaders(event, options));\n}\nfunction appendCorsHeaders(event, options) {\n  appendHeaders(event, createOriginHeaders(event, options));\n  appendHeaders(event, createCredentialsHeaders(options));\n  appendHeaders(event, createExposeHeaders(options));\n}\n\nfunction handleCors(event, options) {\n  const _options = resolveCorsOptions(options);\n  if (isPreflightRequest(event)) {\n    appendCorsPreflightHeaders(event, options);\n    sendNoContent(event, _options.preflight.statusCode);\n    return true;\n  }\n  appendCorsHeaders(event, options);\n  return false;\n}\n\nclass H3Headers {\n  constructor(init) {\n    if (!init) {\n      this._headers = {};\n    } else if (Array.isArray(init)) {\n      this._headers = Object.fromEntries(\n        init.map(([key, value]) => [key.toLowerCase(), value])\n      );\n    } else if (init && \"append\" in init) {\n      this._headers = Object.fromEntries(init.entries());\n    } else {\n      this._headers = Object.fromEntries(\n        Object.entries(init).map(([key, value]) => [key.toLowerCase(), value])\n      );\n    }\n  }\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  entries() {\n    throw Object.entries(this._headers)[Symbol.iterator]();\n  }\n  keys() {\n    return Object.keys(this._headers)[Symbol.iterator]();\n  }\n  values() {\n    throw Object.values(this._headers)[Symbol.iterator]();\n  }\n  append(name, value) {\n    const _name = name.toLowerCase();\n    this.set(_name, [this.get(_name), value].filter(Boolean).join(\", \"));\n  }\n  delete(name) {\n    delete this._headers[name.toLowerCase()];\n  }\n  get(name) {\n    return this._headers[name.toLowerCase()];\n  }\n  has(name) {\n    return name.toLowerCase() in this._headers;\n  }\n  set(name, value) {\n    this._headers[name.toLowerCase()] = String(value);\n  }\n  forEach(callbackfn) {\n    for (const [key, value] of Object.entries(this._headers)) {\n      callbackfn(value, key, this);\n    }\n  }\n}\n\nclass H3Response {\n  constructor(body = null, init = {}) {\n    // TODO: yet to implement\n    this.body = null;\n    this.type = \"default\";\n    this.bodyUsed = false;\n    this.headers = new H3Headers(init.headers);\n    this.status = init.status ?? 200;\n    this.statusText = init.statusText || \"\";\n    this.redirected = !!init.status && [301, 302, 307, 308].includes(init.status);\n    this._body = body;\n    this.url = \"\";\n    this.ok = this.status < 300 && this.status > 199;\n  }\n  clone() {\n    return new H3Response(this.body, {\n      headers: this.headers,\n      status: this.status,\n      statusText: this.statusText\n    });\n  }\n  arrayBuffer() {\n    return Promise.resolve(this._body);\n  }\n  blob() {\n    return Promise.resolve(this._body);\n  }\n  formData() {\n    return Promise.resolve(this._body);\n  }\n  json() {\n    return Promise.resolve(this._body);\n  }\n  text() {\n    return Promise.resolve(this._body);\n  }\n}\n\nclass H3Event {\n  constructor(req, res) {\n    this[\"__is_event__\"] = true;\n    this.context = {};\n    this.node = { req, res };\n  }\n  get path() {\n    return getRequestPath(this);\n  }\n  /** @deprecated Please use `event.node.req` instead. **/\n  get req() {\n    return this.node.req;\n  }\n  /** @deprecated Please use `event.node.res` instead. **/\n  get res() {\n    return this.node.res;\n  }\n  // Implementation of FetchEvent\n  respondWith(r) {\n    Promise.resolve(r).then((_response) => {\n      if (this.res.writableEnded) {\n        return;\n      }\n      const response = _response instanceof H3Response ? _response : new H3Response(_response);\n      for (const [key, value] of response.headers.entries()) {\n        this.res.setHeader(key, value);\n      }\n      if (response.status) {\n        this.res.statusCode = sanitizeStatusCode(\n          response.status,\n          this.res.statusCode\n        );\n      }\n      if (response.statusText) {\n        this.res.statusMessage = sanitizeStatusMessage(response.statusText);\n      }\n      if (response.redirected) {\n        this.res.setHeader(\"location\", response.url);\n      }\n      if (!response._body) {\n        return this.res.end();\n      }\n      if (typeof response._body === \"string\" || \"buffer\" in response._body || \"byteLength\" in response._body) {\n        return this.res.end(response._body);\n      }\n      if (!response.headers.has(\"content-type\")) {\n        response.headers.set(\"content-type\", MIMES.json);\n      }\n      this.res.end(JSON.stringify(response._body));\n    });\n  }\n}\nfunction isEvent(input) {\n  return \"__is_event__\" in input;\n}\nfunction createEvent(req, res) {\n  return new H3Event(req, res);\n}\n\nfunction defineEventHandler(handler) {\n  handler.__is_handler__ = true;\n  return handler;\n}\nconst eventHandler = defineEventHandler;\nfunction isEventHandler(input) {\n  return \"__is_handler__\" in input;\n}\nfunction toEventHandler(input, _, _route) {\n  if (!isEventHandler(input)) {\n    console.warn(\n      \"[h3] Implicit event handler conversion is deprecated. Use `eventHandler()` or `fromNodeMiddleware()` to define event handlers.\",\n      _route && _route !== \"/\" ? `\n     Route: ${_route}` : \"\",\n      `\n     Handler: ${input}`\n    );\n  }\n  return input;\n}\nfunction dynamicEventHandler(initial) {\n  let current = initial;\n  const wrapper = eventHandler((event) => {\n    if (current) {\n      return current(event);\n    }\n  });\n  wrapper.set = (handler) => {\n    current = handler;\n  };\n  return wrapper;\n}\nfunction defineLazyEventHandler(factory) {\n  let _promise;\n  let _resolved;\n  const resolveHandler = () => {\n    if (_resolved) {\n      return Promise.resolve(_resolved);\n    }\n    if (!_promise) {\n      _promise = Promise.resolve(factory()).then((r) => {\n        const handler = r.default || r;\n        if (typeof handler !== \"function\") {\n          throw new TypeError(\n            \"Invalid lazy handler result. It should be a function:\",\n            handler\n          );\n        }\n        _resolved = toEventHandler(r.default || r);\n        return _resolved;\n      });\n    }\n    return _promise;\n  };\n  return eventHandler((event) => {\n    if (_resolved) {\n      return _resolved(event);\n    }\n    return resolveHandler().then((handler) => handler(event));\n  });\n}\nconst lazyEventHandler = defineLazyEventHandler;\n\nfunction createApp(options = {}) {\n  const stack = [];\n  const handler = createAppEventHandler(stack, options);\n  const app = {\n    // @ts-ignore\n    use: (arg1, arg2, arg3) => use(app, arg1, arg2, arg3),\n    handler,\n    stack,\n    options\n  };\n  return app;\n}\nfunction use(app, arg1, arg2, arg3) {\n  if (Array.isArray(arg1)) {\n    for (const i of arg1) {\n      use(app, i, arg2, arg3);\n    }\n  } else if (Array.isArray(arg2)) {\n    for (const i of arg2) {\n      use(app, arg1, i, arg3);\n    }\n  } else if (typeof arg1 === \"string\") {\n    app.stack.push(\n      normalizeLayer({ ...arg3, route: arg1, handler: arg2 })\n    );\n  } else if (typeof arg1 === \"function\") {\n    app.stack.push(\n      normalizeLayer({ ...arg2, route: \"/\", handler: arg1 })\n    );\n  } else {\n    app.stack.push(normalizeLayer({ ...arg1 }));\n  }\n  return app;\n}\nfunction createAppEventHandler(stack, options) {\n  const spacing = options.debug ? 2 : void 0;\n  return eventHandler(async (event) => {\n    event.node.req.originalUrl = event.node.req.originalUrl || event.node.req.url || \"/\";\n    const reqUrl = event.node.req.url || \"/\";\n    for (const layer of stack) {\n      if (layer.route.length > 1) {\n        if (!reqUrl.startsWith(layer.route)) {\n          continue;\n        }\n        event.node.req.url = reqUrl.slice(layer.route.length) || \"/\";\n      } else {\n        event.node.req.url = reqUrl;\n      }\n      if (layer.match && !layer.match(event.node.req.url, event)) {\n        continue;\n      }\n      const val = await layer.handler(event);\n      if (event.node.res.writableEnded) {\n        return;\n      }\n      const type = typeof val;\n      if (type === \"string\") {\n        return send(event, val, MIMES.html);\n      } else if (isStream(val)) {\n        return sendStream(event, val);\n      } else if (val === null) {\n        event.node.res.statusCode = 204;\n        return send(event);\n      } else if (type === \"object\" || type === \"boolean\" || type === \"number\") {\n        if (val.buffer) {\n          return send(event, val);\n        } else if (val instanceof Error) {\n          throw createError(val);\n        } else {\n          return send(\n            event,\n            JSON.stringify(val, void 0, spacing),\n            MIMES.json\n          );\n        }\n      }\n    }\n    if (!event.node.res.writableEnded) {\n      throw createError({\n        statusCode: 404,\n        statusMessage: `Cannot find any route matching ${event.node.req.url || \"/\"}.`\n      });\n    }\n  });\n}\nfunction normalizeLayer(input) {\n  let handler = input.handler;\n  if (handler.handler) {\n    handler = handler.handler;\n  }\n  if (input.lazy) {\n    handler = lazyEventHandler(handler);\n  } else if (!isEventHandler(handler)) {\n    handler = toEventHandler(handler, void 0, input.route);\n  }\n  return {\n    route: withoutTrailingSlash(input.route),\n    match: input.match,\n    handler\n  };\n}\n\nconst defineNodeListener = (handler) => handler;\nconst defineNodeMiddleware = (middleware) => middleware;\nfunction fromNodeMiddleware(handler) {\n  if (isEventHandler(handler)) {\n    return handler;\n  }\n  if (typeof handler !== \"function\") {\n    throw new TypeError(\n      \"Invalid handler. It should be a function:\",\n      handler\n    );\n  }\n  return eventHandler((event) => {\n    return callNodeListener(\n      handler,\n      event.node.req,\n      event.node.res\n    );\n  });\n}\nfunction toNodeListener(app) {\n  const toNodeHandle = async function(req, res) {\n    const event = createEvent(req, res);\n    try {\n      await app.handler(event);\n    } catch (_error) {\n      const error = createError(_error);\n      if (!isError(_error)) {\n        error.unhandled = true;\n      }\n      if (app.options.onError) {\n        await app.options.onError(error, event);\n      } else {\n        if (error.unhandled || error.fatal) {\n          console.error(\"[h3]\", error.fatal ? \"[fatal]\" : \"[unhandled]\", error);\n        }\n        await sendError(event, error, !!app.options.debug);\n      }\n    }\n  };\n  return toNodeHandle;\n}\nfunction promisifyNodeListener(handler) {\n  return function(req, res) {\n    return callNodeListener(handler, req, res);\n  };\n}\nfunction callNodeListener(handler, req, res) {\n  const isMiddleware = handler.length > 2;\n  return new Promise((resolve, reject) => {\n    const next = (err) => {\n      if (isMiddleware) {\n        res.off(\"close\", next);\n        res.off(\"error\", next);\n      }\n      return err ? reject(createError(err)) : resolve(void 0);\n    };\n    try {\n      const returned = handler(req, res, next);\n      if (isMiddleware && returned === void 0) {\n        res.once(\"close\", next);\n        res.once(\"error\", next);\n      } else {\n        resolve(returned);\n      }\n    } catch (error) {\n      next(error);\n    }\n  });\n}\n\nconst RouterMethods = [\n  \"connect\",\n  \"delete\",\n  \"get\",\n  \"head\",\n  \"options\",\n  \"post\",\n  \"put\",\n  \"trace\",\n  \"patch\"\n];\nfunction createRouter(opts = {}) {\n  const _router = createRouter$1({});\n  const routes = {};\n  const router = {};\n  const addRoute = (path, handler, method) => {\n    let route = routes[path];\n    if (!route) {\n      routes[path] = route = { handlers: {} };\n      _router.insert(path, route);\n    }\n    if (Array.isArray(method)) {\n      for (const m of method) {\n        addRoute(path, handler, m);\n      }\n    } else {\n      route.handlers[method] = toEventHandler(handler, void 0, path);\n    }\n    return router;\n  };\n  router.use = router.add = (path, handler, method) => addRoute(path, handler, method || \"all\");\n  for (const method of RouterMethods) {\n    router[method] = (path, handle) => router.add(path, handle, method);\n  }\n  router.handler = eventHandler((event) => {\n    let path = event.node.req.url || \"/\";\n    const qIndex = path.indexOf(\"?\");\n    if (qIndex !== -1) {\n      path = path.slice(0, Math.max(0, qIndex));\n    }\n    const matched = _router.lookup(path);\n    if (!matched || !matched.handlers) {\n      if (opts.preemptive || opts.preemtive) {\n        throw createError({\n          statusCode: 404,\n          name: \"Not Found\",\n          statusMessage: `Cannot find any route matching ${event.node.req.url || \"/\"}.`\n        });\n      } else {\n        return;\n      }\n    }\n    const method = (event.node.req.method || \"get\").toLowerCase();\n    const handler = matched.handlers[method] || matched.handlers.all;\n    if (!handler) {\n      throw createError({\n        statusCode: 405,\n        name: \"Method Not Allowed\",\n        statusMessage: `Method ${method} is not allowed on this route.`\n      });\n    }\n    const params = matched.params || {};\n    event.context.params = params;\n    return handler(event);\n  });\n  return router;\n}\n\nexport { H3Error, H3Event, H3Headers, H3Response, MIMES, appendCorsHeaders, appendCorsPreflightHeaders, appendHeader, appendHeaders, appendResponseHeader, appendResponseHeaders, assertMethod, callNodeListener, clearSession, createApp, createAppEventHandler, createError, createEvent, createRouter, defaultContentType, defineEventHandler, defineLazyEventHandler, defineNodeListener, defineNodeMiddleware, deleteCookie, dynamicEventHandler, eventHandler, fetchWithEvent, fromNodeMiddleware, getCookie, getHeader, getHeaders, getMethod, getProxyRequestHeaders, getQuery, getRequestHeader, getRequestHeaders, getRequestHost, getRequestPath, getRequestProtocol, getRequestURL, getResponseHeader, getResponseHeaders, getResponseStatus, getResponseStatusText, getRouterParam, getRouterParams, getSession, handleCacheHeaders, handleCors, isCorsOriginAllowed, isError, isEvent, isEventHandler, isMethod, isPreflightRequest, isStream, lazyEventHandler, parseCookies, promisifyNodeListener, proxyRequest, readBody, readMultipartFormData, readRawBody, sanitizeStatusCode, sanitizeStatusMessage, sealSession, send, sendError, sendNoContent, sendProxy, sendRedirect, sendStream, setCookie, setHeader, setHeaders, setResponseHeader, setResponseHeaders, setResponseStatus, splitCookiesString, toEventHandler, toNodeListener, unsealSession, updateSession, use, useBase, useSession, writeEarlyHints };\n","import { createError as _createError } from \"h3\";\nimport { toRef } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nexport const useError = () => toRef(useNuxtApp().payload, \"error\");\nexport const showError = (_err) => {\n  const err = createError(_err);\n  try {\n    const nuxtApp = useNuxtApp();\n    nuxtApp.callHook(\"app:error\", err);\n    const error = useError();\n    error.value = error.value || err;\n  } catch {\n    throw err;\n  }\n  return err;\n};\nexport const clearError = async (options = {}) => {\n  const nuxtApp = useNuxtApp();\n  const error = useError();\n  nuxtApp.callHook(\"app:error:cleared\", options);\n  if (options.redirect) {\n    await nuxtApp.$router.replace(options.redirect);\n  }\n  error.value = null;\n};\nexport const isNuxtError = (err) => !!(err && typeof err === \"object\" && \"__nuxt_error\" in err);\nexport const createError = (err) => {\n  const _err = _createError(err);\n  _err.__nuxt_error = true;\n  return _err;\n};\n","import { isRef, toRef } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nexport function useState(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  const [_key, init] = args;\n  if (!_key || typeof _key !== \"string\") {\n    throw new TypeError(\"[nuxt] [useState] key must be a string: \" + _key);\n  }\n  if (init !== void 0 && typeof init !== \"function\") {\n    throw new Error(\"[nuxt] [useState] init must be a function: \" + init);\n  }\n  const key = \"$s\" + _key;\n  const nuxt = useNuxtApp();\n  const state = toRef(nuxt.payload.state, key);\n  if (state.value === void 0 && init) {\n    const initialValue = init();\n    if (isRef(initialValue)) {\n      nuxt.payload.state[key] = initialValue;\n      return initialValue;\n    }\n    state.value = initialValue;\n  }\n  return state;\n}\n","import { getCurrentInstance, inject, onUnmounted } from \"vue\";\nimport { sendRedirect } from \"h3\";\nimport { hasProtocol, joinURL, parseURL } from \"ufo\";\nimport { useNuxtApp, useRuntimeConfig } from \"../nuxt.mjs\";\nimport { createError } from \"./error.mjs\";\nimport { useState } from \"./state.mjs\";\nexport const useRouter = () => {\n  return useNuxtApp()?.$router;\n};\nexport const useRoute = () => {\n  if (getCurrentInstance()) {\n    return inject(\"_route\", useNuxtApp()._route);\n  }\n  return useNuxtApp()._route;\n};\nexport const onBeforeRouteLeave = (guard) => {\n  const unsubscribe = useRouter().beforeEach((to, from, next) => {\n    if (to === from) {\n      return;\n    }\n    return guard(to, from, next);\n  });\n  onUnmounted(unsubscribe);\n};\nexport const onBeforeRouteUpdate = (guard) => {\n  const unsubscribe = useRouter().beforeEach(guard);\n  onUnmounted(unsubscribe);\n};\nexport const defineNuxtRouteMiddleware = (middleware) => middleware;\nexport const addRouteMiddleware = (name, middleware, options = {}) => {\n  const nuxtApp = useNuxtApp();\n  if (options.global || typeof name === \"function\") {\n    nuxtApp._middleware.global.push(typeof name === \"function\" ? name : middleware);\n  } else {\n    nuxtApp._middleware.named[name] = middleware;\n  }\n};\nconst isProcessingMiddleware = () => {\n  try {\n    if (useNuxtApp()._processingMiddleware) {\n      return true;\n    }\n  } catch {\n    return true;\n  }\n  return false;\n};\nexport const navigateTo = (to, options) => {\n  if (!to) {\n    to = \"/\";\n  }\n  const toPath = typeof to === \"string\" ? to : to.path || \"/\";\n  const isExternal = hasProtocol(toPath, true);\n  if (isExternal && !options?.external) {\n    throw new Error(\"Navigating to external URL is not allowed by default. Use `nagivateTo (url, { external: true })`.\");\n  }\n  if (isExternal && parseURL(toPath).protocol === \"script:\") {\n    throw new Error(\"Cannot navigate to an URL with script protocol.\");\n  }\n  if (process.client && !isExternal && isProcessingMiddleware()) {\n    return to;\n  }\n  const router = useRouter();\n  if (process.server) {\n    const nuxtApp = useNuxtApp();\n    if (nuxtApp.ssrContext && nuxtApp.ssrContext.event) {\n      const redirectLocation = isExternal ? toPath : joinURL(useRuntimeConfig().app.baseURL, router.resolve(to).fullPath || \"/\");\n      return nuxtApp.callHook(\"app:redirected\").then(() => sendRedirect(nuxtApp.ssrContext.event, redirectLocation, options?.redirectCode || 302));\n    }\n  }\n  if (isExternal) {\n    if (options?.replace) {\n      location.replace(toPath);\n    } else {\n      location.href = toPath;\n    }\n    return Promise.resolve();\n  }\n  return options?.replace ? router.replace(to) : router.push(to);\n};\nexport const abortNavigation = (err) => {\n  if (process.dev && !isProcessingMiddleware()) {\n    throw new Error(\"abortNavigation() is only usable inside a route middleware handler.\");\n  }\n  if (err) {\n    throw createError(err);\n  }\n  return false;\n};\nexport const setPageLayout = (layout) => {\n  if (process.server) {\n    if (process.dev && getCurrentInstance() && useState(\"_layout\").value !== layout) {\n      console.warn(\"[warn] [nuxt] `setPageLayout` should not be called to change the layout on the server within a component as this will cause hydration errors.\");\n    }\n    useState(\"_layout\").value = layout;\n  }\n  const nuxtApp = useNuxtApp();\n  if (process.dev && nuxtApp.isHydrating && useState(\"_layout\").value !== layout) {\n    console.warn(\"[warn] [nuxt] `setPageLayout` should not be called to change the layout during hydration as this will cause hydration errors.\");\n  }\n  const inMiddleware = isProcessingMiddleware();\n  if (inMiddleware || process.server || nuxtApp.isHydrating) {\n    const unsubscribe = useRouter().beforeResolve((to) => {\n      to.meta.layout = layout;\n      unsubscribe();\n    });\n  }\n  if (!inMiddleware) {\n    useRoute().meta.layout = layout;\n  }\n};\n","const defaults = {\n  ignoreUnknown: false,\n  respectType: false,\n  respectFunctionNames: false,\n  respectFunctionProperties: false,\n  unorderedObjects: true,\n  unorderedArrays: false,\n  unorderedSets: false\n};\nfunction objectHash(object, options = {}) {\n  options = { ...defaults, ...options };\n  const hasher = createHasher(options);\n  hasher.dispatch(object);\n  return hasher.toString();\n}\nfunction createHasher(options) {\n  const buff = [];\n  let context = [];\n  const write = (str) => {\n    buff.push(str);\n  };\n  return {\n    toString() {\n      return buff.join(\"\");\n    },\n    getContext() {\n      return context;\n    },\n    dispatch(value) {\n      if (options.replacer) {\n        value = options.replacer(value);\n      }\n      const type = value === null ? \"null\" : typeof value;\n      return this[\"_\" + type](value);\n    },\n    _object(object) {\n      if (object && typeof object.toJSON === \"function\") {\n        return this._object(object.toJSON());\n      }\n      const pattern = /\\[object (.*)]/i;\n      const objString = Object.prototype.toString.call(object);\n      const _objType = pattern.exec(objString);\n      const objType = _objType ? _objType[1].toLowerCase() : \"unknown:[\" + objString.toLowerCase() + \"]\";\n      let objectNumber = null;\n      if ((objectNumber = context.indexOf(object)) >= 0) {\n        return this.dispatch(\"[CIRCULAR:\" + objectNumber + \"]\");\n      } else {\n        context.push(object);\n      }\n      if (typeof Buffer !== \"undefined\" && Buffer.isBuffer && Buffer.isBuffer(object)) {\n        write(\"buffer:\");\n        return write(object.toString(\"utf8\"));\n      }\n      if (objType !== \"object\" && objType !== \"function\" && objType !== \"asyncfunction\") {\n        if (this[\"_\" + objType]) {\n          this[\"_\" + objType](object);\n        } else if (!options.ignoreUnknown) {\n          this._unkown(object, objType);\n        }\n      } else {\n        let keys = Object.keys(object);\n        if (options.unorderedObjects) {\n          keys = keys.sort();\n        }\n        if (options.respectType !== false && !isNativeFunction(object)) {\n          keys.splice(0, 0, \"prototype\", \"__proto__\", \"letructor\");\n        }\n        if (options.excludeKeys) {\n          keys = keys.filter(function(key) {\n            return !options.excludeKeys(key);\n          });\n        }\n        write(\"object:\" + keys.length + \":\");\n        for (const key of keys) {\n          this.dispatch(key);\n          write(\":\");\n          if (!options.excludeValues) {\n            this.dispatch(object[key]);\n          }\n          write(\",\");\n        }\n      }\n    },\n    _array(arr, unordered) {\n      unordered = typeof unordered !== \"undefined\" ? unordered : options.unorderedArrays !== false;\n      write(\"array:\" + arr.length + \":\");\n      if (!unordered || arr.length <= 1) {\n        for (const entry of arr) {\n          this.dispatch(entry);\n        }\n        return;\n      }\n      const contextAdditions = [];\n      const entries = arr.map((entry) => {\n        const hasher = createHasher(options);\n        hasher.dispatch(entry);\n        contextAdditions.push(hasher.getContext());\n        return hasher.toString();\n      });\n      context = [...context, ...contextAdditions];\n      entries.sort();\n      return this._array(entries, false);\n    },\n    _date(date) {\n      return write(\"date:\" + date.toJSON());\n    },\n    _symbol(sym) {\n      return write(\"symbol:\" + sym.toString());\n    },\n    _unkown(value, type) {\n      write(type);\n      if (!value) {\n        return;\n      }\n      write(\":\");\n      if (value && typeof value.entries === \"function\") {\n        return this._array(\n          Array.from(value.entries()),\n          true\n          /* ordered */\n        );\n      }\n    },\n    _error(err) {\n      return write(\"error:\" + err.toString());\n    },\n    _boolean(bool) {\n      return write(\"bool:\" + bool.toString());\n    },\n    _string(string) {\n      write(\"string:\" + string.length + \":\");\n      write(string.toString());\n    },\n    _function(fn) {\n      write(\"fn:\");\n      if (isNativeFunction(fn)) {\n        this.dispatch(\"[native]\");\n      } else {\n        this.dispatch(fn.toString());\n      }\n      if (options.respectFunctionNames !== false) {\n        this.dispatch(\"function-name:\" + String(fn.name));\n      }\n      if (options.respectFunctionProperties) {\n        this._object(fn);\n      }\n    },\n    _number(number) {\n      return write(\"number:\" + number.toString());\n    },\n    _xml(xml) {\n      return write(\"xml:\" + xml.toString());\n    },\n    _null() {\n      return write(\"Null\");\n    },\n    _undefined() {\n      return write(\"Undefined\");\n    },\n    _regexp(regex) {\n      return write(\"regex:\" + regex.toString());\n    },\n    _uint8array(arr) {\n      write(\"uint8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _uint8clampedarray(arr) {\n      write(\"uint8clampedarray:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _int8array(arr) {\n      write(\"int8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _uint16array(arr) {\n      write(\"uint16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _int16array(arr) {\n      write(\"int16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _uint32array(arr) {\n      write(\"uint32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _int32array(arr) {\n      write(\"int32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _float32array(arr) {\n      write(\"float32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _float64array(arr) {\n      write(\"float64array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _arraybuffer(arr) {\n      write(\"arraybuffer:\");\n      return this.dispatch(new Uint8Array(arr));\n    },\n    _url(url) {\n      return write(\"url:\" + url.toString());\n    },\n    _map(map) {\n      write(\"map:\");\n      const arr = [...map];\n      return this._array(arr, options.unorderedSets !== false);\n    },\n    _set(set) {\n      write(\"set:\");\n      const arr = [...set];\n      return this._array(arr, options.unorderedSets !== false);\n    },\n    _file(file) {\n      write(\"file:\");\n      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);\n    },\n    _blob() {\n      if (options.ignoreUnknown) {\n        return write(\"[blob]\");\n      }\n      throw new Error(\n        'Hashing Blob objects is currently not supported\\nUse \"options.replacer\" or \"options.ignoreUnknown\"\\n'\n      );\n    },\n    _domwindow() {\n      return write(\"domwindow\");\n    },\n    _bigint(number) {\n      return write(\"bigint:\" + number.toString());\n    },\n    /* Node.js standard native objects */\n    _process() {\n      return write(\"process\");\n    },\n    _timer() {\n      return write(\"timer\");\n    },\n    _pipe() {\n      return write(\"pipe\");\n    },\n    _tcp() {\n      return write(\"tcp\");\n    },\n    _udp() {\n      return write(\"udp\");\n    },\n    _tty() {\n      return write(\"tty\");\n    },\n    _statwatcher() {\n      return write(\"statwatcher\");\n    },\n    _securecontext() {\n      return write(\"securecontext\");\n    },\n    _connection() {\n      return write(\"connection\");\n    },\n    _zlib() {\n      return write(\"zlib\");\n    },\n    _context() {\n      return write(\"context\");\n    },\n    _nodescript() {\n      return write(\"nodescript\");\n    },\n    _httpparser() {\n      return write(\"httpparser\");\n    },\n    _dataview() {\n      return write(\"dataview\");\n    },\n    _signal() {\n      return write(\"signal\");\n    },\n    _fsevent() {\n      return write(\"fsevent\");\n    },\n    _tlswrap() {\n      return write(\"tlswrap\");\n    }\n  };\n}\nfunction isNativeFunction(f) {\n  if (typeof f !== \"function\") {\n    return false;\n  }\n  const exp = /^function\\s+\\w*\\s*\\(\\s*\\)\\s*{\\s+\\[native code]\\s+}$/i;\n  return exp.exec(Function.prototype.toString.call(f)) != null;\n}\n\nclass WordArray {\n  constructor(words, sigBytes) {\n    words = this.words = words || [];\n    this.sigBytes = sigBytes !== void 0 ? sigBytes : words.length * 4;\n  }\n  toString(encoder) {\n    return (encoder || Hex).stringify(this);\n  }\n  concat(wordArray) {\n    this.clamp();\n    if (this.sigBytes % 4) {\n      for (let i = 0; i < wordArray.sigBytes; i++) {\n        const thatByte = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n        this.words[this.sigBytes + i >>> 2] |= thatByte << 24 - (this.sigBytes + i) % 4 * 8;\n      }\n    } else {\n      for (let j = 0; j < wordArray.sigBytes; j += 4) {\n        this.words[this.sigBytes + j >>> 2] = wordArray.words[j >>> 2];\n      }\n    }\n    this.sigBytes += wordArray.sigBytes;\n    return this;\n  }\n  clamp() {\n    this.words[this.sigBytes >>> 2] &= 4294967295 << 32 - this.sigBytes % 4 * 8;\n    this.words.length = Math.ceil(this.sigBytes / 4);\n  }\n  clone() {\n    return new WordArray([...this.words]);\n  }\n}\nconst Hex = {\n  stringify(wordArray) {\n    const hexChars = [];\n    for (let i = 0; i < wordArray.sigBytes; i++) {\n      const bite = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      hexChars.push((bite >>> 4).toString(16), (bite & 15).toString(16));\n    }\n    return hexChars.join(\"\");\n  }\n};\nconst Base64 = {\n  stringify(wordArray) {\n    const keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const base64Chars = [];\n    for (let i = 0; i < wordArray.sigBytes; i += 3) {\n      const byte1 = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      const byte2 = wordArray.words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;\n      const byte3 = wordArray.words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;\n      const triplet = byte1 << 16 | byte2 << 8 | byte3;\n      for (let j = 0; j < 4 && i * 8 + j * 6 < wordArray.sigBytes * 8; j++) {\n        base64Chars.push(keyStr.charAt(triplet >>> 6 * (3 - j) & 63));\n      }\n    }\n    return base64Chars.join(\"\");\n  }\n};\nconst Latin1 = {\n  parse(latin1Str) {\n    const latin1StrLength = latin1Str.length;\n    const words = [];\n    for (let i = 0; i < latin1StrLength; i++) {\n      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;\n    }\n    return new WordArray(words, latin1StrLength);\n  }\n};\nconst Utf8 = {\n  parse(utf8Str) {\n    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n  }\n};\nclass BufferedBlockAlgorithm {\n  constructor() {\n    this._minBufferSize = 0;\n    this.blockSize = 512 / 32;\n    this.reset();\n  }\n  reset() {\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n  }\n  _append(data) {\n    if (typeof data === \"string\") {\n      data = Utf8.parse(data);\n    }\n    this._data.concat(data);\n    this._nDataBytes += data.sigBytes;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _doProcessBlock(_dataWords, _offset) {\n  }\n  _process(doFlush) {\n    let processedWords;\n    let nBlocksReady = this._data.sigBytes / (this.blockSize * 4);\n    if (doFlush) {\n      nBlocksReady = Math.ceil(nBlocksReady);\n    } else {\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n    }\n    const nWordsReady = nBlocksReady * this.blockSize;\n    const nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);\n    if (nWordsReady) {\n      for (let offset = 0; offset < nWordsReady; offset += this.blockSize) {\n        this._doProcessBlock(this._data.words, offset);\n      }\n      processedWords = this._data.words.splice(0, nWordsReady);\n      this._data.sigBytes -= nBytesReady;\n    }\n    return new WordArray(processedWords, nBytesReady);\n  }\n}\nclass Hasher extends BufferedBlockAlgorithm {\n  update(messageUpdate) {\n    this._append(messageUpdate);\n    this._process();\n    return this;\n  }\n  finalize(messageUpdate) {\n    if (messageUpdate) {\n      this._append(messageUpdate);\n    }\n  }\n}\n\nconst H = [\n  1779033703,\n  -1150833019,\n  1013904242,\n  -1521486534,\n  1359893119,\n  -1694144372,\n  528734635,\n  1541459225\n];\nconst K = [\n  1116352408,\n  1899447441,\n  -1245643825,\n  -373957723,\n  961987163,\n  1508970993,\n  -1841331548,\n  -1424204075,\n  -670586216,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  -2132889090,\n  -1680079193,\n  -1046744716,\n  -459576895,\n  -272742522,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  -1740746414,\n  -1473132947,\n  -1341970488,\n  -1084653625,\n  -958395405,\n  -710438585,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  -2117940946,\n  -1838011259,\n  -1564481375,\n  -1474664885,\n  -1035236496,\n  -949202525,\n  -778901479,\n  -694614492,\n  -200395387,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  -2067236844,\n  -1933114872,\n  -1866530822,\n  -1538233109,\n  -1090935817,\n  -965641998\n];\nconst W = [];\nclass SHA256 extends Hasher {\n  constructor() {\n    super();\n    this.reset();\n  }\n  reset() {\n    super.reset();\n    this._hash = new WordArray([...H]);\n  }\n  _doProcessBlock(M, offset) {\n    const H2 = this._hash.words;\n    let a = H2[0];\n    let b = H2[1];\n    let c = H2[2];\n    let d = H2[3];\n    let e = H2[4];\n    let f = H2[5];\n    let g = H2[6];\n    let h = H2[7];\n    for (let i = 0; i < 64; i++) {\n      if (i < 16) {\n        W[i] = M[offset + i] | 0;\n      } else {\n        const gamma0x = W[i - 15];\n        const gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;\n        const gamma1x = W[i - 2];\n        const gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;\n        W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n      }\n      const ch = e & f ^ ~e & g;\n      const maj = a & b ^ a & c ^ b & c;\n      const sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);\n      const sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);\n      const t1 = h + sigma1 + ch + K[i] + W[i];\n      const t2 = sigma0 + maj;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t1 | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t1 + t2 | 0;\n    }\n    H2[0] = H2[0] + a | 0;\n    H2[1] = H2[1] + b | 0;\n    H2[2] = H2[2] + c | 0;\n    H2[3] = H2[3] + d | 0;\n    H2[4] = H2[4] + e | 0;\n    H2[5] = H2[5] + f | 0;\n    H2[6] = H2[6] + g | 0;\n    H2[7] = H2[7] + h | 0;\n  }\n  finalize(messageUpdate) {\n    super.finalize(messageUpdate);\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = this._data.sigBytes * 8;\n    this._data.words[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(\n      nBitsTotal / 4294967296\n    );\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n    this._data.sigBytes = this._data.words.length * 4;\n    this._process();\n    return this._hash;\n  }\n}\nfunction sha256(message) {\n  return new SHA256().finalize(message).toString();\n}\nfunction sha256base64(message) {\n  return new SHA256().finalize(message).toString(Base64);\n}\n\nfunction hash(object, options = {}) {\n  const hashed = typeof object === \"string\" ? object : objectHash(object, options);\n  return sha256base64(hashed).slice(0, 10);\n}\n\nfunction murmurHash(key, seed = 0) {\n  if (typeof key === \"string\") {\n    key = createBuffer(key);\n  }\n  let i = 0;\n  let h1 = seed;\n  let k1;\n  let h1b;\n  const remainder = key.length & 3;\n  const bytes = key.length - remainder;\n  const c1 = 3432918353;\n  const c2 = 461845907;\n  while (i < bytes) {\n    k1 = key[i] & 255 | (key[++i] & 255) << 8 | (key[++i] & 255) << 16 | (key[++i] & 255) << 24;\n    ++i;\n    k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;\n    k1 = k1 << 15 | k1 >>> 17;\n    k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;\n    h1 ^= k1;\n    h1 = h1 << 13 | h1 >>> 19;\n    h1b = (h1 & 65535) * 5 + (((h1 >>> 16) * 5 & 65535) << 16) & 4294967295;\n    h1 = (h1b & 65535) + 27492 + (((h1b >>> 16) + 58964 & 65535) << 16);\n  }\n  k1 = 0;\n  switch (remainder) {\n    case 3:\n      k1 ^= (key[i + 2] & 255) << 16;\n      break;\n    case 2:\n      k1 ^= (key[i + 1] & 255) << 8;\n      break;\n    case 1:\n      k1 ^= key[i] & 255;\n      k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;\n      k1 = k1 << 15 | k1 >>> 17;\n      k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;\n      h1 ^= k1;\n  }\n  h1 ^= key.length;\n  h1 ^= h1 >>> 16;\n  h1 = (h1 & 65535) * 2246822507 + (((h1 >>> 16) * 2246822507 & 65535) << 16) & 4294967295;\n  h1 ^= h1 >>> 13;\n  h1 = (h1 & 65535) * 3266489909 + (((h1 >>> 16) * 3266489909 & 65535) << 16) & 4294967295;\n  h1 ^= h1 >>> 16;\n  return h1 >>> 0;\n}\nfunction createBuffer(val) {\n  return new TextEncoder().encode(val);\n}\n\nfunction isEqual(object1, object2, hashOptions = {}) {\n  if (object1 === object2) {\n    return true;\n  }\n  if (objectHash(object1, hashOptions) === objectHash(object2, hashOptions)) {\n    return true;\n  }\n  return false;\n}\n\nfunction diff(obj1, obj2, opts = {}) {\n  const h1 = _toHashedObject(obj1, opts);\n  const h2 = _toHashedObject(obj2, opts);\n  return _diff(h1, h2, opts);\n}\nfunction _diff(h1, h2, opts = {}) {\n  const diffs = [];\n  const allProps = /* @__PURE__ */ new Set([\n    ...Object.keys(h1.props || {}),\n    ...Object.keys(h2.props || {})\n  ]);\n  if (h1.props && h2.props) {\n    for (const prop of allProps) {\n      const p1 = h1.props[prop];\n      const p2 = h2.props[prop];\n      if (p1 && p2) {\n        diffs.push(..._diff(h1.props?.[prop], h2.props?.[prop], opts));\n      } else if (p1 || p2) {\n        diffs.push(\n          new DiffEntry((p2 || p1).key, p1 ? \"removed\" : \"added\", p2, p1)\n        );\n      }\n    }\n  }\n  if (allProps.size === 0 && h1.hash !== h2.hash) {\n    diffs.push(new DiffEntry((h2 || h1).key, \"changed\", h2, h1));\n  }\n  return diffs;\n}\nfunction _toHashedObject(obj, opts, key = \"\") {\n  if (obj && typeof obj !== \"object\") {\n    return new DiffHashedObject(key, obj, objectHash(obj, opts));\n  }\n  const props = {};\n  const hashes = [];\n  for (const _key in obj) {\n    props[_key] = _toHashedObject(\n      obj[_key],\n      opts,\n      key ? `${key}.${_key}` : _key\n    );\n    hashes.push(props[_key].hash);\n  }\n  return new DiffHashedObject(key, obj, `{${hashes.join(\":\")}}`, props);\n}\nclass DiffEntry {\n  // eslint-disable-next-line no-useless-constructor\n  constructor(key, type, newValue, oldValue) {\n    this.key = key;\n    this.type = type;\n    this.newValue = newValue;\n    this.oldValue = oldValue;\n  }\n  toString() {\n    return this.toJSON();\n  }\n  toJSON() {\n    switch (this.type) {\n      case \"added\":\n        return `[+] Added   ${this.key}`;\n      case \"removed\":\n        return `[-] Removed ${this.key}`;\n      case \"changed\":\n        return `[~] Changed ${this.key} from ${this.oldValue.toString()} to ${this.newValue.toString()}`;\n    }\n  }\n}\nclass DiffHashedObject {\n  // eslint-disable-next-line no-useless-constructor\n  constructor(key, value, hash, props) {\n    this.key = key;\n    this.value = value;\n    this.hash = hash;\n    this.props = props;\n  }\n  toString() {\n    if (!this.props) {\n      return JSON.stringify(this.value);\n    } else {\n      return `{${Object.keys(this.props).join(\",\")}}`;\n    }\n  }\n  toJSON() {\n    const k = this.key || \".\";\n    if (this.props) {\n      return `${k}({${Object.keys(this.props).join(\",\")}})`;\n    }\n    return `${k}(${this.value})`;\n  }\n}\n\nexport { diff, hash, isEqual, murmurHash, objectHash, sha256, sha256base64 };\n","const decode = decodeURIComponent;\nconst encode = encodeURIComponent;\nconst pairSplitRegExp = /; */;\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\nfunction parse(str, options) {\n  if (typeof str !== \"string\") {\n    throw new TypeError(\"argument str must be a string\");\n  }\n  let obj = {};\n  let opt = options || {};\n  let pairs = str.split(pairSplitRegExp);\n  let dec = opt.decode || decode;\n  for (let i = 0; i < pairs.length; i++) {\n    let pair = pairs[i];\n    let eq_idx = pair.indexOf(\"=\");\n    if (eq_idx < 0) {\n      continue;\n    }\n    let key = pair.substr(0, eq_idx).trim();\n    let val = pair.substr(++eq_idx, pair.length).trim();\n    if (val[0] == '\"') {\n      val = val.slice(1, -1);\n    }\n    if (obj[key] == void 0) {\n      obj[key] = tryDecode(val, dec);\n    }\n  }\n  return obj;\n}\nfunction serialize(name, value, options) {\n  let opt = options || {};\n  let enc = opt.encode || encode;\n  if (typeof enc !== \"function\") {\n    throw new TypeError(\"option encode is invalid\");\n  }\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError(\"argument name is invalid\");\n  }\n  let encodedValue = enc(value);\n  if (encodedValue && !fieldContentRegExp.test(encodedValue)) {\n    throw new TypeError(\"argument val is invalid\");\n  }\n  let str = name + \"=\" + encodedValue;\n  if (opt.maxAge != null) {\n    let maxAge = opt.maxAge - 0;\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError(\"option maxAge is invalid\");\n    }\n    str += \"; Max-Age=\" + Math.floor(maxAge);\n  }\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError(\"option domain is invalid\");\n    }\n    str += \"; Domain=\" + opt.domain;\n  }\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError(\"option path is invalid\");\n    }\n    str += \"; Path=\" + opt.path;\n  }\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== \"function\") {\n      throw new TypeError(\"option expires is invalid\");\n    }\n    str += \"; Expires=\" + opt.expires.toUTCString();\n  }\n  if (opt.httpOnly) {\n    str += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    str += \"; Secure\";\n  }\n  if (opt.sameSite) {\n    let sameSite = typeof opt.sameSite === \"string\" ? opt.sameSite.toLowerCase() : opt.sameSite;\n    switch (sameSite) {\n      case true:\n        str += \"; SameSite=Strict\";\n        break;\n      case \"lax\":\n        str += \"; SameSite=Lax\";\n        break;\n      case \"strict\":\n        str += \"; SameSite=Strict\";\n        break;\n      case \"none\":\n        str += \"; SameSite=None\";\n        break;\n      default:\n        throw new TypeError(\"option sameSite is invalid\");\n    }\n  }\n  return str;\n}\nfunction tryDecode(str, decode2) {\n  try {\n    return decode2(str);\n  } catch (e) {\n    return str;\n  }\n}\n\nexport { parse, serialize };\n","import { useNuxtApp } from \"../nuxt.mjs\";\nexport function useRequestHeaders(include) {\n  if (process.client) {\n    return {};\n  }\n  const headers = useNuxtApp().ssrContext?.event.node.req.headers ?? {};\n  if (!include) {\n    return headers;\n  }\n  return Object.fromEntries(include.map((key) => key.toLowerCase()).filter((key) => headers[key]).map((key) => [key, headers[key]]));\n}\nexport function useRequestEvent(nuxtApp = useNuxtApp()) {\n  return nuxtApp.ssrContext?.event;\n}\nexport function setResponseStatus(code, message) {\n  const event = process.server && useRequestEvent();\n  if (event) {\n    event.node.res.statusCode = code;\n    if (message) {\n      event.node.res.statusMessage = message;\n    }\n  }\n}\n","import { ref, watch } from \"vue\";\nimport { parse, serialize } from \"cookie-es\";\nimport { appendHeader } from \"h3\";\nimport destr from \"destr\";\nimport { isEqual } from \"ohash\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nimport { useRequestEvent } from \"./ssr.mjs\";\nconst CookieDefaults = {\n  path: \"/\",\n  decode: (val) => destr(decodeURIComponent(val)),\n  encode: (val) => encodeURIComponent(typeof val === \"string\" ? val : JSON.stringify(val))\n};\nexport function useCookie(name, _opts) {\n  const opts = { ...CookieDefaults, ..._opts };\n  const cookies = readRawCookies(opts) || {};\n  const cookie = ref(cookies[name] ?? opts.default?.());\n  if (process.client) {\n    watch(cookie, () => {\n      writeClientCookie(name, cookie.value, opts);\n    });\n  } else if (process.server) {\n    const nuxtApp = useNuxtApp();\n    const writeFinalCookieValue = () => {\n      if (!isEqual(cookie.value, cookies[name])) {\n        writeServerCookie(useRequestEvent(nuxtApp), name, cookie.value, opts);\n      }\n    };\n    const unhook = nuxtApp.hooks.hookOnce(\"app:rendered\", writeFinalCookieValue);\n    nuxtApp.hooks.hookOnce(\"app:redirected\", () => {\n      unhook();\n      return writeFinalCookieValue();\n    });\n  }\n  return cookie;\n}\nfunction readRawCookies(opts = {}) {\n  if (process.server) {\n    return parse(useRequestEvent()?.req.headers.cookie || \"\", opts);\n  } else if (process.client) {\n    return parse(document.cookie, opts);\n  }\n}\nfunction serializeCookie(name, value, opts = {}) {\n  if (value === null || value === void 0) {\n    return serialize(name, value, { ...opts, maxAge: -1 });\n  }\n  return serialize(name, value, opts);\n}\nfunction writeClientCookie(name, value, opts = {}) {\n  if (process.client) {\n    document.cookie = serializeCookie(name, value, opts);\n  }\n}\nfunction writeServerCookie(event, name, value, opts = {}) {\n  if (event) {\n    appendHeader(event, \"Set-Cookie\", serializeCookie(name, value, opts));\n  }\n}\n","import { defineComponent, h, ref, resolveComponent, computed, onMounted, onBeforeUnmount } from \"vue\";\nimport { hasProtocol } from \"ufo\";\nimport { preloadRouteComponents } from \"../composables/preload.mjs\";\nimport { navigateTo, useRouter } from \"../composables/router.mjs\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nconst firstNonUndefined = (...args) => args.find((arg) => arg !== void 0);\nconst DEFAULT_EXTERNAL_REL_ATTRIBUTE = \"noopener noreferrer\";\nconst requestIdleCallback = process.server ? void 0 : globalThis.requestIdleCallback || ((cb) => {\n  const start = Date.now();\n  const idleDeadline = {\n    didTimeout: false,\n    timeRemaining: () => Math.max(0, 50 - (Date.now() - start))\n  };\n  return setTimeout(() => {\n    cb(idleDeadline);\n  }, 1);\n});\nconst cancelIdleCallback = process.server ? null : globalThis.cancelIdleCallback || ((id) => {\n  clearTimeout(id);\n});\nexport function defineNuxtLink(options) {\n  const componentName = options.componentName || \"NuxtLink\";\n  const checkPropConflicts = (props, main, sub) => {\n    if (process.dev && props[main] !== void 0 && props[sub] !== void 0) {\n      console.warn(`[${componentName}] \\`${main}\\` and \\`${sub}\\` cannot be used together. \\`${sub}\\` will be ignored.`);\n    }\n  };\n  return defineComponent({\n    name: componentName,\n    props: {\n      to: {\n        type: [String, Object],\n        default: void 0,\n        required: false\n      },\n      href: {\n        type: [String, Object],\n        default: void 0,\n        required: false\n      },\n      target: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      rel: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      noRel: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      prefetch: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      noPrefetch: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      activeClass: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      exactActiveClass: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      prefetchedClass: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      replace: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      ariaCurrentValue: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      external: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      custom: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      }\n    },\n    setup(props, { slots }) {\n      const router = useRouter();\n      const to = computed(() => {\n        checkPropConflicts(props, \"to\", \"href\");\n        return props.to || props.href || \"\";\n      });\n      const isExternal = computed(() => {\n        if (props.external) {\n          return true;\n        }\n        if (props.target && props.target !== \"_self\") {\n          return true;\n        }\n        if (typeof to.value === \"object\") {\n          return false;\n        }\n        return to.value === \"\" || hasProtocol(to.value, true);\n      });\n      const prefetched = ref(false);\n      const el = process.server ? void 0 : ref(null);\n      if (process.client) {\n        checkPropConflicts(props, \"prefetch\", \"noPrefetch\");\n        const shouldPrefetch = props.prefetch !== false && props.noPrefetch !== true && typeof to.value === \"string\" && props.target !== \"_blank\" && !isSlowConnection();\n        if (shouldPrefetch) {\n          const nuxtApp = useNuxtApp();\n          const observer = useObserver();\n          let idleId;\n          let unobserve = null;\n          onMounted(() => {\n            idleId = requestIdleCallback(() => {\n              if (el?.value?.tagName) {\n                unobserve = observer.observe(el.value, async () => {\n                  unobserve?.();\n                  unobserve = null;\n                  await Promise.all([\n                    nuxtApp.hooks.callHook(\"link:prefetch\", to.value).catch(() => {\n                    }),\n                    !isExternal.value && preloadRouteComponents(to.value, router).catch(() => {\n                    })\n                  ]);\n                  prefetched.value = true;\n                });\n              }\n            });\n          });\n          onBeforeUnmount(() => {\n            if (idleId) {\n              cancelIdleCallback(idleId);\n            }\n            unobserve?.();\n            unobserve = null;\n          });\n        }\n      }\n      return () => {\n        if (!isExternal.value) {\n          return h(\n            resolveComponent(\"RouterLink\"),\n            {\n              ref: process.server ? void 0 : (ref2) => {\n                el.value = ref2?.$el;\n              },\n              to: to.value,\n              ...prefetched.value && !props.custom ? { class: props.prefetchedClass || options.prefetchedClass } : {},\n              activeClass: props.activeClass || options.activeClass,\n              exactActiveClass: props.exactActiveClass || options.exactActiveClass,\n              replace: props.replace,\n              ariaCurrentValue: props.ariaCurrentValue,\n              custom: props.custom\n            },\n            slots.default\n          );\n        }\n        const href = typeof to.value === \"object\" ? router.resolve(to.value)?.href ?? null : to.value || null;\n        const target = props.target || null;\n        checkPropConflicts(props, \"noRel\", \"rel\");\n        const rel = props.noRel ? null : firstNonUndefined(props.rel, options.externalRelAttribute, href ? DEFAULT_EXTERNAL_REL_ATTRIBUTE : \"\") || null;\n        const navigate = () => navigateTo(href, { replace: props.replace });\n        if (props.custom) {\n          if (!slots.default) {\n            return null;\n          }\n          return slots.default({\n            href,\n            navigate,\n            route: router.resolve(href),\n            rel,\n            target,\n            isExternal: isExternal.value,\n            isActive: false,\n            isExactActive: false\n          });\n        }\n        return h(\"a\", { ref: el, href, rel, target }, slots.default?.());\n      };\n    }\n  });\n}\nexport default defineNuxtLink({ componentName: \"NuxtLink\" });\nfunction useObserver() {\n  if (process.server) {\n    return;\n  }\n  const nuxtApp = useNuxtApp();\n  if (nuxtApp._observer) {\n    return nuxtApp._observer;\n  }\n  let observer = null;\n  const callbacks = /* @__PURE__ */ new Map();\n  const observe = (element, callback) => {\n    if (!observer) {\n      observer = new IntersectionObserver((entries) => {\n        for (const entry of entries) {\n          const callback2 = callbacks.get(entry.target);\n          const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n          if (isVisible && callback2) {\n            callback2();\n          }\n        }\n      });\n    }\n    callbacks.set(element, callback);\n    observer.observe(element);\n    return () => {\n      callbacks.delete(element);\n      observer.unobserve(element);\n      if (callbacks.size === 0) {\n        observer.disconnect();\n        observer = null;\n      }\n    };\n  };\n  const _observer = nuxtApp._observer = {\n    observe\n  };\n  return _observer;\n}\nfunction isSlowConnection() {\n  if (process.server) {\n    return;\n  }\n  const cn = navigator.connection;\n  if (cn && (cn.saveData || /2g/.test(cn.effectiveType))) {\n    return true;\n  }\n  return false;\n}\n","\nimport { defuFn } from '/Users/carlesfarpierres/Documents/workspace/app-node-vue/client/node_modules/defu/dist/defu.mjs'\n\nconst inlineConfig = {}\n\n\n\nexport default defuFn(inlineConfig)\n","export * from \"./capi.mjs\";\nexport const Vue2 = void 0;\nexport const isVue2 = false;\nexport const isVue3 = true;\n","/*!\n  * pinia v2.1.3\n  * (c) 2023 Eduardo San Martin Morote\n  * @license MIT\n  */\nimport { hasInjectionContext, inject, toRaw, watch, unref, markRaw, effectScope, ref, isVue2, isRef, isReactive, set, getCurrentScope, onScopeDispose, getCurrentInstance, reactive, toRef, del, nextTick, computed, toRefs } from 'vue-demi';\nimport { setupDevtoolsPlugin } from '@vue/devtools-api';\n\n/**\n * setActivePinia must be called to handle SSR at the top of functions like\n * `fetch`, `setup`, `serverPrefetch` and others\n */\nlet activePinia;\n/**\n * Sets or unsets the active pinia. Used in SSR and internally when calling\n * actions and getters\n *\n * @param pinia - Pinia instance\n */\n// @ts-expect-error: cannot constrain the type of the return\nconst setActivePinia = (pinia) => (activePinia = pinia);\n/**\n * Get the currently active pinia if there is any.\n */\nconst getActivePinia = () => (hasInjectionContext() && inject(piniaSymbol)) || activePinia;\nconst piniaSymbol = ((process.env.NODE_ENV !== 'production') ? Symbol('pinia') : /* istanbul ignore next */ Symbol());\n\nfunction isPlainObject(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\no) {\n    return (o &&\n        typeof o === 'object' &&\n        Object.prototype.toString.call(o) === '[object Object]' &&\n        typeof o.toJSON !== 'function');\n}\n// type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }\n// TODO: can we change these to numbers?\n/**\n * Possible types for SubscriptionCallback\n */\nvar MutationType;\n(function (MutationType) {\n    /**\n     * Direct mutation of the state:\n     *\n     * - `store.name = 'new name'`\n     * - `store.$state.name = 'new name'`\n     * - `store.list.push('new item')`\n     */\n    MutationType[\"direct\"] = \"direct\";\n    /**\n     * Mutated the state with `$patch` and an object\n     *\n     * - `store.$patch({ name: 'newName' })`\n     */\n    MutationType[\"patchObject\"] = \"patch object\";\n    /**\n     * Mutated the state with `$patch` and a function\n     *\n     * - `store.$patch(state => state.name = 'newName')`\n     */\n    MutationType[\"patchFunction\"] = \"patch function\";\n    // maybe reset? for $state = {} and $reset\n})(MutationType || (MutationType = {}));\n\nconst IS_CLIENT = typeof window !== 'undefined';\n/**\n * Should we add the devtools plugins.\n * - only if dev mode or forced through the prod devtools flag\n * - not in test\n * - only if window exists (could change in the future)\n */\nconst USE_DEVTOOLS = ((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test') && IS_CLIENT;\n\n/*\n * FileSaver.js A saveAs() FileSaver implementation.\n *\n * Originally by Eli Grey, adapted as an ESM module by Eduardo San Martin\n * Morote.\n *\n * License : MIT\n */\n// The one and only way of getting global scope in all environments\n// https://stackoverflow.com/q/3277182/1008999\nconst _global = /*#__PURE__*/ (() => typeof window === 'object' && window.window === window\n    ? window\n    : typeof self === 'object' && self.self === self\n        ? self\n        : typeof global === 'object' && global.global === global\n            ? global\n            : typeof globalThis === 'object'\n                ? globalThis\n                : { HTMLElement: null })();\nfunction bom(blob, { autoBom = false } = {}) {\n    // prepend BOM for UTF-8 XML and text/* types (including HTML)\n    // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\n    if (autoBom &&\n        /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\n        return new Blob([String.fromCharCode(0xfeff), blob], { type: blob.type });\n    }\n    return blob;\n}\nfunction download(url, name, opts) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url);\n    xhr.responseType = 'blob';\n    xhr.onload = function () {\n        saveAs(xhr.response, name, opts);\n    };\n    xhr.onerror = function () {\n        console.error('could not download file');\n    };\n    xhr.send();\n}\nfunction corsEnabled(url) {\n    const xhr = new XMLHttpRequest();\n    // use sync to avoid popup blocker\n    xhr.open('HEAD', url, false);\n    try {\n        xhr.send();\n    }\n    catch (e) { }\n    return xhr.status >= 200 && xhr.status <= 299;\n}\n// `a.click()` doesn't work for all browsers (#465)\nfunction click(node) {\n    try {\n        node.dispatchEvent(new MouseEvent('click'));\n    }\n    catch (e) {\n        const evt = document.createEvent('MouseEvents');\n        evt.initMouseEvent('click', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);\n        node.dispatchEvent(evt);\n    }\n}\nconst _navigator = \n typeof navigator === 'object' ? navigator : { userAgent: '' };\n// Detect WebView inside a native macOS app by ruling out all browsers\n// We just need to check for 'Safari' because all other browsers (besides Firefox) include that too\n// https://www.whatismybrowser.com/guides/the-latest-user-agent/macos\nconst isMacOSWebView = /*#__PURE__*/ (() => /Macintosh/.test(_navigator.userAgent) &&\n    /AppleWebKit/.test(_navigator.userAgent) &&\n    !/Safari/.test(_navigator.userAgent))();\nconst saveAs = !IS_CLIENT\n    ? () => { } // noop\n    : // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program\n        typeof HTMLAnchorElement !== 'undefined' &&\n            'download' in HTMLAnchorElement.prototype &&\n            !isMacOSWebView\n            ? downloadSaveAs\n            : // Use msSaveOrOpenBlob as a second approach\n                'msSaveOrOpenBlob' in _navigator\n                    ? msSaveAs\n                    : // Fallback to using FileReader and a popup\n                        fileSaverSaveAs;\nfunction downloadSaveAs(blob, name = 'download', opts) {\n    const a = document.createElement('a');\n    a.download = name;\n    a.rel = 'noopener'; // tabnabbing\n    // TODO: detect chrome extensions & packaged apps\n    // a.target = '_blank'\n    if (typeof blob === 'string') {\n        // Support regular links\n        a.href = blob;\n        if (a.origin !== location.origin) {\n            if (corsEnabled(a.href)) {\n                download(blob, name, opts);\n            }\n            else {\n                a.target = '_blank';\n                click(a);\n            }\n        }\n        else {\n            click(a);\n        }\n    }\n    else {\n        // Support blobs\n        a.href = URL.createObjectURL(blob);\n        setTimeout(function () {\n            URL.revokeObjectURL(a.href);\n        }, 4e4); // 40s\n        setTimeout(function () {\n            click(a);\n        }, 0);\n    }\n}\nfunction msSaveAs(blob, name = 'download', opts) {\n    if (typeof blob === 'string') {\n        if (corsEnabled(blob)) {\n            download(blob, name, opts);\n        }\n        else {\n            const a = document.createElement('a');\n            a.href = blob;\n            a.target = '_blank';\n            setTimeout(function () {\n                click(a);\n            });\n        }\n    }\n    else {\n        // @ts-ignore: works on windows\n        navigator.msSaveOrOpenBlob(bom(blob, opts), name);\n    }\n}\nfunction fileSaverSaveAs(blob, name, opts, popup) {\n    // Open a popup immediately do go around popup blocker\n    // Mostly only available on user interaction and the fileReader is async so...\n    popup = popup || open('', '_blank');\n    if (popup) {\n        popup.document.title = popup.document.body.innerText = 'downloading...';\n    }\n    if (typeof blob === 'string')\n        return download(blob, name, opts);\n    const force = blob.type === 'application/octet-stream';\n    const isSafari = /constructor/i.test(String(_global.HTMLElement)) || 'safari' in _global;\n    const isChromeIOS = /CriOS\\/[\\d]+/.test(navigator.userAgent);\n    if ((isChromeIOS || (force && isSafari) || isMacOSWebView) &&\n        typeof FileReader !== 'undefined') {\n        // Safari doesn't allow downloading of blob URLs\n        const reader = new FileReader();\n        reader.onloadend = function () {\n            let url = reader.result;\n            if (typeof url !== 'string') {\n                popup = null;\n                throw new Error('Wrong reader.result type');\n            }\n            url = isChromeIOS\n                ? url\n                : url.replace(/^data:[^;]*;/, 'data:attachment/file;');\n            if (popup) {\n                popup.location.href = url;\n            }\n            else {\n                location.assign(url);\n            }\n            popup = null; // reverse-tabnabbing #460\n        };\n        reader.readAsDataURL(blob);\n    }\n    else {\n        const url = URL.createObjectURL(blob);\n        if (popup)\n            popup.location.assign(url);\n        else\n            location.href = url;\n        popup = null; // reverse-tabnabbing #460\n        setTimeout(function () {\n            URL.revokeObjectURL(url);\n        }, 4e4); // 40s\n    }\n}\n\n/**\n * Shows a toast or console.log\n *\n * @param message - message to log\n * @param type - different color of the tooltip\n */\nfunction toastMessage(message, type) {\n    const piniaMessage = ' ' + message;\n    if (typeof __VUE_DEVTOOLS_TOAST__ === 'function') {\n        __VUE_DEVTOOLS_TOAST__(piniaMessage, type);\n    }\n    else if (type === 'error') {\n        console.error(piniaMessage);\n    }\n    else if (type === 'warn') {\n        console.warn(piniaMessage);\n    }\n    else {\n        console.log(piniaMessage);\n    }\n}\nfunction isPinia(o) {\n    return '_a' in o && 'install' in o;\n}\n\nfunction checkClipboardAccess() {\n    if (!('clipboard' in navigator)) {\n        toastMessage(`Your browser doesn't support the Clipboard API`, 'error');\n        return true;\n    }\n}\nfunction checkNotFocusedError(error) {\n    if (error instanceof Error &&\n        error.message.toLowerCase().includes('document is not focused')) {\n        toastMessage('You need to activate the \"Emulate a focused page\" setting in the \"Rendering\" panel of devtools.', 'warn');\n        return true;\n    }\n    return false;\n}\nasync function actionGlobalCopyState(pinia) {\n    if (checkClipboardAccess())\n        return;\n    try {\n        await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));\n        toastMessage('Global state copied to clipboard.');\n    }\n    catch (error) {\n        if (checkNotFocusedError(error))\n            return;\n        toastMessage(`Failed to serialize the state. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nasync function actionGlobalPasteState(pinia) {\n    if (checkClipboardAccess())\n        return;\n    try {\n        pinia.state.value = JSON.parse(await navigator.clipboard.readText());\n        toastMessage('Global state pasted from clipboard.');\n    }\n    catch (error) {\n        if (checkNotFocusedError(error))\n            return;\n        toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nasync function actionGlobalSaveState(pinia) {\n    try {\n        saveAs(new Blob([JSON.stringify(pinia.state.value)], {\n            type: 'text/plain;charset=utf-8',\n        }), 'pinia-state.json');\n    }\n    catch (error) {\n        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nlet fileInput;\nfunction getFileOpener() {\n    if (!fileInput) {\n        fileInput = document.createElement('input');\n        fileInput.type = 'file';\n        fileInput.accept = '.json';\n    }\n    function openFile() {\n        return new Promise((resolve, reject) => {\n            fileInput.onchange = async () => {\n                const files = fileInput.files;\n                if (!files)\n                    return resolve(null);\n                const file = files.item(0);\n                if (!file)\n                    return resolve(null);\n                return resolve({ text: await file.text(), file });\n            };\n            // @ts-ignore: TODO: changed from 4.3 to 4.4\n            fileInput.oncancel = () => resolve(null);\n            fileInput.onerror = reject;\n            fileInput.click();\n        });\n    }\n    return openFile;\n}\nasync function actionGlobalOpenStateFile(pinia) {\n    try {\n        const open = await getFileOpener();\n        const result = await open();\n        if (!result)\n            return;\n        const { text, file } = result;\n        pinia.state.value = JSON.parse(text);\n        toastMessage(`Global state imported from \"${file.name}\".`);\n    }\n    catch (error) {\n        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\n\nfunction formatDisplay(display) {\n    return {\n        _custom: {\n            display,\n        },\n    };\n}\nconst PINIA_ROOT_LABEL = ' Pinia (root)';\nconst PINIA_ROOT_ID = '_root';\nfunction formatStoreForInspectorTree(store) {\n    return isPinia(store)\n        ? {\n            id: PINIA_ROOT_ID,\n            label: PINIA_ROOT_LABEL,\n        }\n        : {\n            id: store.$id,\n            label: store.$id,\n        };\n}\nfunction formatStoreForInspectorState(store) {\n    if (isPinia(store)) {\n        const storeNames = Array.from(store._s.keys());\n        const storeMap = store._s;\n        const state = {\n            state: storeNames.map((storeId) => ({\n                editable: true,\n                key: storeId,\n                value: store.state.value[storeId],\n            })),\n            getters: storeNames\n                .filter((id) => storeMap.get(id)._getters)\n                .map((id) => {\n                const store = storeMap.get(id);\n                return {\n                    editable: false,\n                    key: id,\n                    value: store._getters.reduce((getters, key) => {\n                        getters[key] = store[key];\n                        return getters;\n                    }, {}),\n                };\n            }),\n        };\n        return state;\n    }\n    const state = {\n        state: Object.keys(store.$state).map((key) => ({\n            editable: true,\n            key,\n            value: store.$state[key],\n        })),\n    };\n    // avoid adding empty getters\n    if (store._getters && store._getters.length) {\n        state.getters = store._getters.map((getterName) => ({\n            editable: false,\n            key: getterName,\n            value: store[getterName],\n        }));\n    }\n    if (store._customProperties.size) {\n        state.customProperties = Array.from(store._customProperties).map((key) => ({\n            editable: true,\n            key,\n            value: store[key],\n        }));\n    }\n    return state;\n}\nfunction formatEventData(events) {\n    if (!events)\n        return {};\n    if (Array.isArray(events)) {\n        // TODO: handle add and delete for arrays and objects\n        return events.reduce((data, event) => {\n            data.keys.push(event.key);\n            data.operations.push(event.type);\n            data.oldValue[event.key] = event.oldValue;\n            data.newValue[event.key] = event.newValue;\n            return data;\n        }, {\n            oldValue: {},\n            keys: [],\n            operations: [],\n            newValue: {},\n        });\n    }\n    else {\n        return {\n            operation: formatDisplay(events.type),\n            key: formatDisplay(events.key),\n            oldValue: events.oldValue,\n            newValue: events.newValue,\n        };\n    }\n}\nfunction formatMutationType(type) {\n    switch (type) {\n        case MutationType.direct:\n            return 'mutation';\n        case MutationType.patchFunction:\n            return '$patch';\n        case MutationType.patchObject:\n            return '$patch';\n        default:\n            return 'unknown';\n    }\n}\n\n// timeline can be paused when directly changing the state\nlet isTimelineActive = true;\nconst componentStateTypes = [];\nconst MUTATIONS_LAYER_ID = 'pinia:mutations';\nconst INSPECTOR_ID = 'pinia';\nconst { assign: assign$1 } = Object;\n/**\n * Gets the displayed name of a store in devtools\n *\n * @param id - id of the store\n * @returns a formatted string\n */\nconst getStoreType = (id) => ' ' + id;\n/**\n * Add the pinia plugin without any store. Allows displaying a Pinia plugin tab\n * as soon as it is added to the application.\n *\n * @param app - Vue application\n * @param pinia - pinia instance\n */\nfunction registerPiniaDevtools(app, pinia) {\n    setupDevtoolsPlugin({\n        id: 'dev.esm.pinia',\n        label: 'Pinia ',\n        logo: 'https://pinia.vuejs.org/logo.svg',\n        packageName: 'pinia',\n        homepage: 'https://pinia.vuejs.org',\n        componentStateTypes,\n        app,\n    }, (api) => {\n        if (typeof api.now !== 'function') {\n            toastMessage('You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.');\n        }\n        api.addTimelineLayer({\n            id: MUTATIONS_LAYER_ID,\n            label: `Pinia `,\n            color: 0xe5df88,\n        });\n        api.addInspector({\n            id: INSPECTOR_ID,\n            label: 'Pinia ',\n            icon: 'storage',\n            treeFilterPlaceholder: 'Search stores',\n            actions: [\n                {\n                    icon: 'content_copy',\n                    action: () => {\n                        actionGlobalCopyState(pinia);\n                    },\n                    tooltip: 'Serialize and copy the state',\n                },\n                {\n                    icon: 'content_paste',\n                    action: async () => {\n                        await actionGlobalPasteState(pinia);\n                        api.sendInspectorTree(INSPECTOR_ID);\n                        api.sendInspectorState(INSPECTOR_ID);\n                    },\n                    tooltip: 'Replace the state with the content of your clipboard',\n                },\n                {\n                    icon: 'save',\n                    action: () => {\n                        actionGlobalSaveState(pinia);\n                    },\n                    tooltip: 'Save the state as a JSON file',\n                },\n                {\n                    icon: 'folder_open',\n                    action: async () => {\n                        await actionGlobalOpenStateFile(pinia);\n                        api.sendInspectorTree(INSPECTOR_ID);\n                        api.sendInspectorState(INSPECTOR_ID);\n                    },\n                    tooltip: 'Import the state from a JSON file',\n                },\n            ],\n            nodeActions: [\n                {\n                    icon: 'restore',\n                    tooltip: 'Reset the state (with \"$reset\")',\n                    action: (nodeId) => {\n                        const store = pinia._s.get(nodeId);\n                        if (!store) {\n                            toastMessage(`Cannot reset \"${nodeId}\" store because it wasn't found.`, 'warn');\n                        }\n                        else if (typeof store.$reset !== 'function') {\n                            toastMessage(`Cannot reset \"${nodeId}\" store because it doesn't have a \"$reset\" method implemented.`, 'warn');\n                        }\n                        else {\n                            store.$reset();\n                            toastMessage(`Store \"${nodeId}\" reset.`);\n                        }\n                    },\n                },\n            ],\n        });\n        api.on.inspectComponent((payload, ctx) => {\n            const proxy = (payload.componentInstance &&\n                payload.componentInstance.proxy);\n            if (proxy && proxy._pStores) {\n                const piniaStores = payload.componentInstance.proxy._pStores;\n                Object.values(piniaStores).forEach((store) => {\n                    payload.instanceData.state.push({\n                        type: getStoreType(store.$id),\n                        key: 'state',\n                        editable: true,\n                        value: store._isOptionsAPI\n                            ? {\n                                _custom: {\n                                    value: toRaw(store.$state),\n                                    actions: [\n                                        {\n                                            icon: 'restore',\n                                            tooltip: 'Reset the state of this store',\n                                            action: () => store.$reset(),\n                                        },\n                                    ],\n                                },\n                            }\n                            : // NOTE: workaround to unwrap transferred refs\n                                Object.keys(store.$state).reduce((state, key) => {\n                                    state[key] = store.$state[key];\n                                    return state;\n                                }, {}),\n                    });\n                    if (store._getters && store._getters.length) {\n                        payload.instanceData.state.push({\n                            type: getStoreType(store.$id),\n                            key: 'getters',\n                            editable: false,\n                            value: store._getters.reduce((getters, key) => {\n                                try {\n                                    getters[key] = store[key];\n                                }\n                                catch (error) {\n                                    // @ts-expect-error: we just want to show it in devtools\n                                    getters[key] = error;\n                                }\n                                return getters;\n                            }, {}),\n                        });\n                    }\n                });\n            }\n        });\n        api.on.getInspectorTree((payload) => {\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n                let stores = [pinia];\n                stores = stores.concat(Array.from(pinia._s.values()));\n                payload.rootNodes = (payload.filter\n                    ? stores.filter((store) => '$id' in store\n                        ? store.$id\n                            .toLowerCase()\n                            .includes(payload.filter.toLowerCase())\n                        : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase()))\n                    : stores).map(formatStoreForInspectorTree);\n            }\n        });\n        api.on.getInspectorState((payload) => {\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\n                    ? pinia\n                    : pinia._s.get(payload.nodeId);\n                if (!inspectedStore) {\n                    // this could be the selected store restored for a different project\n                    // so it's better not to say anything here\n                    return;\n                }\n                if (inspectedStore) {\n                    payload.state = formatStoreForInspectorState(inspectedStore);\n                }\n            }\n        });\n        api.on.editInspectorState((payload, ctx) => {\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\n                    ? pinia\n                    : pinia._s.get(payload.nodeId);\n                if (!inspectedStore) {\n                    return toastMessage(`store \"${payload.nodeId}\" not found`, 'error');\n                }\n                const { path } = payload;\n                if (!isPinia(inspectedStore)) {\n                    // access only the state\n                    if (path.length !== 1 ||\n                        !inspectedStore._customProperties.has(path[0]) ||\n                        path[0] in inspectedStore.$state) {\n                        path.unshift('$state');\n                    }\n                }\n                else {\n                    // Root access, we can omit the `.value` because the devtools API does it for us\n                    path.unshift('state');\n                }\n                isTimelineActive = false;\n                payload.set(inspectedStore, path, payload.state.value);\n                isTimelineActive = true;\n            }\n        });\n        api.on.editComponentState((payload) => {\n            if (payload.type.startsWith('')) {\n                const storeId = payload.type.replace(/^\\s*/, '');\n                const store = pinia._s.get(storeId);\n                if (!store) {\n                    return toastMessage(`store \"${storeId}\" not found`, 'error');\n                }\n                const { path } = payload;\n                if (path[0] !== 'state') {\n                    return toastMessage(`Invalid path for store \"${storeId}\":\\n${path}\\nOnly state can be modified.`);\n                }\n                // rewrite the first entry to be able to directly set the state as\n                // well as any other path\n                path[0] = '$state';\n                isTimelineActive = false;\n                payload.set(store, path, payload.state.value);\n                isTimelineActive = true;\n            }\n        });\n    });\n}\nfunction addStoreToDevtools(app, store) {\n    if (!componentStateTypes.includes(getStoreType(store.$id))) {\n        componentStateTypes.push(getStoreType(store.$id));\n    }\n    setupDevtoolsPlugin({\n        id: 'dev.esm.pinia',\n        label: 'Pinia ',\n        logo: 'https://pinia.vuejs.org/logo.svg',\n        packageName: 'pinia',\n        homepage: 'https://pinia.vuejs.org',\n        componentStateTypes,\n        app,\n        settings: {\n            logStoreChanges: {\n                label: 'Notify about new/deleted stores',\n                type: 'boolean',\n                defaultValue: true,\n            },\n            // useEmojis: {\n            //   label: 'Use emojis in messages ',\n            //   type: 'boolean',\n            //   defaultValue: true,\n            // },\n        },\n    }, (api) => {\n        // gracefully handle errors\n        const now = typeof api.now === 'function' ? api.now.bind(api) : Date.now;\n        store.$onAction(({ after, onError, name, args }) => {\n            const groupId = runningActionId++;\n            api.addTimelineEvent({\n                layerId: MUTATIONS_LAYER_ID,\n                event: {\n                    time: now(),\n                    title: ' ' + name,\n                    subtitle: 'start',\n                    data: {\n                        store: formatDisplay(store.$id),\n                        action: formatDisplay(name),\n                        args,\n                    },\n                    groupId,\n                },\n            });\n            after((result) => {\n                activeAction = undefined;\n                api.addTimelineEvent({\n                    layerId: MUTATIONS_LAYER_ID,\n                    event: {\n                        time: now(),\n                        title: ' ' + name,\n                        subtitle: 'end',\n                        data: {\n                            store: formatDisplay(store.$id),\n                            action: formatDisplay(name),\n                            args,\n                            result,\n                        },\n                        groupId,\n                    },\n                });\n            });\n            onError((error) => {\n                activeAction = undefined;\n                api.addTimelineEvent({\n                    layerId: MUTATIONS_LAYER_ID,\n                    event: {\n                        time: now(),\n                        logType: 'error',\n                        title: ' ' + name,\n                        subtitle: 'end',\n                        data: {\n                            store: formatDisplay(store.$id),\n                            action: formatDisplay(name),\n                            args,\n                            error,\n                        },\n                        groupId,\n                    },\n                });\n            });\n        }, true);\n        store._customProperties.forEach((name) => {\n            watch(() => unref(store[name]), (newValue, oldValue) => {\n                api.notifyComponentUpdate();\n                api.sendInspectorState(INSPECTOR_ID);\n                if (isTimelineActive) {\n                    api.addTimelineEvent({\n                        layerId: MUTATIONS_LAYER_ID,\n                        event: {\n                            time: now(),\n                            title: 'Change',\n                            subtitle: name,\n                            data: {\n                                newValue,\n                                oldValue,\n                            },\n                            groupId: activeAction,\n                        },\n                    });\n                }\n            }, { deep: true });\n        });\n        store.$subscribe(({ events, type }, state) => {\n            api.notifyComponentUpdate();\n            api.sendInspectorState(INSPECTOR_ID);\n            if (!isTimelineActive)\n                return;\n            // rootStore.state[store.id] = state\n            const eventData = {\n                time: now(),\n                title: formatMutationType(type),\n                data: assign$1({ store: formatDisplay(store.$id) }, formatEventData(events)),\n                groupId: activeAction,\n            };\n            // reset for the next mutation\n            activeAction = undefined;\n            if (type === MutationType.patchFunction) {\n                eventData.subtitle = '';\n            }\n            else if (type === MutationType.patchObject) {\n                eventData.subtitle = '';\n            }\n            else if (events && !Array.isArray(events)) {\n                eventData.subtitle = events.type;\n            }\n            if (events) {\n                eventData.data['rawEvent(s)'] = {\n                    _custom: {\n                        display: 'DebuggerEvent',\n                        type: 'object',\n                        tooltip: 'raw DebuggerEvent[]',\n                        value: events,\n                    },\n                };\n            }\n            api.addTimelineEvent({\n                layerId: MUTATIONS_LAYER_ID,\n                event: eventData,\n            });\n        }, { detached: true, flush: 'sync' });\n        const hotUpdate = store._hotUpdate;\n        store._hotUpdate = markRaw((newStore) => {\n            hotUpdate(newStore);\n            api.addTimelineEvent({\n                layerId: MUTATIONS_LAYER_ID,\n                event: {\n                    time: now(),\n                    title: ' ' + store.$id,\n                    subtitle: 'HMR update',\n                    data: {\n                        store: formatDisplay(store.$id),\n                        info: formatDisplay(`HMR update`),\n                    },\n                },\n            });\n            // update the devtools too\n            api.notifyComponentUpdate();\n            api.sendInspectorTree(INSPECTOR_ID);\n            api.sendInspectorState(INSPECTOR_ID);\n        });\n        const { $dispose } = store;\n        store.$dispose = () => {\n            $dispose();\n            api.notifyComponentUpdate();\n            api.sendInspectorTree(INSPECTOR_ID);\n            api.sendInspectorState(INSPECTOR_ID);\n            api.getSettings().logStoreChanges &&\n                toastMessage(`Disposed \"${store.$id}\" store `);\n        };\n        // trigger an update so it can display new registered stores\n        api.notifyComponentUpdate();\n        api.sendInspectorTree(INSPECTOR_ID);\n        api.sendInspectorState(INSPECTOR_ID);\n        api.getSettings().logStoreChanges &&\n            toastMessage(`\"${store.$id}\" store installed `);\n    });\n}\nlet runningActionId = 0;\nlet activeAction;\n/**\n * Patches a store to enable action grouping in devtools by wrapping the store with a Proxy that is passed as the\n * context of all actions, allowing us to set `runningAction` on each access and effectively associating any state\n * mutation to the action.\n *\n * @param store - store to patch\n * @param actionNames - list of actionst to patch\n */\nfunction patchActionForGrouping(store, actionNames) {\n    // original actions of the store as they are given by pinia. We are going to override them\n    const actions = actionNames.reduce((storeActions, actionName) => {\n        // use toRaw to avoid tracking #541\n        storeActions[actionName] = toRaw(store)[actionName];\n        return storeActions;\n    }, {});\n    for (const actionName in actions) {\n        store[actionName] = function () {\n            // setActivePinia(store._p)\n            // the running action id is incremented in a before action hook\n            const _actionId = runningActionId;\n            const trackedStore = new Proxy(store, {\n                get(...args) {\n                    activeAction = _actionId;\n                    return Reflect.get(...args);\n                },\n                set(...args) {\n                    activeAction = _actionId;\n                    return Reflect.set(...args);\n                },\n            });\n            return actions[actionName].apply(trackedStore, arguments);\n        };\n    }\n}\n/**\n * pinia.use(devtoolsPlugin)\n */\nfunction devtoolsPlugin({ app, store, options }) {\n    // HMR module\n    if (store.$id.startsWith('__hot:')) {\n        return;\n    }\n    // detect option api vs setup api\n    if (options.state) {\n        store._isOptionsAPI = true;\n    }\n    // only wrap actions in option-defined stores as this technique relies on\n    // wrapping the context of the action with a proxy\n    if (typeof options.state === 'function') {\n        patchActionForGrouping(\n        // @ts-expect-error: can cast the store...\n        store, Object.keys(options.actions));\n        const originalHotUpdate = store._hotUpdate;\n        // Upgrade the HMR to also update the new actions\n        toRaw(store)._hotUpdate = function (newStore) {\n            originalHotUpdate.apply(this, arguments);\n            patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions));\n        };\n    }\n    addStoreToDevtools(app, \n    // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?\n    store);\n}\n\n/**\n * Creates a Pinia instance to be used by the application\n */\nfunction createPinia() {\n    const scope = effectScope(true);\n    // NOTE: here we could check the window object for a state and directly set it\n    // if there is anything like it with Vue 3 SSR\n    const state = scope.run(() => ref({}));\n    let _p = [];\n    // plugins added before calling app.use(pinia)\n    let toBeInstalled = [];\n    const pinia = markRaw({\n        install(app) {\n            // this allows calling useStore() outside of a component setup after\n            // installing pinia's plugin\n            setActivePinia(pinia);\n            if (!isVue2) {\n                pinia._a = app;\n                app.provide(piniaSymbol, pinia);\n                app.config.globalProperties.$pinia = pinia;\n                /* istanbul ignore else */\n                if (USE_DEVTOOLS) {\n                    registerPiniaDevtools(app, pinia);\n                }\n                toBeInstalled.forEach((plugin) => _p.push(plugin));\n                toBeInstalled = [];\n            }\n        },\n        use(plugin) {\n            if (!this._a && !isVue2) {\n                toBeInstalled.push(plugin);\n            }\n            else {\n                _p.push(plugin);\n            }\n            return this;\n        },\n        _p,\n        // it's actually undefined here\n        // @ts-expect-error\n        _a: null,\n        _e: scope,\n        _s: new Map(),\n        state,\n    });\n    // pinia devtools rely on dev only features so they cannot be forced unless\n    // the dev build of Vue is used. Avoid old browsers like IE11.\n    if (USE_DEVTOOLS && typeof Proxy !== 'undefined') {\n        pinia.use(devtoolsPlugin);\n    }\n    return pinia;\n}\n\n/**\n * Checks if a function is a `StoreDefinition`.\n *\n * @param fn - object to test\n * @returns true if `fn` is a StoreDefinition\n */\nconst isUseStore = (fn) => {\n    return typeof fn === 'function' && typeof fn.$id === 'string';\n};\n/**\n * Mutates in place `newState` with `oldState` to _hot update_ it. It will\n * remove any key not existing in `newState` and recursively merge plain\n * objects.\n *\n * @param newState - new state object to be patched\n * @param oldState - old state that should be used to patch newState\n * @returns - newState\n */\nfunction patchObject(newState, oldState) {\n    // no need to go through symbols because they cannot be serialized anyway\n    for (const key in oldState) {\n        const subPatch = oldState[key];\n        // skip the whole sub tree\n        if (!(key in newState)) {\n            continue;\n        }\n        const targetValue = newState[key];\n        if (isPlainObject(targetValue) &&\n            isPlainObject(subPatch) &&\n            !isRef(subPatch) &&\n            !isReactive(subPatch)) {\n            newState[key] = patchObject(targetValue, subPatch);\n        }\n        else {\n            // objects are either a bit more complex (e.g. refs) or primitives, so we\n            // just set the whole thing\n            if (isVue2) {\n                set(newState, key, subPatch);\n            }\n            else {\n                newState[key] = subPatch;\n            }\n        }\n    }\n    return newState;\n}\n/**\n * Creates an _accept_ function to pass to `import.meta.hot` in Vite applications.\n *\n * @example\n * ```js\n * const useUser = defineStore(...)\n * if (import.meta.hot) {\n *   import.meta.hot.accept(acceptHMRUpdate(useUser, import.meta.hot))\n * }\n * ```\n *\n * @param initialUseStore - return of the defineStore to hot update\n * @param hot - `import.meta.hot`\n */\nfunction acceptHMRUpdate(initialUseStore, hot) {\n    // strip as much as possible from iife.prod\n    if (!(process.env.NODE_ENV !== 'production')) {\n        return () => { };\n    }\n    return (newModule) => {\n        const pinia = hot.data.pinia || initialUseStore._pinia;\n        if (!pinia) {\n            // this store is still not used\n            return;\n        }\n        // preserve the pinia instance across loads\n        hot.data.pinia = pinia;\n        // console.log('got data', newStore)\n        for (const exportName in newModule) {\n            const useStore = newModule[exportName];\n            // console.log('checking for', exportName)\n            if (isUseStore(useStore) && pinia._s.has(useStore.$id)) {\n                // console.log('Accepting update for', useStore.$id)\n                const id = useStore.$id;\n                if (id !== initialUseStore.$id) {\n                    console.warn(`The id of the store changed from \"${initialUseStore.$id}\" to \"${id}\". Reloading.`);\n                    // return import.meta.hot.invalidate()\n                    return hot.invalidate();\n                }\n                const existingStore = pinia._s.get(id);\n                if (!existingStore) {\n                    console.log(`[Pinia]: skipping hmr because store doesn't exist yet`);\n                    return;\n                }\n                useStore(pinia, existingStore);\n            }\n        }\n    };\n}\n\nconst noop = () => { };\nfunction addSubscription(subscriptions, callback, detached, onCleanup = noop) {\n    subscriptions.push(callback);\n    const removeSubscription = () => {\n        const idx = subscriptions.indexOf(callback);\n        if (idx > -1) {\n            subscriptions.splice(idx, 1);\n            onCleanup();\n        }\n    };\n    if (!detached && getCurrentScope()) {\n        onScopeDispose(removeSubscription);\n    }\n    return removeSubscription;\n}\nfunction triggerSubscriptions(subscriptions, ...args) {\n    subscriptions.slice().forEach((callback) => {\n        callback(...args);\n    });\n}\n\nconst fallbackRunWithContext = (fn) => fn();\nfunction mergeReactiveObjects(target, patchToApply) {\n    // Handle Map instances\n    if (target instanceof Map && patchToApply instanceof Map) {\n        patchToApply.forEach((value, key) => target.set(key, value));\n    }\n    // Handle Set instances\n    if (target instanceof Set && patchToApply instanceof Set) {\n        patchToApply.forEach(target.add, target);\n    }\n    // no need to go through symbols because they cannot be serialized anyway\n    for (const key in patchToApply) {\n        if (!patchToApply.hasOwnProperty(key))\n            continue;\n        const subPatch = patchToApply[key];\n        const targetValue = target[key];\n        if (isPlainObject(targetValue) &&\n            isPlainObject(subPatch) &&\n            target.hasOwnProperty(key) &&\n            !isRef(subPatch) &&\n            !isReactive(subPatch)) {\n            // NOTE: here I wanted to warn about inconsistent types but it's not possible because in setup stores one might\n            // start the value of a property as a certain type e.g. a Map, and then for some reason, during SSR, change that\n            // to `undefined`. When trying to hydrate, we want to override the Map with `undefined`.\n            target[key] = mergeReactiveObjects(targetValue, subPatch);\n        }\n        else {\n            // @ts-expect-error: subPatch is a valid value\n            target[key] = subPatch;\n        }\n    }\n    return target;\n}\nconst skipHydrateSymbol = (process.env.NODE_ENV !== 'production')\n    ? Symbol('pinia:skipHydration')\n    : /* istanbul ignore next */ Symbol();\nconst skipHydrateMap = /*#__PURE__*/ new WeakMap();\n/**\n * Tells Pinia to skip the hydration process of a given object. This is useful in setup stores (only) when you return a\n * stateful object in the store but it isn't really state. e.g. returning a router instance in a setup store.\n *\n * @param obj - target object\n * @returns obj\n */\nfunction skipHydrate(obj) {\n    return isVue2\n        ? // in @vue/composition-api, the refs are sealed so defineProperty doesn't work...\n            /* istanbul ignore next */ skipHydrateMap.set(obj, 1) && obj\n        : Object.defineProperty(obj, skipHydrateSymbol, {});\n}\n/**\n * Returns whether a value should be hydrated\n *\n * @param obj - target variable\n * @returns true if `obj` should be hydrated\n */\nfunction shouldHydrate(obj) {\n    return isVue2\n        ? /* istanbul ignore next */ !skipHydrateMap.has(obj)\n        : !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);\n}\nconst { assign } = Object;\nfunction isComputed(o) {\n    return !!(isRef(o) && o.effect);\n}\nfunction createOptionsStore(id, options, pinia, hot) {\n    const { state, actions, getters } = options;\n    const initialState = pinia.state.value[id];\n    let store;\n    function setup() {\n        if (!initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\n            /* istanbul ignore if */\n            if (isVue2) {\n                set(pinia.state.value, id, state ? state() : {});\n            }\n            else {\n                pinia.state.value[id] = state ? state() : {};\n            }\n        }\n        // avoid creating a state in pinia.state.value\n        const localState = (process.env.NODE_ENV !== 'production') && hot\n            ? // use ref() to unwrap refs inside state TODO: check if this is still necessary\n                toRefs(ref(state ? state() : {}).value)\n            : toRefs(pinia.state.value[id]);\n        return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {\n            if ((process.env.NODE_ENV !== 'production') && name in localState) {\n                console.warn(`[]: A getter cannot have the same name as another state property. Rename one of them. Found with \"${name}\" in store \"${id}\".`);\n            }\n            computedGetters[name] = markRaw(computed(() => {\n                setActivePinia(pinia);\n                // it was created just before\n                const store = pinia._s.get(id);\n                // allow cross using stores\n                /* istanbul ignore next */\n                if (isVue2 && !store._r)\n                    return;\n                // @ts-expect-error\n                // return getters![name].call(context, context)\n                // TODO: avoid reading the getter while assigning with a global variable\n                return getters[name].call(store, store);\n            }));\n            return computedGetters;\n        }, {}));\n    }\n    store = createSetupStore(id, setup, options, pinia, hot, true);\n    return store;\n}\nfunction createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {\n    let scope;\n    const optionsForPlugin = assign({ actions: {} }, options);\n    /* istanbul ignore if */\n    if ((process.env.NODE_ENV !== 'production') && !pinia._e.active) {\n        throw new Error('Pinia destroyed');\n    }\n    // watcher options for $subscribe\n    const $subscribeOptions = {\n        deep: true,\n        // flush: 'post',\n    };\n    /* istanbul ignore else */\n    if ((process.env.NODE_ENV !== 'production') && !isVue2) {\n        $subscribeOptions.onTrigger = (event) => {\n            /* istanbul ignore else */\n            if (isListening) {\n                debuggerEvents = event;\n                // avoid triggering this while the store is being built and the state is being set in pinia\n            }\n            else if (isListening == false && !store._hotUpdating) {\n                // let patch send all the events together later\n                /* istanbul ignore else */\n                if (Array.isArray(debuggerEvents)) {\n                    debuggerEvents.push(event);\n                }\n                else {\n                    console.error(' debuggerEvents should be an array. This is most likely an internal Pinia bug.');\n                }\n            }\n        };\n    }\n    // internal state\n    let isListening; // set to true at the end\n    let isSyncListening; // set to true at the end\n    let subscriptions = [];\n    let actionSubscriptions = [];\n    let debuggerEvents;\n    const initialState = pinia.state.value[$id];\n    // avoid setting the state for option stores if it is set\n    // by the setup\n    if (!isOptionsStore && !initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\n        /* istanbul ignore if */\n        if (isVue2) {\n            set(pinia.state.value, $id, {});\n        }\n        else {\n            pinia.state.value[$id] = {};\n        }\n    }\n    const hotState = ref({});\n    // avoid triggering too many listeners\n    // https://github.com/vuejs/pinia/issues/1129\n    let activeListener;\n    function $patch(partialStateOrMutator) {\n        let subscriptionMutation;\n        isListening = isSyncListening = false;\n        // reset the debugger events since patches are sync\n        /* istanbul ignore else */\n        if ((process.env.NODE_ENV !== 'production')) {\n            debuggerEvents = [];\n        }\n        if (typeof partialStateOrMutator === 'function') {\n            partialStateOrMutator(pinia.state.value[$id]);\n            subscriptionMutation = {\n                type: MutationType.patchFunction,\n                storeId: $id,\n                events: debuggerEvents,\n            };\n        }\n        else {\n            mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);\n            subscriptionMutation = {\n                type: MutationType.patchObject,\n                payload: partialStateOrMutator,\n                storeId: $id,\n                events: debuggerEvents,\n            };\n        }\n        const myListenerId = (activeListener = Symbol());\n        nextTick().then(() => {\n            if (activeListener === myListenerId) {\n                isListening = true;\n            }\n        });\n        isSyncListening = true;\n        // because we paused the watcher, we need to manually call the subscriptions\n        triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);\n    }\n    const $reset = isOptionsStore\n        ? function $reset() {\n            const { state } = options;\n            const newState = state ? state() : {};\n            // we use a patch to group all changes into one single subscription\n            this.$patch(($state) => {\n                assign($state, newState);\n            });\n        }\n        : /* istanbul ignore next */\n            (process.env.NODE_ENV !== 'production')\n                ? () => {\n                    throw new Error(`: Store \"${$id}\" is built using the setup syntax and does not implement $reset().`);\n                }\n                : noop;\n    function $dispose() {\n        scope.stop();\n        subscriptions = [];\n        actionSubscriptions = [];\n        pinia._s.delete($id);\n    }\n    /**\n     * Wraps an action to handle subscriptions.\n     *\n     * @param name - name of the action\n     * @param action - action to wrap\n     * @returns a wrapped action to handle subscriptions\n     */\n    function wrapAction(name, action) {\n        return function () {\n            setActivePinia(pinia);\n            const args = Array.from(arguments);\n            const afterCallbackList = [];\n            const onErrorCallbackList = [];\n            function after(callback) {\n                afterCallbackList.push(callback);\n            }\n            function onError(callback) {\n                onErrorCallbackList.push(callback);\n            }\n            // @ts-expect-error\n            triggerSubscriptions(actionSubscriptions, {\n                args,\n                name,\n                store,\n                after,\n                onError,\n            });\n            let ret;\n            try {\n                ret = action.apply(this && this.$id === $id ? this : store, args);\n                // handle sync errors\n            }\n            catch (error) {\n                triggerSubscriptions(onErrorCallbackList, error);\n                throw error;\n            }\n            if (ret instanceof Promise) {\n                return ret\n                    .then((value) => {\n                    triggerSubscriptions(afterCallbackList, value);\n                    return value;\n                })\n                    .catch((error) => {\n                    triggerSubscriptions(onErrorCallbackList, error);\n                    return Promise.reject(error);\n                });\n            }\n            // trigger after callbacks\n            triggerSubscriptions(afterCallbackList, ret);\n            return ret;\n        };\n    }\n    const _hmrPayload = /*#__PURE__*/ markRaw({\n        actions: {},\n        getters: {},\n        state: [],\n        hotState,\n    });\n    const partialStore = {\n        _p: pinia,\n        // _s: scope,\n        $id,\n        $onAction: addSubscription.bind(null, actionSubscriptions),\n        $patch,\n        $reset,\n        $subscribe(callback, options = {}) {\n            const removeSubscription = addSubscription(subscriptions, callback, options.detached, () => stopWatcher());\n            const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {\n                if (options.flush === 'sync' ? isSyncListening : isListening) {\n                    callback({\n                        storeId: $id,\n                        type: MutationType.direct,\n                        events: debuggerEvents,\n                    }, state);\n                }\n            }, assign({}, $subscribeOptions, options)));\n            return removeSubscription;\n        },\n        $dispose,\n    };\n    /* istanbul ignore if */\n    if (isVue2) {\n        // start as non ready\n        partialStore._r = false;\n    }\n    const store = reactive((process.env.NODE_ENV !== 'production') || USE_DEVTOOLS\n        ? assign({\n            _hmrPayload,\n            _customProperties: markRaw(new Set()), // devtools custom properties\n        }, partialStore\n        // must be added later\n        // setupStore\n        )\n        : partialStore);\n    // store the partial store now so the setup of stores can instantiate each other before they are finished without\n    // creating infinite loops.\n    pinia._s.set($id, store);\n    const runWithContext = (pinia._a && pinia._a.runWithContext) || fallbackRunWithContext;\n    // TODO: idea create skipSerialize that marks properties as non serializable and they are skipped\n    const setupStore = pinia._e.run(() => {\n        scope = effectScope();\n        return runWithContext(() => scope.run(setup));\n    });\n    // overwrite existing actions to support $onAction\n    for (const key in setupStore) {\n        const prop = setupStore[key];\n        if ((isRef(prop) && !isComputed(prop)) || isReactive(prop)) {\n            // mark it as a piece of state to be serialized\n            if ((process.env.NODE_ENV !== 'production') && hot) {\n                set(hotState.value, key, toRef(setupStore, key));\n                // createOptionStore directly sets the state in pinia.state.value so we\n                // can just skip that\n            }\n            else if (!isOptionsStore) {\n                // in setup stores we must hydrate the state and sync pinia state tree with the refs the user just created\n                if (initialState && shouldHydrate(prop)) {\n                    if (isRef(prop)) {\n                        prop.value = initialState[key];\n                    }\n                    else {\n                        // probably a reactive object, lets recursively assign\n                        // @ts-expect-error: prop is unknown\n                        mergeReactiveObjects(prop, initialState[key]);\n                    }\n                }\n                // transfer the ref to the pinia state to keep everything in sync\n                /* istanbul ignore if */\n                if (isVue2) {\n                    set(pinia.state.value[$id], key, prop);\n                }\n                else {\n                    pinia.state.value[$id][key] = prop;\n                }\n            }\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                _hmrPayload.state.push(key);\n            }\n            // action\n        }\n        else if (typeof prop === 'function') {\n            // @ts-expect-error: we are overriding the function we avoid wrapping if\n            const actionValue = (process.env.NODE_ENV !== 'production') && hot ? prop : wrapAction(key, prop);\n            // this a hot module replacement store because the hotUpdate method needs\n            // to do it with the right context\n            /* istanbul ignore if */\n            if (isVue2) {\n                set(setupStore, key, actionValue);\n            }\n            else {\n                // @ts-expect-error\n                setupStore[key] = actionValue;\n            }\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                _hmrPayload.actions[key] = prop;\n            }\n            // list actions so they can be used in plugins\n            // @ts-expect-error\n            optionsForPlugin.actions[key] = prop;\n        }\n        else if ((process.env.NODE_ENV !== 'production')) {\n            // add getters for devtools\n            if (isComputed(prop)) {\n                _hmrPayload.getters[key] = isOptionsStore\n                    ? // @ts-expect-error\n                        options.getters[key]\n                    : prop;\n                if (IS_CLIENT) {\n                    const getters = setupStore._getters ||\n                        // @ts-expect-error: same\n                        (setupStore._getters = markRaw([]));\n                    getters.push(key);\n                }\n            }\n        }\n    }\n    // add the state, getters, and action properties\n    /* istanbul ignore if */\n    if (isVue2) {\n        Object.keys(setupStore).forEach((key) => {\n            set(store, key, setupStore[key]);\n        });\n    }\n    else {\n        assign(store, setupStore);\n        // allows retrieving reactive objects with `storeToRefs()`. Must be called after assigning to the reactive object.\n        // Make `storeToRefs()` work with `reactive()` #799\n        assign(toRaw(store), setupStore);\n    }\n    // use this instead of a computed with setter to be able to create it anywhere\n    // without linking the computed lifespan to wherever the store is first\n    // created.\n    Object.defineProperty(store, '$state', {\n        get: () => ((process.env.NODE_ENV !== 'production') && hot ? hotState.value : pinia.state.value[$id]),\n        set: (state) => {\n            /* istanbul ignore if */\n            if ((process.env.NODE_ENV !== 'production') && hot) {\n                throw new Error('cannot set hotState');\n            }\n            $patch(($state) => {\n                assign($state, state);\n            });\n        },\n    });\n    // add the hotUpdate before plugins to allow them to override it\n    /* istanbul ignore else */\n    if ((process.env.NODE_ENV !== 'production')) {\n        store._hotUpdate = markRaw((newStore) => {\n            store._hotUpdating = true;\n            newStore._hmrPayload.state.forEach((stateKey) => {\n                if (stateKey in store.$state) {\n                    const newStateTarget = newStore.$state[stateKey];\n                    const oldStateSource = store.$state[stateKey];\n                    if (typeof newStateTarget === 'object' &&\n                        isPlainObject(newStateTarget) &&\n                        isPlainObject(oldStateSource)) {\n                        patchObject(newStateTarget, oldStateSource);\n                    }\n                    else {\n                        // transfer the ref\n                        newStore.$state[stateKey] = oldStateSource;\n                    }\n                }\n                // patch direct access properties to allow store.stateProperty to work as\n                // store.$state.stateProperty\n                set(store, stateKey, toRef(newStore.$state, stateKey));\n            });\n            // remove deleted state properties\n            Object.keys(store.$state).forEach((stateKey) => {\n                if (!(stateKey in newStore.$state)) {\n                    del(store, stateKey);\n                }\n            });\n            // avoid devtools logging this as a mutation\n            isListening = false;\n            isSyncListening = false;\n            pinia.state.value[$id] = toRef(newStore._hmrPayload, 'hotState');\n            isSyncListening = true;\n            nextTick().then(() => {\n                isListening = true;\n            });\n            for (const actionName in newStore._hmrPayload.actions) {\n                const action = newStore[actionName];\n                set(store, actionName, wrapAction(actionName, action));\n            }\n            // TODO: does this work in both setup and option store?\n            for (const getterName in newStore._hmrPayload.getters) {\n                const getter = newStore._hmrPayload.getters[getterName];\n                const getterValue = isOptionsStore\n                    ? // special handling of options api\n                        computed(() => {\n                            setActivePinia(pinia);\n                            return getter.call(store, store);\n                        })\n                    : getter;\n                set(store, getterName, getterValue);\n            }\n            // remove deleted getters\n            Object.keys(store._hmrPayload.getters).forEach((key) => {\n                if (!(key in newStore._hmrPayload.getters)) {\n                    del(store, key);\n                }\n            });\n            // remove old actions\n            Object.keys(store._hmrPayload.actions).forEach((key) => {\n                if (!(key in newStore._hmrPayload.actions)) {\n                    del(store, key);\n                }\n            });\n            // update the values used in devtools and to allow deleting new properties later on\n            store._hmrPayload = newStore._hmrPayload;\n            store._getters = newStore._getters;\n            store._hotUpdating = false;\n        });\n    }\n    if (USE_DEVTOOLS) {\n        const nonEnumerable = {\n            writable: true,\n            configurable: true,\n            // avoid warning on devtools trying to display this property\n            enumerable: false,\n        };\n        ['_p', '_hmrPayload', '_getters', '_customProperties'].forEach((p) => {\n            Object.defineProperty(store, p, assign({ value: store[p] }, nonEnumerable));\n        });\n    }\n    /* istanbul ignore if */\n    if (isVue2) {\n        // mark the store as ready before plugins\n        store._r = true;\n    }\n    // apply all plugins\n    pinia._p.forEach((extender) => {\n        /* istanbul ignore else */\n        if (USE_DEVTOOLS) {\n            const extensions = scope.run(() => extender({\n                store,\n                app: pinia._a,\n                pinia,\n                options: optionsForPlugin,\n            }));\n            Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));\n            assign(store, extensions);\n        }\n        else {\n            assign(store, scope.run(() => extender({\n                store,\n                app: pinia._a,\n                pinia,\n                options: optionsForPlugin,\n            })));\n        }\n    });\n    if ((process.env.NODE_ENV !== 'production') &&\n        store.$state &&\n        typeof store.$state === 'object' &&\n        typeof store.$state.constructor === 'function' &&\n        !store.$state.constructor.toString().includes('[native code]')) {\n        console.warn(`[]: The \"state\" must be a plain object. It cannot be\\n` +\n            `\\tstate: () => new MyClass()\\n` +\n            `Found in store \"${store.$id}\".`);\n    }\n    // only apply hydrate to option stores with an initial state in pinia\n    if (initialState &&\n        isOptionsStore &&\n        options.hydrate) {\n        options.hydrate(store.$state, initialState);\n    }\n    isListening = true;\n    isSyncListening = true;\n    return store;\n}\nfunction defineStore(\n// TODO: add proper types from above\nidOrOptions, setup, setupOptions) {\n    let id;\n    let options;\n    const isSetupStore = typeof setup === 'function';\n    if (typeof idOrOptions === 'string') {\n        id = idOrOptions;\n        // the option store setup will contain the actual options in this case\n        options = isSetupStore ? setupOptions : setup;\n    }\n    else {\n        options = idOrOptions;\n        id = idOrOptions.id;\n        if ((process.env.NODE_ENV !== 'production') && typeof id !== 'string') {\n            throw new Error(`[]: \"defineStore()\" must be passed a store id as its first argument.`);\n        }\n    }\n    function useStore(pinia, hot) {\n        const hasContext = hasInjectionContext();\n        pinia =\n            // in test mode, ignore the argument provided as we can always retrieve a\n            // pinia instance with getActivePinia()\n            ((process.env.NODE_ENV === 'test') && activePinia && activePinia._testing ? null : pinia) ||\n                (hasContext ? inject(piniaSymbol, null) : null);\n        if (pinia)\n            setActivePinia(pinia);\n        if ((process.env.NODE_ENV !== 'production') && !activePinia) {\n            throw new Error(`[]: \"getActivePinia()\" was called but there was no active Pinia. Did you forget to install pinia?\\n` +\n                `\\tconst pinia = createPinia()\\n` +\n                `\\tapp.use(pinia)\\n` +\n                `This will fail in production.`);\n        }\n        pinia = activePinia;\n        if (!pinia._s.has(id)) {\n            // creating the store registers it in `pinia._s`\n            if (isSetupStore) {\n                createSetupStore(id, setup, options, pinia);\n            }\n            else {\n                createOptionsStore(id, options, pinia);\n            }\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                // @ts-expect-error: not the right inferred type\n                useStore._pinia = pinia;\n            }\n        }\n        const store = pinia._s.get(id);\n        if ((process.env.NODE_ENV !== 'production') && hot) {\n            const hotId = '__hot:' + id;\n            const newStore = isSetupStore\n                ? createSetupStore(hotId, setup, options, pinia, true)\n                : createOptionsStore(hotId, assign({}, options), pinia, true);\n            hot._hotUpdate(newStore);\n            // cleanup the state properties and the store from the cache\n            delete pinia.state.value[hotId];\n            pinia._s.delete(hotId);\n        }\n        if ((process.env.NODE_ENV !== 'production') && IS_CLIENT) {\n            const currentInstance = getCurrentInstance();\n            // save stores in instances to access them devtools\n            if (currentInstance &&\n                currentInstance.proxy &&\n                // avoid adding stores that are just built for hot module replacement\n                !hot) {\n                const vm = currentInstance.proxy;\n                const cache = '_pStores' in vm ? vm._pStores : (vm._pStores = {});\n                cache[id] = store;\n            }\n        }\n        // StoreGeneric cannot be casted towards Store\n        return store;\n    }\n    useStore.$id = id;\n    return useStore;\n}\n\nlet mapStoreSuffix = 'Store';\n/**\n * Changes the suffix added by `mapStores()`. Can be set to an empty string.\n * Defaults to `\"Store\"`. Make sure to extend the MapStoresCustomization\n * interface if you are using TypeScript.\n *\n * @param suffix - new suffix\n */\nfunction setMapStoreSuffix(suffix // could be 'Store' but that would be annoying for JS\n) {\n    mapStoreSuffix = suffix;\n}\n/**\n * Allows using stores without the composition API (`setup()`) by generating an\n * object to be spread in the `computed` field of a component. It accepts a list\n * of store definitions.\n *\n * @example\n * ```js\n * export default {\n *   computed: {\n *     // other computed properties\n *     ...mapStores(useUserStore, useCartStore)\n *   },\n *\n *   created() {\n *     this.userStore // store with id \"user\"\n *     this.cartStore // store with id \"cart\"\n *   }\n * }\n * ```\n *\n * @param stores - list of stores to map to an object\n */\nfunction mapStores(...stores) {\n    if ((process.env.NODE_ENV !== 'production') && Array.isArray(stores[0])) {\n        console.warn(`[]: Directly pass all stores to \"mapStores()\" without putting them in an array:\\n` +\n            `Replace\\n` +\n            `\\tmapStores([useAuthStore, useCartStore])\\n` +\n            `with\\n` +\n            `\\tmapStores(useAuthStore, useCartStore)\\n` +\n            `This will fail in production if not fixed.`);\n        stores = stores[0];\n    }\n    return stores.reduce((reduced, useStore) => {\n        // @ts-expect-error: $id is added by defineStore\n        reduced[useStore.$id + mapStoreSuffix] = function () {\n            return useStore(this.$pinia);\n        };\n        return reduced;\n    }, {});\n}\n/**\n * Allows using state and getters from one store without using the composition\n * API (`setup()`) by generating an object to be spread in the `computed` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keysOrMapper - array or object\n */\nfunction mapState(useStore, keysOrMapper) {\n    return Array.isArray(keysOrMapper)\n        ? keysOrMapper.reduce((reduced, key) => {\n            reduced[key] = function () {\n                return useStore(this.$pinia)[key];\n            };\n            return reduced;\n        }, {})\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\n            // @ts-expect-error\n            reduced[key] = function () {\n                const store = useStore(this.$pinia);\n                const storeKey = keysOrMapper[key];\n                // for some reason TS is unable to infer the type of storeKey to be a\n                // function\n                return typeof storeKey === 'function'\n                    ? storeKey.call(this, store)\n                    : store[storeKey];\n            };\n            return reduced;\n        }, {});\n}\n/**\n * Alias for `mapState()`. You should use `mapState()` instead.\n * @deprecated use `mapState()` instead.\n */\nconst mapGetters = mapState;\n/**\n * Allows directly using actions from your store without using the composition\n * API (`setup()`) by generating an object to be spread in the `methods` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keysOrMapper - array or object\n */\nfunction mapActions(useStore, keysOrMapper) {\n    return Array.isArray(keysOrMapper)\n        ? keysOrMapper.reduce((reduced, key) => {\n            // @ts-expect-error\n            reduced[key] = function (...args) {\n                return useStore(this.$pinia)[key](...args);\n            };\n            return reduced;\n        }, {})\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\n            // @ts-expect-error\n            reduced[key] = function (...args) {\n                return useStore(this.$pinia)[keysOrMapper[key]](...args);\n            };\n            return reduced;\n        }, {});\n}\n/**\n * Allows using state and getters from one store without using the composition\n * API (`setup()`) by generating an object to be spread in the `computed` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keysOrMapper - array or object\n */\nfunction mapWritableState(useStore, keysOrMapper) {\n    return Array.isArray(keysOrMapper)\n        ? keysOrMapper.reduce((reduced, key) => {\n            // @ts-ignore\n            reduced[key] = {\n                get() {\n                    return useStore(this.$pinia)[key];\n                },\n                set(value) {\n                    // it's easier to type it here as any\n                    return (useStore(this.$pinia)[key] = value);\n                },\n            };\n            return reduced;\n        }, {})\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\n            // @ts-ignore\n            reduced[key] = {\n                get() {\n                    return useStore(this.$pinia)[keysOrMapper[key]];\n                },\n                set(value) {\n                    // it's easier to type it here as any\n                    return (useStore(this.$pinia)[keysOrMapper[key]] = value);\n                },\n            };\n            return reduced;\n        }, {});\n}\n\n/**\n * Creates an object of references with all the state, getters, and plugin-added\n * state properties of the store. Similar to `toRefs()` but specifically\n * designed for Pinia stores so methods and non reactive properties are\n * completely ignored.\n *\n * @param store - store to extract the refs from\n */\nfunction storeToRefs(store) {\n    // See https://github.com/vuejs/pinia/issues/852\n    // It's easier to just use toRefs() even if it includes more stuff\n    if (isVue2) {\n        // @ts-expect-error: toRefs include methods and others\n        return toRefs(store);\n    }\n    else {\n        store = toRaw(store);\n        const refs = {};\n        for (const key in store) {\n            const value = store[key];\n            if (isRef(value) || isReactive(value)) {\n                // @ts-expect-error: the key is state or getter\n                refs[key] =\n                    // ---\n                    toRef(store, key);\n            }\n        }\n        return refs;\n    }\n}\n\n/**\n * Vue 2 Plugin that must be installed for pinia to work. Note **you don't need\n * this plugin if you are using Nuxt.js**. Use the `buildModule` instead:\n * https://pinia.vuejs.org/ssr/nuxt.html.\n *\n * @example\n * ```js\n * import Vue from 'vue'\n * import { PiniaVuePlugin, createPinia } from 'pinia'\n *\n * Vue.use(PiniaVuePlugin)\n * const pinia = createPinia()\n *\n * new Vue({\n *   el: '#app',\n *   // ...\n *   pinia,\n * })\n * ```\n *\n * @param _Vue - `Vue` imported from 'vue'.\n */\nconst PiniaVuePlugin = function (_Vue) {\n    // Equivalent of\n    // app.config.globalProperties.$pinia = pinia\n    _Vue.mixin({\n        beforeCreate() {\n            const options = this.$options;\n            if (options.pinia) {\n                const pinia = options.pinia;\n                // HACK: taken from provide(): https://github.com/vuejs/composition-api/blob/main/src/apis/inject.ts#L31\n                /* istanbul ignore else */\n                if (!this._provided) {\n                    const provideCache = {};\n                    Object.defineProperty(this, '_provided', {\n                        get: () => provideCache,\n                        set: (v) => Object.assign(provideCache, v),\n                    });\n                }\n                this._provided[piniaSymbol] = pinia;\n                // propagate the pinia instance in an SSR friendly way\n                // avoid adding it to nuxt twice\n                /* istanbul ignore else */\n                if (!this.$pinia) {\n                    this.$pinia = pinia;\n                }\n                pinia._a = this;\n                if (IS_CLIENT) {\n                    // this allows calling useStore() outside of a component setup after\n                    // installing pinia's plugin\n                    setActivePinia(pinia);\n                }\n                if (USE_DEVTOOLS) {\n                    registerPiniaDevtools(pinia._a, pinia);\n                }\n            }\n            else if (!this.$pinia && options.parent && options.parent.$pinia) {\n                this.$pinia = options.parent.$pinia;\n            }\n        },\n        destroyed() {\n            delete this._pStores;\n        },\n    });\n};\n\nexport { MutationType, PiniaVuePlugin, acceptHMRUpdate, createPinia, defineStore, getActivePinia, mapActions, mapGetters, mapState, mapStores, mapWritableState, setActivePinia, setMapStoreSuffix, skipHydrate, storeToRefs };\n","import { createPinia, setActivePinia } from \"pinia\";\nimport { defineNuxtPlugin } from \"#app\";\nconst plugin = defineNuxtPlugin((nuxtApp) => {\n  const pinia = createPinia();\n  nuxtApp.vueApp.use(pinia);\n  setActivePinia(pinia);\n  if (process.server) {\n    nuxtApp.payload.pinia = pinia.state.value;\n  } else if (nuxtApp.payload && nuxtApp.payload.pinia) {\n    pinia.state.value = nuxtApp.payload.pinia;\n  }\n  return {\n    provide: {\n      pinia\n    }\n  };\n});\nexport default plugin;\n","import { defineAsyncComponent } from 'vue'\nimport { defineNuxtPlugin } from '#app'\n\nconst components = {}\n\nexport default defineNuxtPlugin(nuxtApp => {\n  for (const name in components) {\n    nuxtApp.vueApp.component(name, components[name])\n    nuxtApp.vueApp.component('Lazy' + name, components[name])\n  }\n})\n","function asArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\nconst SelfClosingTags = [\"meta\", \"link\", \"base\"];\nconst TagsWithInnerContent = [\"title\", \"script\", \"style\", \"noscript\"];\nconst HasElementTags = [\n  \"base\",\n  \"meta\",\n  \"link\",\n  \"style\",\n  \"script\",\n  \"noscript\"\n];\nconst ValidHeadTags = [\n  \"title\",\n  \"titleTemplate\",\n  \"templateParams\",\n  \"base\",\n  \"htmlAttrs\",\n  \"bodyAttrs\",\n  \"meta\",\n  \"link\",\n  \"style\",\n  \"script\",\n  \"noscript\"\n];\nconst UniqueTags = [\"base\", \"title\", \"titleTemplate\", \"bodyAttrs\", \"htmlAttrs\", \"templateParams\"];\nconst TagConfigKeys = [\"tagPosition\", \"tagPriority\", \"tagDuplicateStrategy\", \"innerHTML\", \"textContent\"];\n\nfunction defineHeadPlugin(plugin) {\n  return plugin;\n}\n\nfunction hashCode(s) {\n  let h = 9;\n  for (let i = 0; i < s.length; )\n    h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);\n  return ((h ^ h >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase();\n}\nfunction hashTag(tag) {\n  return hashCode(`${tag.tag}:${tag.textContent || tag.innerHTML || \"\"}:${Object.entries(tag.props).map(([key, value]) => `${key}:${String(value)}`).join(\",\")}`);\n}\nfunction computeHashes(hashes) {\n  let h = 9;\n  for (const s of hashes) {\n    for (let i = 0; i < s.length; )\n      h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);\n  }\n  return ((h ^ h >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase();\n}\n\nfunction tagDedupeKey(tag, fn) {\n  const { props, tag: tagName } = tag;\n  if (UniqueTags.includes(tagName))\n    return tagName;\n  if (tagName === \"link\" && props.rel === \"canonical\")\n    return \"canonical\";\n  if (props.charset)\n    return \"charset\";\n  const name = [\"id\"];\n  if (tagName === \"meta\")\n    name.push(...[\"name\", \"property\", \"http-equiv\"]);\n  for (const n of name) {\n    if (typeof props[n] !== \"undefined\") {\n      const val = String(props[n]);\n      if (fn && !fn(val))\n        return false;\n      return `${tagName}:${n}:${val}`;\n    }\n  }\n  return false;\n}\n\nfunction resolveTitleTemplate(template, title) {\n  if (template == null)\n    return title || null;\n  if (typeof template === \"function\")\n    return template(title);\n  return template;\n}\n\nexport { HasElementTags, SelfClosingTags, TagConfigKeys, TagsWithInnerContent, UniqueTags, ValidHeadTags, asArray, computeHashes, defineHeadPlugin, hashCode, hashTag, resolveTitleTemplate, tagDedupeKey };\n","import { TagsWithInnerContent, computeHashes, hashTag, HasElementTags, tagDedupeKey, defineHeadPlugin } from '@unhead/shared';\n\nfunction setAttrs(ctx, newEntry = false, markSideEffect) {\n  const { tag, $el } = ctx;\n  if (!$el)\n    return;\n  Object.entries(tag.props).forEach(([k, value]) => {\n    value = String(value);\n    const attrSdeKey = `attr:${k}`;\n    if (k === \"class\") {\n      if (!value)\n        return;\n      for (const c of value.split(\" \")) {\n        const classSdeKey = `${attrSdeKey}:${c}`;\n        if (markSideEffect)\n          markSideEffect(ctx, classSdeKey, () => $el.classList.remove(c));\n        if (!$el.classList.contains(c))\n          $el.classList.add(c);\n      }\n      return;\n    }\n    if (markSideEffect && !k.startsWith(\"data-h-\"))\n      markSideEffect(ctx, attrSdeKey, () => $el.removeAttribute(k));\n    if (newEntry || $el.getAttribute(k) !== value)\n      $el.setAttribute(k, value);\n  });\n  if (TagsWithInnerContent.includes(tag.tag)) {\n    if (tag.textContent && tag.textContent !== $el.textContent)\n      $el.textContent = tag.textContent;\n    else if (tag.innerHTML && tag.innerHTML !== $el.innerHTML)\n      $el.innerHTML = tag.innerHTML;\n  }\n}\n\nlet prevHash = false;\nasync function renderDOMHead(head, options = {}) {\n  const beforeRenderCtx = { shouldRender: true };\n  await head.hooks.callHook(\"dom:beforeRender\", beforeRenderCtx);\n  if (!beforeRenderCtx.shouldRender)\n    return;\n  const dom = options.document || head.resolvedOptions.document || window.document;\n  const tagContexts = (await head.resolveTags()).map(setupTagRenderCtx);\n  if (head.resolvedOptions.experimentalHashHydration) {\n    prevHash = prevHash || head._hash || false;\n    if (prevHash) {\n      const hash = computeHashes(tagContexts.map((ctx) => ctx.tag._h));\n      if (prevHash === hash)\n        return;\n      prevHash = hash;\n    }\n  }\n  const staleSideEffects = head._popSideEffectQueue();\n  head.headEntries().map((entry) => entry._sde).forEach((sde) => {\n    Object.entries(sde).forEach(([key, fn]) => {\n      staleSideEffects[key] = fn;\n    });\n  });\n  const markSideEffect = (ctx, key, fn) => {\n    key = `${ctx.renderId}:${key}`;\n    if (ctx.entry)\n      ctx.entry._sde[key] = fn;\n    delete staleSideEffects[key];\n  };\n  function setupTagRenderCtx(tag) {\n    const entry = head.headEntries().find((e) => e._i === tag._e);\n    const renderCtx = {\n      renderId: tag._d || hashTag(tag),\n      $el: null,\n      shouldRender: true,\n      tag,\n      entry,\n      markSideEffect: (key, fn) => markSideEffect(renderCtx, key, fn)\n    };\n    return renderCtx;\n  }\n  const renders = [];\n  const pendingRenders = {\n    body: [],\n    head: []\n  };\n  const markEl = (ctx) => {\n    head._elMap[ctx.renderId] = ctx.$el;\n    renders.push(ctx);\n    markSideEffect(ctx, \"el\", () => {\n      ctx.$el?.remove();\n      delete head._elMap[ctx.renderId];\n    });\n  };\n  for (const ctx of tagContexts) {\n    await head.hooks.callHook(\"dom:beforeRenderTag\", ctx);\n    if (!ctx.shouldRender)\n      continue;\n    const { tag } = ctx;\n    if (tag.tag === \"title\") {\n      dom.title = tag.textContent || \"\";\n      renders.push(ctx);\n      continue;\n    }\n    if (tag.tag === \"htmlAttrs\" || tag.tag === \"bodyAttrs\") {\n      ctx.$el = dom[tag.tag === \"htmlAttrs\" ? \"documentElement\" : \"body\"];\n      setAttrs(ctx, false, markSideEffect);\n      renders.push(ctx);\n      continue;\n    }\n    ctx.$el = head._elMap[ctx.renderId];\n    if (!ctx.$el && tag.key)\n      ctx.$el = dom.querySelector(`${tag.tagPosition?.startsWith(\"body\") ? \"body\" : \"head\"} > ${tag.tag}[data-h-${tag._h}]`);\n    if (ctx.$el) {\n      if (ctx.tag._d)\n        setAttrs(ctx);\n      markEl(ctx);\n      continue;\n    }\n    pendingRenders[tag.tagPosition?.startsWith(\"body\") ? \"body\" : \"head\"].push(ctx);\n  }\n  const fragments = {\n    bodyClose: void 0,\n    bodyOpen: void 0,\n    head: void 0\n  };\n  Object.entries(pendingRenders).forEach(([pos, queue]) => {\n    if (!queue.length)\n      return;\n    const children = dom?.[pos]?.children;\n    if (!children)\n      return;\n    for (const $el of [...children].reverse()) {\n      const elTag = $el.tagName.toLowerCase();\n      if (!HasElementTags.includes(elTag))\n        continue;\n      const props = $el.getAttributeNames().reduce((props2, name) => ({ ...props2, [name]: $el.getAttribute(name) }), {});\n      const tmpTag = { tag: elTag, props };\n      if ($el.innerHTML)\n        tmpTag.innerHTML = $el.innerHTML;\n      const tmpRenderId = hashTag(tmpTag);\n      let matchIdx = queue.findIndex((ctx) => ctx?.renderId === tmpRenderId);\n      if (matchIdx === -1) {\n        const tmpDedupeKey = tagDedupeKey(tmpTag);\n        matchIdx = queue.findIndex((ctx) => ctx?.tag._d && ctx.tag._d === tmpDedupeKey);\n      }\n      if (matchIdx !== -1) {\n        const ctx = queue[matchIdx];\n        ctx.$el = $el;\n        setAttrs(ctx);\n        markEl(ctx);\n        delete queue[matchIdx];\n      }\n    }\n    queue.forEach((ctx) => {\n      const pos2 = ctx.tag.tagPosition || \"head\";\n      fragments[pos2] = fragments[pos2] || dom.createDocumentFragment();\n      if (!ctx.$el) {\n        ctx.$el = dom.createElement(ctx.tag.tag);\n        setAttrs(ctx, true);\n      }\n      fragments[pos2].appendChild(ctx.$el);\n      markEl(ctx);\n    });\n  });\n  if (fragments.head)\n    dom.head.appendChild(fragments.head);\n  if (fragments.bodyOpen)\n    dom.body.insertBefore(fragments.bodyOpen, dom.body.firstChild);\n  if (fragments.bodyClose)\n    dom.body.appendChild(fragments.bodyClose);\n  for (const ctx of renders)\n    await head.hooks.callHook(\"dom:renderTag\", ctx);\n  Object.values(staleSideEffects).forEach((fn) => fn());\n}\nlet domUpdatePromise = null;\nasync function debouncedRenderDOMHead(head, options = {}) {\n  function doDomUpdate() {\n    domUpdatePromise = null;\n    return renderDOMHead(head, options);\n  }\n  const delayFn = options.delayFn || ((fn) => setTimeout(fn, 10));\n  return domUpdatePromise = domUpdatePromise || new Promise((resolve) => delayFn(() => resolve(doDomUpdate())));\n}\n\nfunction PatchDomOnEntryUpdatesPlugin(options) {\n  return defineHeadPlugin({\n    hooks: {\n      \"entries:updated\": function(head) {\n        if (typeof options?.document === \"undefined\" && typeof window === \"undefined\")\n          return;\n        let delayFn = options?.delayFn;\n        if (!delayFn && typeof requestAnimationFrame !== \"undefined\")\n          delayFn = requestAnimationFrame;\n        debouncedRenderDOMHead(head, { document: options?.document || window.document, delayFn });\n      }\n    }\n  });\n}\n\nfunction maybeGetSSRHash(document) {\n  return document?.head.querySelector('meta[name=\"unhead:ssr\"]')?.getAttribute(\"content\") || false;\n}\n\nexport { PatchDomOnEntryUpdatesPlugin, debouncedRenderDOMHead, domUpdatePromise, maybeGetSSRHash, renderDOMHead, setAttrs };\n","import { createHooks } from 'hookable';\nimport { PatchDomOnEntryUpdatesPlugin, maybeGetSSRHash } from '@unhead/dom';\nimport { defineHeadPlugin, resolveTitleTemplate, hashTag, hashCode, tagDedupeKey, HasElementTags, asArray as asArray$1, TagConfigKeys, TagsWithInnerContent, ValidHeadTags } from '@unhead/shared';\n\nconst TAG_WEIGHTS = {\n  // aliases\n  critical: 2,\n  high: 9,\n  low: 12,\n  // tags\n  base: -1,\n  title: 1,\n  meta: 10\n};\nfunction tagWeight(tag) {\n  if (typeof tag.tagPriority === \"number\")\n    return tag.tagPriority;\n  if (tag.tag === \"meta\") {\n    if (tag.props.charset)\n      return -2;\n    if (tag.props[\"http-equiv\"] === \"content-security-policy\")\n      return 0;\n  }\n  const key = tag.tagPriority || tag.tag;\n  if (key in TAG_WEIGHTS) {\n    return TAG_WEIGHTS[key];\n  }\n  return 10;\n}\nconst SortModifiers = [{ prefix: \"before:\", offset: -1 }, { prefix: \"after:\", offset: 1 }];\nfunction SortTagsPlugin() {\n  return defineHeadPlugin({\n    hooks: {\n      \"tags:resolve\": (ctx) => {\n        const tagPositionForKey = (key) => ctx.tags.find((tag) => tag._d === key)?._p;\n        for (const { prefix, offset } of SortModifiers) {\n          for (const tag of ctx.tags.filter((tag2) => typeof tag2.tagPriority === \"string\" && tag2.tagPriority.startsWith(prefix))) {\n            const position = tagPositionForKey(\n              tag.tagPriority.replace(prefix, \"\")\n            );\n            if (typeof position !== \"undefined\")\n              tag._p = position + offset;\n          }\n        }\n        ctx.tags.sort((a, b) => a._p - b._p).sort((a, b) => tagWeight(a) - tagWeight(b));\n      }\n    }\n  });\n}\n\nfunction TitleTemplatePlugin() {\n  return defineHeadPlugin({\n    hooks: {\n      \"tags:resolve\": (ctx) => {\n        const { tags } = ctx;\n        let titleTemplateIdx = tags.findIndex((i) => i.tag === \"titleTemplate\");\n        const titleIdx = tags.findIndex((i) => i.tag === \"title\");\n        if (titleIdx !== -1 && titleTemplateIdx !== -1) {\n          const newTitle = resolveTitleTemplate(\n            tags[titleTemplateIdx].textContent,\n            tags[titleIdx].textContent\n          );\n          if (newTitle !== null) {\n            tags[titleIdx].textContent = newTitle || tags[titleIdx].textContent;\n          } else {\n            delete tags[titleIdx];\n          }\n        } else if (titleTemplateIdx !== -1) {\n          const newTitle = resolveTitleTemplate(\n            tags[titleTemplateIdx].textContent\n          );\n          if (newTitle !== null) {\n            tags[titleTemplateIdx].textContent = newTitle;\n            tags[titleTemplateIdx].tag = \"title\";\n            titleTemplateIdx = -1;\n          }\n        }\n        if (titleTemplateIdx !== -1) {\n          delete tags[titleTemplateIdx];\n        }\n        ctx.tags = tags.filter(Boolean);\n      }\n    }\n  });\n}\n\nfunction DeprecatedTagAttrPlugin() {\n  return defineHeadPlugin({\n    hooks: {\n      \"tag:normalise\": function({ tag }) {\n        if (typeof tag.props.body !== \"undefined\") {\n          tag.tagPosition = \"bodyClose\";\n          delete tag.props.body;\n        }\n      }\n    }\n  });\n}\n\nconst DupeableTags = [\"link\", \"style\", \"script\", \"noscript\"];\nfunction ProvideTagHashPlugin() {\n  return defineHeadPlugin({\n    hooks: {\n      \"tag:normalise\": ({ tag, resolvedOptions }) => {\n        if (resolvedOptions.experimentalHashHydration === true) {\n          tag._h = hashTag(tag);\n        }\n        if (tag.key && DupeableTags.includes(tag.tag)) {\n          tag._h = hashCode(tag.key);\n          tag.props[`data-h-${tag._h}`] = \"\";\n        }\n      }\n    }\n  });\n}\n\nconst ValidEventTags = [\"script\", \"link\", \"bodyAttrs\"];\nfunction EventHandlersPlugin() {\n  const stripEventHandlers = (mode, tag) => {\n    const props = {};\n    const eventHandlers = {};\n    Object.entries(tag.props).forEach(([key, value]) => {\n      if (key.startsWith(\"on\") && typeof value === \"function\")\n        eventHandlers[key] = value;\n      else\n        props[key] = value;\n    });\n    let delayedSrc;\n    if (mode === \"dom\" && tag.tag === \"script\" && typeof props.src === \"string\" && typeof eventHandlers.onload !== \"undefined\") {\n      delayedSrc = props.src;\n      delete props.src;\n    }\n    return { props, eventHandlers, delayedSrc };\n  };\n  return defineHeadPlugin({\n    hooks: {\n      \"ssr:render\": function(ctx) {\n        ctx.tags = ctx.tags.map((tag) => {\n          if (!ValidEventTags.includes(tag.tag))\n            return tag;\n          if (!Object.entries(tag.props).find(([key, value]) => key.startsWith(\"on\") && typeof value === \"function\"))\n            return tag;\n          tag.props = stripEventHandlers(\"ssr\", tag).props;\n          return tag;\n        });\n      },\n      \"dom:beforeRenderTag\": function(ctx) {\n        if (!ValidEventTags.includes(ctx.tag.tag))\n          return;\n        if (!Object.entries(ctx.tag.props).find(([key, value]) => key.startsWith(\"on\") && typeof value === \"function\"))\n          return;\n        const { props, eventHandlers, delayedSrc } = stripEventHandlers(\"dom\", ctx.tag);\n        if (!Object.keys(eventHandlers).length)\n          return;\n        ctx.tag.props = props;\n        ctx.tag._eventHandlers = eventHandlers;\n        ctx.tag._delayedSrc = delayedSrc;\n      },\n      \"dom:renderTag\": function(ctx) {\n        const $el = ctx.$el;\n        if (!ctx.tag._eventHandlers || !$el)\n          return;\n        const $eventListenerTarget = ctx.tag.tag === \"bodyAttrs\" && typeof window !== \"undefined\" ? window : $el;\n        Object.entries(ctx.tag._eventHandlers).forEach(([k, value]) => {\n          const sdeKey = `${ctx.tag._d || ctx.tag._p}:${k}`;\n          const eventName = k.slice(2).toLowerCase();\n          const eventDedupeKey = `data-h-${eventName}`;\n          ctx.markSideEffect(sdeKey, () => {\n          });\n          if ($el.hasAttribute(eventDedupeKey))\n            return;\n          const handler = value;\n          $el.setAttribute(eventDedupeKey, \"\");\n          $eventListenerTarget.addEventListener(eventName, handler);\n          if (ctx.entry) {\n            ctx.entry._sde[sdeKey] = () => {\n              $eventListenerTarget.removeEventListener(eventName, handler);\n              $el.removeAttribute(eventDedupeKey);\n            };\n          }\n        });\n        if (ctx.tag._delayedSrc) {\n          $el.setAttribute(\"src\", ctx.tag._delayedSrc);\n        }\n      }\n    }\n  });\n}\n\nconst UsesMergeStrategy = [\"templateParams\", \"htmlAttrs\", \"bodyAttrs\"];\nfunction DedupesTagsPlugin() {\n  return defineHeadPlugin({\n    hooks: {\n      \"tag:normalise\": function({ tag }) {\n        [\"hid\", \"vmid\", \"key\"].forEach((key) => {\n          if (tag.props[key]) {\n            tag.key = tag.props[key];\n            delete tag.props[key];\n          }\n        });\n        const generatedKey = tagDedupeKey(tag);\n        const dedupe = generatedKey || (tag.key ? `${tag.tag}:${tag.key}` : false);\n        if (dedupe)\n          tag._d = dedupe;\n      },\n      \"tags:resolve\": function(ctx) {\n        const deduping = {};\n        ctx.tags.forEach((tag) => {\n          const dedupeKey = (tag.key ? `${tag.tag}:${tag.key}` : tag._d) || tag._p;\n          const dupedTag = deduping[dedupeKey];\n          if (dupedTag) {\n            let strategy = tag?.tagDuplicateStrategy;\n            if (!strategy && UsesMergeStrategy.includes(tag.tag))\n              strategy = \"merge\";\n            if (strategy === \"merge\") {\n              const oldProps = dupedTag.props;\n              [\"class\", \"style\"].forEach((key) => {\n                if (tag.props[key] && oldProps[key]) {\n                  if (key === \"style\" && !oldProps[key].endsWith(\";\"))\n                    oldProps[key] += \";\";\n                  tag.props[key] = `${oldProps[key]} ${tag.props[key]}`;\n                }\n              });\n              deduping[dedupeKey].props = {\n                ...oldProps,\n                ...tag.props\n              };\n              return;\n            } else if (tag._e === dupedTag._e) {\n              dupedTag._duped = dupedTag._duped || [];\n              tag._d = `${dupedTag._d}:${dupedTag._duped.length + 1}`;\n              dupedTag._duped.push(tag);\n              return;\n            }\n          }\n          const propCount = Object.keys(tag.props).length + (tag.innerHTML ? 1 : 0) + (tag.textContent ? 1 : 0);\n          if (HasElementTags.includes(tag.tag) && propCount === 0) {\n            delete deduping[dedupeKey];\n            return;\n          }\n          deduping[dedupeKey] = tag;\n        });\n        const newTags = [];\n        Object.values(deduping).forEach((tag) => {\n          const dupes = tag._duped;\n          delete tag._duped;\n          newTags.push(tag);\n          if (dupes)\n            newTags.push(...dupes);\n        });\n        ctx.tags = newTags;\n      }\n    }\n  });\n}\n\nfunction processTemplateParams(s, config) {\n  function sub(token) {\n    if ([\"s\", \"pageTitle\"].includes(token))\n      return config.pageTitle;\n    let val;\n    if (token.includes(\".\")) {\n      val = token.split(\".\").reduce((acc, key) => acc ? acc[key] || void 0 : void 0, config);\n    } else {\n      val = config[token];\n    }\n    return typeof val !== \"undefined\" ? val || \"\" : false;\n  }\n  let decoded = s;\n  try {\n    decoded = decodeURI(s);\n  } catch {\n  }\n  const tokens = (decoded.match(/%(\\w+\\.+\\w+)|%(\\w+)/g) || []).sort().reverse();\n  tokens.forEach((token) => {\n    const re = sub(token.slice(1));\n    if (typeof re === \"string\") {\n      s = s.replace(new RegExp(`\\\\${token}(\\\\W|$)`, \"g\"), `${re}$1`).trim();\n    }\n  });\n  if (config.separator) {\n    if (s.endsWith(config.separator))\n      s = s.slice(0, -config.separator.length).trim();\n    if (s.startsWith(config.separator))\n      s = s.slice(config.separator.length).trim();\n    s = s.replace(new RegExp(`\\\\${config.separator}\\\\s*\\\\${config.separator}`, \"g\"), config.separator);\n  }\n  return s;\n}\nfunction TemplateParamsPlugin() {\n  return defineHeadPlugin({\n    hooks: {\n      \"tags:resolve\": (ctx) => {\n        const { tags } = ctx;\n        const title = tags.find((tag) => tag.tag === \"title\")?.textContent;\n        const idx = tags.findIndex((tag) => tag.tag === \"templateParams\");\n        const params = idx !== -1 ? tags[idx].props : {};\n        params.pageTitle = params.pageTitle || title || \"\";\n        for (const tag of tags) {\n          if ([\"titleTemplate\", \"title\"].includes(tag.tag) && typeof tag.textContent === \"string\") {\n            tag.textContent = processTemplateParams(tag.textContent, params);\n          } else if (tag.tag === \"meta\" && typeof tag.props.content === \"string\") {\n            tag.props.content = processTemplateParams(tag.props.content, params);\n          } else if (tag.tag === \"link\" && typeof tag.props.href === \"string\") {\n            tag.props.href = processTemplateParams(tag.props.href, params);\n          } else if (tag.tag === \"script\" && [\"application/json\", \"application/ld+json\"].includes(tag.props.type) && typeof tag.innerHTML === \"string\") {\n            try {\n              tag.innerHTML = JSON.stringify(JSON.parse(tag.innerHTML), (key, val) => {\n                if (typeof val === \"string\")\n                  return processTemplateParams(val, params);\n                return val;\n              });\n            } catch {\n            }\n          }\n        }\n        ctx.tags = tags.filter((tag) => tag.tag !== \"templateParams\");\n      }\n    }\n  });\n}\n\nconst IsBrowser = typeof window !== \"undefined\";\n\nlet activeHead;\nfunction setActiveHead(head) {\n  return activeHead = head;\n}\nfunction getActiveHead() {\n  return activeHead;\n}\n\nfunction useHead(input, options = {}) {\n  const head = getActiveHead();\n  if (head) {\n    const isBrowser = IsBrowser || head.resolvedOptions?.document;\n    if (options.mode === \"server\" && isBrowser || options.mode === \"client\" && !isBrowser)\n      return;\n    return head.push(input, options);\n  }\n}\n\nfunction useHeadSafe(input, options = {}) {\n  return useHead(input, {\n    ...options || {},\n    transform: whitelistSafeInput\n  });\n}\n\nfunction useServerHead(input, options = {}) {\n  return useHead(input, { ...options, mode: \"server\" });\n}\n\nfunction useServerHeadSafe(input, options = {}) {\n  return useHeadSafe(input, { ...options, mode: \"server\" });\n}\n\nfunction useSeoMeta(input, options) {\n  const { title, titleTemplate, ...meta } = input;\n  return useHead({\n    title,\n    titleTemplate,\n    meta: unpackMeta(meta)\n  }, options);\n}\n\nfunction useServerSeoMeta(input, options) {\n  return useSeoMeta(input, {\n    ...options || {},\n    mode: \"server\"\n  });\n}\n\nfunction useTagTitle(title) {\n  return useHead({ title });\n}\nfunction useTagBase(base) {\n  return useHead({ base });\n}\nfunction useTagMeta(meta) {\n  return useHead({ meta: asArray$1(meta) });\n}\nfunction useTagMetaFlat(meta) {\n  return useTagMeta(unpackMeta(meta));\n}\nfunction useTagLink(link) {\n  return useHead({ link: asArray$1(link) });\n}\nfunction useTagScript(script) {\n  return useHead({ script: asArray$1(script) });\n}\nfunction useTagStyle(style) {\n  return useHead({ style: asArray$1(style) });\n}\nfunction useTagNoscript(noscript) {\n  return useHead({ noscript: asArray$1(noscript) });\n}\nfunction useHtmlAttrs(attrs) {\n  return useHead({ htmlAttrs: attrs });\n}\nfunction useBodyAttrs(attrs) {\n  return useHead({ bodyAttrs: attrs });\n}\nfunction useTitleTemplate(titleTemplate) {\n  return useHead({ titleTemplate });\n}\nfunction useServerTagTitle(title) {\n  return useServerHead({ title });\n}\nfunction useServerTagBase(base) {\n  return useServerHead({ base });\n}\nfunction useServerTagMeta(meta) {\n  return useServerHead({ meta: asArray$1(meta) });\n}\nfunction useServerTagMetaFlat(meta) {\n  return useServerTagMeta(unpackMeta(meta));\n}\nfunction useServerTagLink(link) {\n  return useServerHead({ link: asArray$1(link) });\n}\nfunction useServerTagScript(script) {\n  return useServerHead({ script: asArray$1(script) });\n}\nfunction useServerTagStyle(style) {\n  return useServerHead({ style: asArray$1(style) });\n}\nfunction useServerTagNoscript(noscript) {\n  return useServerHead({ noscript: asArray$1(noscript) });\n}\nfunction useServerHtmlAttrs(attrs) {\n  return useServerHead({ htmlAttrs: attrs });\n}\nfunction useServerBodyAttrs(attrs) {\n  return useServerHead({ bodyAttrs: attrs });\n}\nfunction useServerTitleTemplate(titleTemplate) {\n  return useServerHead({ titleTemplate });\n}\n\nfunction asArray(input) {\n  return Array.isArray(input) ? input : [input];\n}\nconst InternalKeySymbol = \"_$key\";\nfunction packObject(input, options) {\n  const keys = Object.keys(input);\n  let [k, v] = keys;\n  options = options || {};\n  options.key = options.key || k;\n  options.value = options.value || v;\n  options.resolveKey = options.resolveKey || ((k2) => k2);\n  const resolveKey = (index) => {\n    const arr = asArray(options?.[index]);\n    return arr.find((k2) => {\n      if (typeof k2 === \"string\" && k2.includes(\".\")) {\n        return k2;\n      }\n      return k2 && keys.includes(k2);\n    });\n  };\n  const resolveValue = (k2, input2) => {\n    if (k2.includes(\".\")) {\n      const paths = k2.split(\".\");\n      let val = input2;\n      for (const path of paths)\n        val = val[path];\n      return val;\n    }\n    return input2[k2];\n  };\n  k = resolveKey(\"key\") || k;\n  v = resolveKey(\"value\") || v;\n  const dedupeKeyPrefix = input.key ? `${InternalKeySymbol}${input.key}-` : \"\";\n  let keyValue = resolveValue(k, input);\n  keyValue = options.resolveKey(keyValue);\n  return {\n    [`${dedupeKeyPrefix}${keyValue}`]: resolveValue(v, input)\n  };\n}\n\nfunction packArray(input, options) {\n  const packed = {};\n  for (const i of input) {\n    const packedObj = packObject(i, options);\n    const pKey = Object.keys(packedObj)[0];\n    const isDedupeKey = pKey.startsWith(InternalKeySymbol);\n    if (!isDedupeKey && packed[pKey]) {\n      packed[pKey] = Array.isArray(packed[pKey]) ? packed[pKey] : [packed[pKey]];\n      packed[pKey].push(Object.values(packedObj)[0]);\n    } else {\n      packed[isDedupeKey ? pKey.split(\"-\").slice(1).join(\"-\") || pKey : pKey] = packedObj[pKey];\n    }\n  }\n  return packed;\n}\n\nfunction unpackToArray(input, options) {\n  const unpacked = [];\n  const kFn = options.resolveKeyData || ((ctx) => ctx.key);\n  const vFn = options.resolveValueData || ((ctx) => ctx.value);\n  for (const [k, v] of Object.entries(input)) {\n    unpacked.push(...(Array.isArray(v) ? v : [v]).map((i) => {\n      const ctx = { key: k, value: i };\n      const val = vFn(ctx);\n      if (typeof val === \"object\")\n        return unpackToArray(val, options);\n      if (Array.isArray(val))\n        return val;\n      return {\n        [typeof options.key === \"function\" ? options.key(ctx) : options.key]: kFn(ctx),\n        [typeof options.value === \"function\" ? options.value(ctx) : options.value]: val\n      };\n    }).flat());\n  }\n  return unpacked;\n}\n\nfunction unpackToString(value, options) {\n  return Object.entries(value).map(([key, value2]) => {\n    if (typeof value2 === \"object\")\n      value2 = unpackToString(value2, options);\n    if (options.resolve) {\n      const resolved = options.resolve({ key, value: value2 });\n      if (resolved)\n        return resolved;\n    }\n    if (typeof value2 === \"number\")\n      value2 = value2.toString();\n    if (typeof value2 === \"string\" && options.wrapValue) {\n      value2 = value2.replace(new RegExp(options.wrapValue, \"g\"), `\\\\${options.wrapValue}`);\n      value2 = `${options.wrapValue}${value2}${options.wrapValue}`;\n    }\n    return `${key}${options.keyValueSeparator || \"\"}${value2}`;\n  }).join(options.entrySeparator || \"\");\n}\n\nconst MetaPackingSchema = {\n  robots: {\n    unpack: {\n      keyValueSeparator: \":\"\n    }\n  },\n  // Pragma directives\n  contentSecurityPolicy: {\n    unpack: {\n      keyValueSeparator: \" \",\n      entrySeparator: \"; \"\n    },\n    metaKey: \"http-equiv\"\n  },\n  fbAppId: {\n    keyValue: \"fb:app_id\",\n    metaKey: \"property\"\n  },\n  ogSiteName: {\n    keyValue: \"og:site_name\"\n  },\n  msapplicationTileImage: {\n    keyValue: \"msapplication-TileImage\"\n  },\n  /**\n   * Tile colour for windows\n   */\n  msapplicationTileColor: {\n    keyValue: \"msapplication-TileColor\"\n  },\n  /**\n   * URL of a config for windows tile.\n   */\n  msapplicationConfig: {\n    keyValue: \"msapplication-Config\"\n  },\n  charset: {\n    metaKey: \"charset\"\n  },\n  contentType: {\n    metaKey: \"http-equiv\"\n  },\n  defaultStyle: {\n    metaKey: \"http-equiv\"\n  },\n  xUaCompatible: {\n    metaKey: \"http-equiv\"\n  },\n  refresh: {\n    metaKey: \"http-equiv\"\n  }\n};\n\nfunction packMeta(inputs) {\n  const mappedPackingSchema = Object.entries(MetaPackingSchema).map(([key, value]) => [key, value.keyValue]);\n  return packArray(inputs, {\n    key: [\"name\", \"property\", \"httpEquiv\", \"http-equiv\", \"charset\"],\n    value: [\"content\", \"charset\"],\n    resolveKey(k) {\n      let key = mappedPackingSchema.filter((sk) => sk[1] === k)?.[0]?.[0] || k;\n      const replacer = (_, letter) => letter?.toUpperCase();\n      key = key.replace(/:([a-z])/g, replacer).replace(/-([a-z])/g, replacer);\n      return key;\n    }\n  });\n}\n\nconst ArrayableInputs = [\"Image\", \"Video\", \"Audio\"];\nconst ColonPrefixKeys = /^(og|twitter|fb)/;\nconst PropertyPrefixKeys = /^(og|fb)/;\nfunction resolveMetaKeyType(key) {\n  return PropertyPrefixKeys.test(key) ? \"property\" : MetaPackingSchema[key]?.metaKey || \"name\";\n}\nfunction resolveMetaKeyValue(key) {\n  return MetaPackingSchema[key]?.keyValue || fixKeyCase(key);\n}\nfunction fixKeyCase(key) {\n  key = key.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n  if (ColonPrefixKeys.test(key)) {\n    key = key.replace(\"secure-url\", \"secure_url\").replace(/-/g, \":\");\n  }\n  return key;\n}\nfunction changeKeyCasingDeep(input) {\n  if (Array.isArray(input)) {\n    return input.map((entry) => changeKeyCasingDeep(entry));\n  }\n  if (typeof input !== \"object\" || Array.isArray(input))\n    return input;\n  const output = {};\n  for (const [key, value] of Object.entries(input))\n    output[fixKeyCase(key)] = changeKeyCasingDeep(value);\n  return output;\n}\nfunction unpackMeta(input) {\n  const extras = [];\n  ArrayableInputs.forEach((key) => {\n    const ogKey = `og:${key.toLowerCase()}`;\n    const inputKey = `og${key}`;\n    const val = input[inputKey];\n    if (typeof val === \"object\") {\n      (Array.isArray(val) ? val : [val]).forEach((entry) => {\n        if (!entry)\n          return;\n        const unpackedEntry = unpackToArray(entry, {\n          key: \"property\",\n          value: \"content\",\n          resolveKeyData({ key: key2 }) {\n            return fixKeyCase(`${ogKey}${key2 !== \"url\" ? `:${key2}` : \"\"}`);\n          },\n          resolveValueData({ value }) {\n            return typeof value === \"number\" ? value.toString() : value;\n          }\n        });\n        extras.push(\n          ...unpackedEntry.sort((a, b) => a.property === ogKey ? -1 : b.property === ogKey ? 1 : 0)\n        );\n      });\n      delete input[inputKey];\n    }\n  });\n  const meta = unpackToArray(input, {\n    key({ key }) {\n      return resolveMetaKeyType(key);\n    },\n    value({ key }) {\n      return key === \"charset\" ? \"charset\" : \"content\";\n    },\n    resolveKeyData({ key }) {\n      return resolveMetaKeyValue(key);\n    },\n    resolveValueData({ value, key }) {\n      if (value === null)\n        return \"_null\";\n      if (typeof value === \"object\")\n        return resolvePackedMetaObjectValue(value, key);\n      return typeof value === \"number\" ? value.toString() : value;\n    }\n  });\n  return [...extras, ...meta].filter((v) => typeof v.content === \"undefined\" || v.content !== \"_null\");\n}\nfunction resolvePackedMetaObjectValue(value, key) {\n  const definition = MetaPackingSchema[key];\n  if (key === \"refresh\")\n    return `${value.seconds};url=${value.url}`;\n  return unpackToString(\n    changeKeyCasingDeep(value),\n    {\n      entrySeparator: \", \",\n      keyValueSeparator: \"=\",\n      resolve({ value: value2, key: key2 }) {\n        if (value2 === null)\n          return \"\";\n        if (typeof value2 === \"boolean\")\n          return `${key2}`;\n      },\n      ...definition?.unpack\n    }\n  );\n}\n\nasync function normaliseTag(tagName, input) {\n  const tag = { tag: tagName, props: {} };\n  if (tagName === \"templateParams\") {\n    tag.props = input;\n    return tag;\n  }\n  if ([\"title\", \"titleTemplate\"].includes(tagName)) {\n    tag.textContent = input instanceof Promise ? await input : input;\n    return tag;\n  }\n  if (typeof input === \"string\") {\n    if (![\"script\", \"noscript\", \"style\"].includes(tagName))\n      return false;\n    if (tagName === \"script\" && (/^(https?:)?\\/\\//.test(input) || input.startsWith(\"/\")))\n      tag.props.src = input;\n    else\n      tag.innerHTML = input;\n    return tag;\n  }\n  tag.props = await normaliseProps(tagName, { ...input });\n  if (tag.props.children) {\n    tag.props.innerHTML = tag.props.children;\n  }\n  delete tag.props.children;\n  Object.keys(tag.props).filter((k) => TagConfigKeys.includes(k)).forEach((k) => {\n    if (![\"innerHTML\", \"textContent\"].includes(k) || TagsWithInnerContent.includes(tag.tag)) {\n      tag[k] = tag.props[k];\n    }\n    delete tag.props[k];\n  });\n  [\"innerHTML\", \"textContent\"].forEach((k) => {\n    if (tag.tag === \"script\" && typeof tag[k] === \"string\" && [\"application/ld+json\", \"application/json\"].includes(tag.props.type)) {\n      try {\n        tag[k] = JSON.parse(tag[k]);\n      } catch (e) {\n        tag[k] = \"\";\n      }\n    }\n    if (typeof tag[k] === \"object\")\n      tag[k] = JSON.stringify(tag[k]);\n  });\n  if (tag.props.class)\n    tag.props.class = normaliseClassProp(tag.props.class);\n  if (tag.props.content && Array.isArray(tag.props.content))\n    return tag.props.content.map((v) => ({ ...tag, props: { ...tag.props, content: v } }));\n  return tag;\n}\nfunction normaliseClassProp(v) {\n  if (typeof v === \"object\" && !Array.isArray(v)) {\n    v = Object.keys(v).filter((k) => v[k]);\n  }\n  return (Array.isArray(v) ? v.join(\" \") : v).split(\" \").filter((c) => c.trim()).filter(Boolean).join(\" \");\n}\nasync function normaliseProps(tagName, props) {\n  for (const k of Object.keys(props)) {\n    const isDataKey = k.startsWith(\"data-\");\n    if (props[k] instanceof Promise) {\n      props[k] = await props[k];\n    }\n    if (String(props[k]) === \"true\") {\n      props[k] = isDataKey ? \"true\" : \"\";\n    } else if (String(props[k]) === \"false\") {\n      if (isDataKey) {\n        props[k] = \"false\";\n      } else {\n        delete props[k];\n      }\n    }\n  }\n  return props;\n}\nconst TagEntityBits = 10;\nasync function normaliseEntryTags(e) {\n  const tagPromises = [];\n  Object.entries(e.resolvedInput).filter(([k, v]) => typeof v !== \"undefined\" && ValidHeadTags.includes(k)).forEach(([k, value]) => {\n    const v = asArray$1(value);\n    tagPromises.push(...v.map((props) => normaliseTag(k, props)).flat());\n  });\n  return (await Promise.all(tagPromises)).flat().filter(Boolean).map((t, i) => {\n    t._e = e._i;\n    t._p = (e._i << TagEntityBits) + i;\n    return t;\n  });\n}\n\nconst WhitelistAttributes = {\n  htmlAttrs: [\"id\", \"class\", \"lang\", \"dir\"],\n  bodyAttrs: [\"id\", \"class\"],\n  meta: [\"id\", \"name\", \"property\", \"charset\", \"content\"],\n  noscript: [\"id\", \"textContent\"],\n  script: [\"id\", \"type\", \"textContent\"],\n  link: [\"id\", \"color\", \"crossorigin\", \"fetchpriority\", \"href\", \"hreflang\", \"imagesrcset\", \"imagesizes\", \"integrity\", \"media\", \"referrerpolicy\", \"rel\", \"sizes\", \"type\"]\n};\nfunction whitelistSafeInput(input) {\n  const filtered = {};\n  Object.keys(input).forEach((key) => {\n    const tagValue = input[key];\n    if (!tagValue)\n      return;\n    switch (key) {\n      case \"title\":\n      case \"titleTemplate\":\n      case \"templateParams\":\n        filtered[key] = tagValue;\n        break;\n      case \"htmlAttrs\":\n      case \"bodyAttrs\":\n        filtered[key] = {};\n        WhitelistAttributes[key].forEach((a) => {\n          if (tagValue[a])\n            filtered[key][a] = tagValue[a];\n        });\n        Object.keys(tagValue || {}).filter((a) => a.startsWith(\"data-\")).forEach((a) => {\n          filtered[key][a] = tagValue[a];\n        });\n        break;\n      case \"meta\":\n        if (Array.isArray(tagValue)) {\n          filtered[key] = tagValue.map((meta) => {\n            const safeMeta = {};\n            WhitelistAttributes.meta.forEach((key2) => {\n              if (meta[key2] || key2.startsWith(\"data-\"))\n                safeMeta[key2] = meta[key2];\n            });\n            return safeMeta;\n          }).filter((meta) => Object.keys(meta).length > 0);\n        }\n        break;\n      case \"link\":\n        if (Array.isArray(tagValue)) {\n          filtered[key] = tagValue.map((meta) => {\n            const link = {};\n            WhitelistAttributes.link.forEach((key2) => {\n              if (key2 === \"rel\" && [\"stylesheet\", \"canonical\", \"modulepreload\", \"prerender\", \"preload\", \"prefetch\"].includes(meta[key2]))\n                return;\n              if (key2 === \"href\") {\n                try {\n                  const url = new URL(meta[key2]);\n                  if ([\"javascript:\", \"data:\"].includes(url.protocol))\n                    return;\n                  link[key2] = meta[key2];\n                } catch (e) {\n                }\n              } else if (meta[key2] || key2.startsWith(\"data-\")) {\n                link[key2] = meta[key2];\n              }\n            });\n            return link;\n          }).filter((link) => Object.keys(link).length > 1 && !!link.rel);\n        }\n        break;\n      case \"noscript\":\n        if (Array.isArray(tagValue)) {\n          filtered[key] = tagValue.map((meta) => {\n            const noscript = {};\n            WhitelistAttributes.noscript.forEach((key2) => {\n              if (meta[key2] || key2.startsWith(\"data-\"))\n                noscript[key2] = meta[key2];\n            });\n            return noscript;\n          }).filter((meta) => Object.keys(meta).length > 0);\n        }\n        break;\n      case \"script\":\n        if (Array.isArray(tagValue)) {\n          filtered[key] = tagValue.map((script) => {\n            const safeScript = {};\n            WhitelistAttributes.script.forEach((s) => {\n              if (script[s] || s.startsWith(\"data-\")) {\n                if (s === \"textContent\") {\n                  try {\n                    const jsonVal = typeof script[s] === \"string\" ? JSON.parse(script[s]) : script[s];\n                    safeScript[s] = JSON.stringify(jsonVal, null, 0);\n                  } catch (e) {\n                  }\n                } else {\n                  safeScript[s] = script[s];\n                }\n              }\n            });\n            return safeScript;\n          }).filter((meta) => Object.keys(meta).length > 0);\n        }\n        break;\n    }\n  });\n  return filtered;\n}\n\nfunction CorePlugins() {\n  return [\n    // dedupe needs to come first\n    DedupesTagsPlugin(),\n    SortTagsPlugin(),\n    TemplateParamsPlugin(),\n    TitleTemplatePlugin(),\n    ProvideTagHashPlugin(),\n    EventHandlersPlugin(),\n    DeprecatedTagAttrPlugin()\n  ];\n}\nfunction DOMPlugins(options = {}) {\n  return [\n    PatchDomOnEntryUpdatesPlugin({ document: options?.document, delayFn: options?.domDelayFn })\n  ];\n}\nfunction createHead(options = {}) {\n  const head = createHeadCore({\n    ...options,\n    plugins: [...DOMPlugins(options), ...options?.plugins || []]\n  });\n  if (options.experimentalHashHydration && head.resolvedOptions.document)\n    head._hash = maybeGetSSRHash(head.resolvedOptions.document);\n  setActiveHead(head);\n  return head;\n}\nfunction createServerHead(options = {}) {\n  const head = createHeadCore(options);\n  setActiveHead(head);\n  return head;\n}\nfunction createHeadCore(options = {}) {\n  let entries = [];\n  let _sde = {};\n  let _eid = 0;\n  const hooks = createHooks();\n  if (options?.hooks)\n    hooks.addHooks(options.hooks);\n  options.plugins = [\n    ...CorePlugins(),\n    ...options?.plugins || []\n  ];\n  options.plugins.forEach((p) => p.hooks && hooks.addHooks(p.hooks));\n  options.document = options.document || (IsBrowser ? document : void 0);\n  const updated = () => hooks.callHook(\"entries:updated\", head);\n  const head = {\n    resolvedOptions: options,\n    headEntries() {\n      return entries;\n    },\n    get hooks() {\n      return hooks;\n    },\n    use(plugin) {\n      if (plugin.hooks)\n        hooks.addHooks(plugin.hooks);\n    },\n    push(input, options2) {\n      const activeEntry = {\n        _i: _eid++,\n        input,\n        _sde: {}\n      };\n      if (options2?.mode)\n        activeEntry._m = options2?.mode;\n      if (options2?.transform) {\n        activeEntry._t = options2?.transform;\n      }\n      entries.push(activeEntry);\n      updated();\n      return {\n        dispose() {\n          entries = entries.filter((e) => {\n            if (e._i !== activeEntry._i)\n              return true;\n            _sde = { ..._sde, ...e._sde || {} };\n            e._sde = {};\n            updated();\n            return false;\n          });\n        },\n        // a patch is the same as creating a new entry, just a nice DX\n        patch(input2) {\n          entries = entries.map((e) => {\n            if (e._i === activeEntry._i) {\n              activeEntry.input = e.input = input2;\n              updated();\n            }\n            return e;\n          });\n        }\n      };\n    },\n    async resolveTags() {\n      const resolveCtx = { tags: [], entries: [...entries] };\n      await hooks.callHook(\"entries:resolve\", resolveCtx);\n      for (const entry of resolveCtx.entries) {\n        const transformer = entry._t || ((i) => i);\n        entry.resolvedInput = transformer(entry.resolvedInput || entry.input);\n        if (entry.resolvedInput) {\n          for (const tag of await normaliseEntryTags(entry)) {\n            const tagCtx = { tag, entry, resolvedOptions: head.resolvedOptions };\n            await hooks.callHook(\"tag:normalise\", tagCtx);\n            resolveCtx.tags.push(tagCtx.tag);\n          }\n        }\n      }\n      await hooks.callHook(\"tags:resolve\", resolveCtx);\n      return resolveCtx.tags;\n    },\n    _popSideEffectQueue() {\n      const sde = { ..._sde };\n      _sde = {};\n      return sde;\n    },\n    _elMap: {}\n  };\n  head.hooks.callHook(\"init\", head);\n  return head;\n}\n\nconst coreComposableNames = [\n  \"getActiveHead\"\n];\nconst composableNames = [\n  \"useHead\",\n  \"useSeoMeta\",\n  \"useHeadSafe\",\n  \"useServerHead\",\n  \"useServerSeoMeta\",\n  \"useServerHeadSafe\",\n  // deprecated\n  \"useTagTitle\",\n  \"useTagBase\",\n  \"useTagMeta\",\n  \"useTagMetaFlat\",\n  \"useTagLink\",\n  \"useTagScript\",\n  \"useTagStyle\",\n  \"useTagNoscript\",\n  \"useHtmlAttrs\",\n  \"useBodyAttrs\",\n  \"useTitleTemplate\",\n  \"useServerTagTitle\",\n  \"useServerTagBase\",\n  \"useServerTagMeta\",\n  \"useServerTagMetaFlat\",\n  \"useServerTagLink\",\n  \"useServerTagScript\",\n  \"useServerTagStyle\",\n  \"useServerTagNoscript\",\n  \"useServerHtmlAttrs\",\n  \"useServerBodyAttrs\",\n  \"useServerTitleTemplate\"\n];\nconst unheadComposablesImports = [\n  {\n    from: \"unhead\",\n    imports: [...coreComposableNames, ...composableNames]\n  }\n];\n\nexport { CorePlugins, DOMPlugins, DedupesTagsPlugin, DeprecatedTagAttrPlugin, EventHandlersPlugin, ProvideTagHashPlugin, SortModifiers, SortTagsPlugin, TAG_WEIGHTS, TagEntityBits, TemplateParamsPlugin, TitleTemplatePlugin, activeHead, composableNames, createHead, createHeadCore, createServerHead, getActiveHead, normaliseClassProp, normaliseEntryTags, normaliseProps, normaliseTag, packMeta, processTemplateParams, resolveMetaKeyType, resolveMetaKeyValue, resolvePackedMetaObjectValue, setActiveHead, tagWeight, unheadComposablesImports, unpackMeta, useBodyAttrs, useHead, useHeadSafe, useHtmlAttrs, useSeoMeta, useServerBodyAttrs, useServerHead, useServerHeadSafe, useServerHtmlAttrs, useServerSeoMeta, useServerTagBase, useServerTagLink, useServerTagMeta, useServerTagMetaFlat, useServerTagNoscript, useServerTagScript, useServerTagStyle, useServerTagTitle, useServerTitleTemplate, useTagBase, useTagLink, useTagMeta, useTagMetaFlat, useTagNoscript, useTagScript, useTagStyle, useTagTitle, useTitleTemplate, whitelistSafeInput };\n","import { unref, version, getCurrentInstance, inject, nextTick, ref, watchEffect, watch, onBeforeUnmount, onDeactivated, onActivated } from 'vue';\nimport { getActiveHead, createServerHead as createServerHead$1, createHead as createHead$1 } from 'unhead';\nimport { defineHeadPlugin } from '@unhead/shared';\n\nfunction resolveUnref(r) {\n  return typeof r === \"function\" ? r() : unref(r);\n}\nfunction resolveUnrefHeadInput(ref, lastKey = \"\") {\n  if (ref instanceof Promise)\n    return ref;\n  const root = resolveUnref(ref);\n  if (!ref || !root)\n    return root;\n  if (Array.isArray(root))\n    return root.map((r) => resolveUnrefHeadInput(r, lastKey));\n  if (typeof root === \"object\") {\n    return Object.fromEntries(\n      Object.entries(root).map(([k, v]) => {\n        if (k === \"titleTemplate\" || k.startsWith(\"on\"))\n          return [k, unref(v)];\n        return [k, resolveUnrefHeadInput(v, k)];\n      })\n    );\n  }\n  return root;\n}\n\nconst Vue3 = version.startsWith(\"3\");\nconst IsBrowser = typeof window !== \"undefined\";\n\nconst headSymbol = \"usehead\";\nfunction injectHead() {\n  return getCurrentInstance() && inject(headSymbol) || getActiveHead();\n}\nfunction vueInstall(head) {\n  const plugin = {\n    install(app) {\n      if (Vue3) {\n        app.config.globalProperties.$unhead = head;\n        app.config.globalProperties.$head = head;\n        app.provide(headSymbol, head);\n      }\n    }\n  };\n  return plugin.install;\n}\nfunction createServerHead(options = {}) {\n  const head = createServerHead$1({\n    ...options,\n    plugins: [\n      VueReactiveUseHeadPlugin(),\n      ...options?.plugins || []\n    ]\n  });\n  head.install = vueInstall(head);\n  return head;\n}\nfunction createHead(options = {}) {\n  const head = createHead$1({\n    ...options,\n    // arbitrary delay the dom update for batch updates\n    domDelayFn: (fn) => setTimeout(() => nextTick(() => fn()), 10),\n    plugins: [\n      VueReactiveUseHeadPlugin(),\n      ...options?.plugins || []\n    ]\n  });\n  head.install = vueInstall(head);\n  return head;\n}\n\nfunction VueReactiveUseHeadPlugin() {\n  return defineHeadPlugin({\n    hooks: {\n      \"entries:resolve\": function(ctx) {\n        for (const entry of ctx.entries)\n          entry.resolvedInput = resolveUnrefHeadInput(entry.input);\n      }\n    }\n  });\n}\n\nfunction clientUseHead(input, options = {}) {\n  const head = injectHead();\n  const deactivated = ref(false);\n  const resolvedInput = ref({});\n  watchEffect(() => {\n    resolvedInput.value = deactivated.value ? {} : resolveUnrefHeadInput(input);\n  });\n  const entry = head.push(resolvedInput.value, options);\n  watch(resolvedInput, (e) => {\n    entry.patch(e);\n  });\n  const vm = getCurrentInstance();\n  if (vm) {\n    onBeforeUnmount(() => {\n      entry.dispose();\n    });\n    onDeactivated(() => {\n      deactivated.value = true;\n    });\n    onActivated(() => {\n      deactivated.value = false;\n    });\n  }\n  return entry;\n}\n\nfunction serverUseHead(input, options = {}) {\n  const head = injectHead();\n  return head.push(input, options);\n}\n\nfunction useHead(input, options = {}) {\n  const head = injectHead();\n  if (head) {\n    const isBrowser = IsBrowser || !!head.resolvedOptions?.document;\n    if (options.mode === \"server\" && isBrowser || options.mode === \"client\" && !isBrowser)\n      return;\n    return isBrowser ? clientUseHead(input, options) : serverUseHead(input, options);\n  }\n}\n\nexport { VueReactiveUseHeadPlugin as V, createHead as a, createServerHead as c, headSymbol as h, injectHead as i, resolveUnrefHeadInput as r, serverUseHead as s, useHead as u };\n","import { whitelistSafeInput, unpackMeta, composableNames } from 'unhead';\nexport { createHeadCore } from 'unhead';\nimport { u as useHead, h as headSymbol, r as resolveUnrefHeadInput, s as serverUseHead } from './shared/vue.505b826e.mjs';\nexport { V as VueReactiveUseHeadPlugin, a as createHead, c as createServerHead, i as injectHead } from './shared/vue.505b826e.mjs';\nimport { getCurrentInstance, ref, watchEffect } from 'vue';\nimport { asArray } from '@unhead/shared';\n\nconst VueHeadMixin = {\n  created() {\n    const instance = getCurrentInstance();\n    if (!instance)\n      return;\n    const options = instance.type;\n    if (!options || !(\"head\" in options))\n      return;\n    const source = typeof options.head === \"function\" ? () => options.head.call(instance.proxy) : options.head;\n    useHead(source);\n  }\n};\n\nconst Vue2ProvideUnheadPlugin = function(_Vue, head) {\n  _Vue.mixin({\n    beforeCreate() {\n      const options = this.$options;\n      const origProvide = options.provide;\n      options.provide = function() {\n        let origProvideResult;\n        if (typeof origProvide === \"function\")\n          origProvideResult = origProvide.call(this);\n        else\n          origProvideResult = origProvide || {};\n        return {\n          ...origProvideResult,\n          [headSymbol]: head\n        };\n      };\n    }\n  });\n};\n\nfunction useHeadSafe(input, options = {}) {\n  return useHead(input, { ...options, transform: whitelistSafeInput });\n}\n\nfunction useSeoMeta(input, options) {\n  const headInput = ref({});\n  watchEffect(() => {\n    const resolvedMeta = resolveUnrefHeadInput(input);\n    const { title, titleTemplate, ...meta } = resolvedMeta;\n    headInput.value = {\n      title,\n      titleTemplate,\n      meta: unpackMeta(meta)\n    };\n  });\n  return useHead(headInput, options);\n}\n\nfunction useServerHead(input, options = {}) {\n  return serverUseHead(input, { ...options, mode: \"server\" });\n}\n\nfunction useServerHeadSafe(input, options = {}) {\n  return useHeadSafe(input, { ...options, mode: \"server\" });\n}\n\nfunction useServerSeoMeta(input, options) {\n  return useSeoMeta(input, { ...options || {}, mode: \"server\" });\n}\n\nfunction useTagTitle(title) {\n  return useHead({ title });\n}\nfunction useTitleTemplate(titleTemplate) {\n  return useHead({ titleTemplate });\n}\nfunction useTagMeta(meta) {\n  return useHead({ meta: asArray(meta) });\n}\nfunction useTagMetaFlat(meta) {\n  const input = ref({});\n  watchEffect(() => {\n    input.value = unpackMeta(resolveUnrefHeadInput(meta));\n  });\n  return useHead({ meta: input });\n}\nfunction useTagLink(link) {\n  return useHead({ link: asArray(link) });\n}\nfunction useTagScript(script) {\n  return useHead({ script: asArray(script) });\n}\nfunction useTagStyle(style) {\n  return useHead({ style: asArray(style) });\n}\nfunction useTagNoscript(noscript) {\n  return useHead({ noscript: asArray(noscript) });\n}\nfunction useTagBase(base) {\n  return useHead({ base });\n}\nfunction useHtmlAttrs(attrs) {\n  return useHead({ htmlAttrs: attrs });\n}\nfunction useBodyAttrs(attrs) {\n  return useHead({ bodyAttrs: attrs });\n}\nfunction useServerTagTitle(title) {\n  return useServerHead({ title });\n}\nfunction useServerTitleTemplate(titleTemplate) {\n  return useServerHead({ titleTemplate });\n}\nfunction useServerTagMeta(meta) {\n  return useServerHead({ meta: asArray(meta) });\n}\nfunction useServerTagMetaFlat(meta) {\n  const input = ref({});\n  watchEffect(() => {\n    input.value = unpackMeta(resolveUnrefHeadInput(meta));\n  });\n  return useServerHead({ meta: input });\n}\nfunction useServerTagLink(link) {\n  return useServerHead({ link: asArray(link) });\n}\nfunction useServerTagScript(script) {\n  return useServerHead({ script: asArray(script) });\n}\nfunction useServerTagStyle(style) {\n  return useServerHead({ style: asArray(style) });\n}\nfunction useServerTagNoscript(noscript) {\n  return useServerHead({ noscript: asArray(noscript) });\n}\nfunction useServerTagBase(base) {\n  return useServerHead({ base });\n}\nfunction useServerHtmlAttrs(attrs) {\n  return useServerHead({ htmlAttrs: attrs });\n}\nfunction useServerBodyAttrs(attrs) {\n  return useHead({ bodyAttrs: attrs });\n}\n\nconst coreComposableNames = [\n  \"injectHead\"\n];\nconst unheadVueComposablesImports = {\n  \"@unhead/vue\": [...coreComposableNames, ...composableNames]\n};\n\nexport { Vue2ProvideUnheadPlugin, VueHeadMixin, headSymbol, resolveUnrefHeadInput, unheadVueComposablesImports, useBodyAttrs, useHead, useHeadSafe, useHtmlAttrs, useSeoMeta, useServerBodyAttrs, useServerHead, useServerHeadSafe, useServerHtmlAttrs, useServerSeoMeta, useServerTagBase, useServerTagLink, useServerTagMeta, useServerTagMetaFlat, useServerTagNoscript, useServerTagScript, useServerTagStyle, useServerTagTitle, useServerTitleTemplate, useTagBase, useTagLink, useTagMeta, useTagMetaFlat, useTagNoscript, useTagScript, useTagStyle, useTagTitle, useTitleTemplate };\n","import { createHead as createHead$1, useHead, Vue2ProvideUnheadPlugin, injectHead } from '@unhead/vue';\nexport { Vue2ProvideUnheadPlugin, VueHeadMixin, createHeadCore, injectHead, unheadVueComposablesImports, useBodyAttrs, useHead, useHeadSafe, useHtmlAttrs, useSeoMeta, useServerBodyAttrs, useServerHead, useServerHeadSafe, useServerHtmlAttrs, useServerSeoMeta, useServerTagBase, useServerTagLink, useServerTagMeta, useServerTagMetaFlat, useServerTagNoscript, useServerTagScript, useServerTagStyle, useServerTagTitle, useServerTitleTemplate, useTagBase, useTagLink, useTagMeta, useTagMetaFlat, useTagNoscript, useTagScript, useTagStyle, useTagTitle, useTitleTemplate } from '@unhead/vue';\nimport { renderDOMHead, debouncedRenderDOMHead } from '@unhead/dom';\nimport { version, defineComponent, ref, onBeforeUnmount, watchEffect } from 'vue';\nimport { renderSSRHead } from '@unhead/ssr';\n\nfunction createHead(initHeadObject, options) {\n  const unhead = createHead$1(options || {});\n  const legacyHead = {\n    unhead,\n    install(app) {\n      if (version.startsWith(\"3\")) {\n        app.config.globalProperties.$head = unhead;\n        app.provide(\"usehead\", unhead);\n      }\n    },\n    use(plugin) {\n      unhead.use(plugin);\n    },\n    resolveTags() {\n      return unhead.resolveTags();\n    },\n    headEntries() {\n      return unhead.headEntries();\n    },\n    headTags() {\n      return unhead.resolveTags();\n    },\n    push(input, options2) {\n      return unhead.push(input, options2);\n    },\n    addEntry(input, options2) {\n      return unhead.push(input, options2);\n    },\n    addHeadObjs(input, options2) {\n      return unhead.push(input, options2);\n    },\n    addReactiveEntry(input, options2) {\n      const api = useHead(input, options2);\n      if (typeof api !== \"undefined\")\n        return api.dispose;\n      return () => {\n      };\n    },\n    removeHeadObjs() {\n    },\n    updateDOM(document, force) {\n      if (force)\n        renderDOMHead(unhead, { document });\n      else\n        debouncedRenderDOMHead(unhead, { delayFn: (fn) => setTimeout(() => fn(), 50), document });\n    },\n    internalHooks: unhead.hooks,\n    hooks: {\n      \"before:dom\": [],\n      \"resolved:tags\": [],\n      \"resolved:entries\": []\n    }\n  };\n  unhead.addHeadObjs = legacyHead.addHeadObjs;\n  unhead.updateDOM = legacyHead.updateDOM;\n  unhead.hooks.hook(\"dom:beforeRender\", (ctx) => {\n    for (const hook of legacyHead.hooks[\"before:dom\"]) {\n      if (hook() === false)\n        ctx.shouldRender = false;\n    }\n  });\n  if (initHeadObject)\n    legacyHead.addHeadObjs(initHeadObject);\n  return legacyHead;\n}\n\nconst HeadVuePlugin = Vue2ProvideUnheadPlugin;\nconst renderHeadToString = (head) => renderSSRHead(head.unhead);\n\nconst Vue2 = version.startsWith(\"2.\");\nconst IsBrowser = typeof window !== \"undefined\";\n\nconst addVNodeToHeadObj = (node, obj) => {\n  const nodeType = Vue2 ? node.tag : node.type;\n  const type = nodeType === \"html\" ? \"htmlAttrs\" : nodeType === \"body\" ? \"bodyAttrs\" : nodeType;\n  if (typeof type !== \"string\" || !(type in obj))\n    return;\n  const nodeData = Vue2 ? node.data : node;\n  const props = (Vue2 ? nodeData.attrs : node.props) || {};\n  if (Vue2) {\n    if (nodeData.staticClass)\n      props.class = nodeData.staticClass;\n    if (nodeData.staticStyle)\n      props.style = Object.entries(nodeData.staticStyle).map(([key, value]) => `${key}:${value}`).join(\";\");\n  }\n  if (node.children) {\n    const childrenAttr = Vue2 ? \"text\" : \"children\";\n    props.children = Array.isArray(node.children) ? node.children[0][childrenAttr] : node[childrenAttr];\n  }\n  if (Array.isArray(obj[type]))\n    obj[type].push(props);\n  else if (type === \"title\")\n    obj.title = props.children;\n  else\n    obj[type] = props;\n};\nconst vnodesToHeadObj = (nodes) => {\n  const obj = {\n    title: void 0,\n    htmlAttrs: void 0,\n    bodyAttrs: void 0,\n    base: void 0,\n    meta: [],\n    link: [],\n    style: [],\n    script: [],\n    noscript: []\n  };\n  for (const node of nodes) {\n    if (typeof node.type === \"symbol\" && Array.isArray(node.children)) {\n      for (const childNode of node.children)\n        addVNodeToHeadObj(childNode, obj);\n    } else {\n      addVNodeToHeadObj(node, obj);\n    }\n  }\n  return obj;\n};\nconst Head = /* @__PURE__ */ defineComponent({\n  // eslint-disable-next-line vue/no-reserved-component-names\n  name: \"Head\",\n  setup(_, { slots }) {\n    const head = injectHead();\n    const obj = ref({});\n    const entry = head.push(obj);\n    if (IsBrowser) {\n      onBeforeUnmount(() => {\n        entry.dispose();\n      });\n    }\n    return () => {\n      watchEffect(() => {\n        if (!slots.default)\n          return;\n        entry.patch(vnodesToHeadObj(slots.default()));\n      });\n      return null;\n    };\n  }\n});\n\nexport { Head, HeadVuePlugin, createHead, renderHeadToString };\n","export const appBaseURL = \"/\"\n\nexport const appBuildAssetsDir = \"/_nuxt/\"\n\nexport const appCdnURL = \"\"\n\nexport const appHead = {\"meta\":[{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"},{\"charset\":\"utf-8\"}],\"link\":[],\"style\":[],\"script\":[],\"noscript\":[]}\n\nexport const appLayoutTransition = false\n\nexport const appPageTransition = false\n\nexport const appKeepalive = false\n\nexport const appRootId = \"__nuxt\"\n\nexport const appRootTag = \"div\"","import { createHead, useHead } from \"@vueuse/head\";\nimport { defineNuxtPlugin } from \"#app\";\nimport { appHead } from \"#build/nuxt.config.mjs\";\nexport default defineNuxtPlugin((nuxtApp) => {\n  const head = createHead();\n  head.push(appHead);\n  nuxtApp.vueApp.use(head);\n  if (process.client) {\n    let pauseDOMUpdates = true;\n    const unpauseDom = () => {\n      pauseDOMUpdates = false;\n      head.internalHooks.callHook(\"entries:updated\", head.unhead);\n    };\n    head.internalHooks.hook(\"dom:beforeRender\", (context) => {\n      context.shouldRender = !pauseDOMUpdates;\n    });\n    nuxtApp.hooks.hook(\"page:start\", () => {\n      pauseDOMUpdates = true;\n    });\n    nuxtApp.hooks.hook(\"page:finish\", unpauseDom);\n    nuxtApp.hooks.hook(\"app:mounted\", unpauseDom);\n  }\n  nuxtApp._useHead = useHead;\n  if (process.server) {\n    nuxtApp.ssrContext.renderMeta = async () => {\n      const { renderSSRHead } = await import(\"@unhead/ssr\");\n      const meta = await renderSSRHead(head.unhead);\n      return {\n        ...meta,\n        bodyScriptsPrepend: meta.bodyTagsOpen,\n        bodyScripts: meta.bodyTags\n      };\n    };\n  }\n});\n","export const globalMiddleware = []\nexport const namedMiddleware = {\n  auth: () => import(\"/Users/carlesfarpierres/Documents/workspace/app-node-vue/client/middleware/auth.js\")\n}","import { reactive, h } from \"vue\";\nimport { parseURL, stringifyParsedURL, parseQuery, stringifyQuery, withoutBase, isEqual, joinURL } from \"ufo\";\nimport { createError } from \"h3\";\nimport { defineNuxtPlugin, clearError, navigateTo, showError, useRuntimeConfig, useState } from \"../index.mjs\";\nimport { callWithNuxt } from \"../nuxt.mjs\";\nimport { globalMiddleware } from \"#build/middleware\";\nfunction getRouteFromPath(fullPath) {\n  if (typeof fullPath === \"object\") {\n    fullPath = stringifyParsedURL({\n      pathname: fullPath.path || \"\",\n      search: stringifyQuery(fullPath.query || {}),\n      hash: fullPath.hash || \"\"\n    });\n  }\n  const url = parseURL(fullPath.toString());\n  return {\n    path: url.pathname,\n    fullPath,\n    query: parseQuery(url.search),\n    hash: url.hash,\n    params: {},\n    name: void 0,\n    matched: [],\n    redirectedFrom: void 0,\n    meta: {},\n    href: fullPath\n  };\n}\nexport default defineNuxtPlugin((nuxtApp) => {\n  const initialURL = process.client ? withoutBase(window.location.pathname, useRuntimeConfig().app.baseURL) + window.location.search + window.location.hash : nuxtApp.ssrContext.url;\n  const routes = [];\n  const hooks = {\n    \"navigate:before\": [],\n    \"resolve:before\": [],\n    \"navigate:after\": [],\n    error: []\n  };\n  const registerHook = (hook, guard) => {\n    hooks[hook].push(guard);\n    return () => hooks[hook].splice(hooks[hook].indexOf(guard), 1);\n  };\n  const baseURL = useRuntimeConfig().app.baseURL;\n  const route = reactive(getRouteFromPath(initialURL));\n  async function handleNavigation(url, replace) {\n    try {\n      const to = getRouteFromPath(url);\n      for (const middleware of hooks[\"navigate:before\"]) {\n        const result = await middleware(to, route);\n        if (result === false || result instanceof Error) {\n          return;\n        }\n        if (result) {\n          return handleNavigation(result, true);\n        }\n      }\n      for (const handler of hooks[\"resolve:before\"]) {\n        await handler(to, route);\n      }\n      Object.assign(route, to);\n      if (process.client) {\n        window.history[replace ? \"replaceState\" : \"pushState\"]({}, \"\", joinURL(baseURL, to.fullPath));\n        if (!nuxtApp.isHydrating) {\n          await callWithNuxt(nuxtApp, clearError);\n        }\n      }\n      for (const middleware of hooks[\"navigate:after\"]) {\n        await middleware(to, route);\n      }\n    } catch (err) {\n      if (process.dev && !hooks.error.length) {\n        console.warn(\"No error handlers registered to handle middleware errors. You can register an error handler with `router.onError()`\", err);\n      }\n      for (const handler of hooks.error) {\n        await handler(err);\n      }\n    }\n  }\n  const router = {\n    currentRoute: route,\n    isReady: () => Promise.resolve(),\n    options: {},\n    install: () => Promise.resolve(),\n    push: (url) => handleNavigation(url, false),\n    replace: (url) => handleNavigation(url, true),\n    back: () => window.history.go(-1),\n    go: (delta) => window.history.go(delta),\n    forward: () => window.history.go(1),\n    beforeResolve: (guard) => registerHook(\"resolve:before\", guard),\n    beforeEach: (guard) => registerHook(\"navigate:before\", guard),\n    afterEach: (guard) => registerHook(\"navigate:after\", guard),\n    onError: (handler) => registerHook(\"error\", handler),\n    resolve: getRouteFromPath,\n    addRoute: (parentName, route2) => {\n      routes.push(route2);\n    },\n    getRoutes: () => routes,\n    hasRoute: (name) => routes.some((route2) => route2.name === name),\n    removeRoute: (name) => {\n      const index = routes.findIndex((route2) => route2.name === name);\n      if (index !== -1) {\n        routes.splice(index, 1);\n      }\n    }\n  };\n  nuxtApp.vueApp.component(\"RouterLink\", {\n    functional: true,\n    props: {\n      to: String,\n      custom: Boolean,\n      replace: Boolean,\n      activeClass: String,\n      exactActiveClass: String,\n      ariaCurrentValue: String\n    },\n    setup: (props, { slots }) => {\n      const navigate = () => handleNavigation(props.to, props.replace);\n      return () => {\n        const route2 = router.resolve(props.to);\n        return props.custom ? slots.default?.({ href: props.to, navigate, route: route2 }) : h(\"a\", { href: props.to, onClick: (e) => {\n          e.preventDefault();\n          return navigate();\n        } }, slots);\n      };\n    }\n  });\n  if (process.client) {\n    window.addEventListener(\"popstate\", (event) => {\n      const location = event.target.location;\n      router.replace(location.href.replace(location.origin, \"\"));\n    });\n  }\n  nuxtApp._route = route;\n  nuxtApp._middleware = nuxtApp._middleware || {\n    global: [],\n    named: {}\n  };\n  const initialLayout = useState(\"_layout\");\n  nuxtApp.hooks.hookOnce(\"app:created\", async () => {\n    router.beforeEach(async (to, from) => {\n      to.meta = reactive(to.meta || {});\n      if (nuxtApp.isHydrating) {\n        to.meta.layout = initialLayout.value ?? to.meta.layout;\n      }\n      nuxtApp._processingMiddleware = true;\n      const middlewareEntries = /* @__PURE__ */ new Set([...globalMiddleware, ...nuxtApp._middleware.global]);\n      for (const middleware of middlewareEntries) {\n        const result = await callWithNuxt(nuxtApp, middleware, [to, from]);\n        if (process.server) {\n          if (result === false || result instanceof Error) {\n            const error = result || createError({\n              statusCode: 404,\n              statusMessage: `Page Not Found: ${initialURL}`\n            });\n            return callWithNuxt(nuxtApp, showError, [error]);\n          }\n        }\n        if (result || result === false) {\n          return result;\n        }\n      }\n    });\n    router.afterEach(() => {\n      delete nuxtApp._processingMiddleware;\n    });\n    await router.replace(initialURL);\n    if (!isEqual(route.fullPath, initialURL)) {\n      await callWithNuxt(nuxtApp, navigateTo, [route.fullPath]);\n    }\n  });\n  return {\n    provide: {\n      route,\n      router\n    }\n  };\n});\n","import { useCookie, useNuxtApp } from \"#app\";\nconst usePersistedstateCookies = (cookieOptions) => ({\n  getItem: (key) => {\n    return useCookie(key, {\n      ...cookieOptions,\n      encode: encodeURIComponent,\n      decode: decodeURIComponent\n    }).value;\n  },\n  setItem: (key, value) => {\n    useCookie(key, {\n      ...cookieOptions,\n      encode: encodeURIComponent,\n      decode: decodeURIComponent\n    }).value = value;\n  }\n});\nconst usePersistedstateLocalStorage = () => ({\n  getItem: (key) => {\n    return !useNuxtApp().ssrContext ? localStorage.getItem(key) : null;\n  },\n  setItem: (key, value) => {\n    if (!useNuxtApp().ssrContext)\n      localStorage.setItem(key, value);\n  }\n});\nconst usePersistedstateSessionStorage = () => ({\n  getItem: (key) => {\n    return !useNuxtApp().ssrContext ? sessionStorage.getItem(key) : null;\n  },\n  setItem: (key, value) => {\n    if (!useNuxtApp().ssrContext)\n      sessionStorage.setItem(key, value);\n  }\n});\nexport const persistedState = {\n  localStorage: usePersistedstateLocalStorage(),\n  sessionStorage: usePersistedstateSessionStorage(),\n  cookies: usePersistedstateCookies(),\n  cookiesWithOptions: usePersistedstateCookies\n};\n","// src/normalize.ts\nfunction isObject(v) {\n  return typeof v === \"object\" && v !== null;\n}\nfunction normalizeOptions(options, factoryOptions) {\n  options = isObject(options) ? options : /* @__PURE__ */ Object.create(null);\n  return new Proxy(options, {\n    get(target, key, receiver) {\n      if (key === \"key\")\n        return Reflect.get(target, key, receiver);\n      return Reflect.get(target, key, receiver) || Reflect.get(factoryOptions, key, receiver);\n    }\n  });\n}\n\n// src/pick.ts\nfunction get(state, path) {\n  return path.reduce((obj, p) => {\n    return obj == null ? void 0 : obj[p];\n  }, state);\n}\nfunction set(state, path, val) {\n  return path.slice(0, -1).reduce((obj, p) => {\n    if (/^(__proto__)$/.test(p))\n      return {};\n    else\n      return obj[p] = obj[p] || {};\n  }, state)[path[path.length - 1]] = val, state;\n}\nfunction pick(baseState, paths) {\n  return paths.reduce((substate, path) => {\n    const pathArray = path.split(\".\");\n    return set(substate, pathArray, get(baseState, pathArray));\n  }, {});\n}\n\n// src/plugin.ts\nfunction hydrateStore(store, { storage, serializer, key, debug }) {\n  try {\n    const fromStorage = storage == null ? void 0 : storage.getItem(key);\n    if (fromStorage)\n      store.$patch(serializer == null ? void 0 : serializer.deserialize(fromStorage));\n  } catch (error) {\n    if (debug)\n      console.error(error);\n  }\n}\nfunction persistState(state, { storage, serializer, key, paths, debug }) {\n  try {\n    const toStore = Array.isArray(paths) ? pick(state, paths) : state;\n    storage.setItem(key, serializer.serialize(toStore));\n  } catch (error) {\n    if (debug)\n      console.error(error);\n  }\n}\nfunction createPersistedState(factoryOptions = {}) {\n  return (context) => {\n    const { auto = false } = factoryOptions;\n    const {\n      options: { persist = auto },\n      store\n    } = context;\n    if (!persist)\n      return;\n    const persistences = (Array.isArray(persist) ? persist.map((p) => normalizeOptions(p, factoryOptions)) : [normalizeOptions(persist, factoryOptions)]).map(\n      ({\n        storage = localStorage,\n        beforeRestore = null,\n        afterRestore = null,\n        serializer = {\n          serialize: JSON.stringify,\n          deserialize: JSON.parse\n        },\n        key = store.$id,\n        paths = null,\n        debug = false\n      }) => {\n        var _a;\n        return {\n          storage,\n          beforeRestore,\n          afterRestore,\n          serializer,\n          key: ((_a = factoryOptions.key) != null ? _a : (k) => k)(key),\n          paths,\n          debug\n        };\n      }\n    );\n    store.$persist = () => {\n      persistences.forEach((persistence) => {\n        persistState(store.$state, persistence);\n      });\n    };\n    store.$hydrate = ({ runHooks = true } = {}) => {\n      persistences.forEach((persistence) => {\n        const { beforeRestore, afterRestore } = persistence;\n        if (runHooks)\n          beforeRestore == null ? void 0 : beforeRestore(context);\n        hydrateStore(store, persistence);\n        if (runHooks)\n          afterRestore == null ? void 0 : afterRestore(context);\n      });\n    };\n    persistences.forEach((persistence) => {\n      const { beforeRestore, afterRestore } = persistence;\n      beforeRestore == null ? void 0 : beforeRestore(context);\n      hydrateStore(store, persistence);\n      afterRestore == null ? void 0 : afterRestore(context);\n      store.$subscribe(\n        (_mutation, state) => {\n          persistState(state, persistence);\n        },\n        {\n          detached: true\n        }\n      );\n    });\n  };\n}\n\n// src/index.ts\nvar src_default = createPersistedState();\nexport {\n  createPersistedState,\n  src_default as default\n};\n","import { createPersistedState } from \"pinia-plugin-persistedstate\";\nimport { defineNuxtPlugin, useRuntimeConfig } from \"#app\";\nimport { persistedState } from \"#imports\";\nexport default defineNuxtPlugin((nuxtApp) => {\n  const { cookieOptions, debug, storage } = useRuntimeConfig().public.persistedState;\n  const pinia = nuxtApp.$pinia;\n  pinia.use(createPersistedState({\n    storage: storage === \"cookies\" ? persistedState.cookiesWithOptions(cookieOptions) : persistedState[storage],\n    debug\n  }));\n});\n","import node_modules__64pinia_nuxt_dist_runtime_plugin_vue3_mjs_A0OWXRrUgq from \"/Users/carlesfarpierres/Documents/workspace/app-node-vue/client/node_modules/@pinia/nuxt/dist/runtime/plugin.vue3.mjs\";\nimport _nuxt_components_plugin_mjs_KR1HBZs4kY from \"/Users/carlesfarpierres/Documents/workspace/app-node-vue/client/.nuxt/components.plugin.mjs\";\nimport node_modules_nuxt_dist_head_runtime_lib_vueuse_head_plugin_mjs_D7WGfuP1A0 from \"/Users/carlesfarpierres/Documents/workspace/app-node-vue/client/node_modules/nuxt/dist/head/runtime/lib/vueuse-head.plugin.mjs\";\nimport node_modules_nuxt_dist_app_plugins_router_mjs_PJLmOmdFeM from \"/Users/carlesfarpierres/Documents/workspace/app-node-vue/client/node_modules/nuxt/dist/app/plugins/router.mjs\";\nimport node_modules__64pinia_plugin_persistedstate_nuxt_dist_runtime_plugin_mjs_1UohGbtF8v from \"/Users/carlesfarpierres/Documents/workspace/app-node-vue/client/node_modules/@pinia-plugin-persistedstate/nuxt/dist/runtime/plugin.mjs\";\nexport default [\n  node_modules__64pinia_nuxt_dist_runtime_plugin_vue3_mjs_A0OWXRrUgq,\n  _nuxt_components_plugin_mjs_KR1HBZs4kY,\n  node_modules_nuxt_dist_head_runtime_lib_vueuse_head_plugin_mjs_D7WGfuP1A0,\n  node_modules_nuxt_dist_app_plugins_router_mjs_PJLmOmdFeM,\n  node_modules__64pinia_plugin_persistedstate_nuxt_dist_runtime_plugin_mjs_1UohGbtF8v\n]","import { defineComponent } from \"vue\";\nexport default defineComponent({\n  name: \"NuxtPage\",\n  setup(_, props) {\n    if (process.dev) {\n      console.warn(\"Create a Vue component in the `pages/` directory to enable `<NuxtPage>`\");\n    }\n    return () => props.slots.default?.();\n  }\n});\n","import { computed, defineComponent, h, onBeforeUnmount, ref } from \"vue\";\nimport { useNuxtApp } from \"#app\";\nexport default defineComponent({\n  name: \"NuxtLoadingIndicator\",\n  props: {\n    throttle: {\n      type: Number,\n      default: 200\n    },\n    duration: {\n      type: Number,\n      default: 2e3\n    },\n    height: {\n      type: Number,\n      default: 3\n    },\n    color: {\n      type: String,\n      default: \"repeating-linear-gradient(to right,#00dc82 0%,#34cdfe 50%,#0047e1 100%)\"\n    }\n  },\n  setup(props, { slots }) {\n    const indicator = useLoadingIndicator({\n      duration: props.duration,\n      throttle: props.throttle\n    });\n    const nuxtApp = useNuxtApp();\n    nuxtApp.hook(\"page:start\", indicator.start);\n    nuxtApp.hook(\"page:finish\", indicator.finish);\n    onBeforeUnmount(() => indicator.clear);\n    return () => h(\"div\", {\n      class: \"nuxt-loading-indicator\",\n      style: {\n        position: \"fixed\",\n        top: 0,\n        right: 0,\n        left: 0,\n        pointerEvents: \"none\",\n        width: `${indicator.progress.value}%`,\n        height: `${props.height}px`,\n        opacity: indicator.isLoading.value ? 1 : 0,\n        background: props.color,\n        backgroundSize: `${100 / indicator.progress.value * 100}% auto`,\n        transition: \"width 0.1s, height 0.4s, opacity 0.4s\",\n        zIndex: 999999\n      }\n    }, slots);\n  }\n});\nfunction useLoadingIndicator(opts) {\n  const progress = ref(0);\n  const isLoading = ref(false);\n  const step = computed(() => 1e4 / opts.duration);\n  let _timer = null;\n  let _throttle = null;\n  function start() {\n    clear();\n    progress.value = 0;\n    isLoading.value = true;\n    if (opts.throttle) {\n      if (process.client) {\n        _throttle = setTimeout(_startTimer, opts.throttle);\n      }\n    } else {\n      _startTimer();\n    }\n  }\n  function finish() {\n    progress.value = 100;\n    _hide();\n  }\n  function clear() {\n    clearInterval(_timer);\n    clearTimeout(_throttle);\n    _timer = null;\n    _throttle = null;\n  }\n  function _increase(num) {\n    progress.value = Math.min(100, progress.value + num);\n  }\n  function _hide() {\n    clear();\n    if (process.client) {\n      setTimeout(() => {\n        isLoading.value = false;\n        setTimeout(() => {\n          progress.value = 0;\n        }, 400);\n      }, 500);\n    }\n  }\n  function _startTimer() {\n    if (process.client) {\n      _timer = setInterval(() => {\n        _increase(step.value);\n      }, 100);\n    }\n  }\n  return {\n    progress,\n    isLoading,\n    start,\n    finish,\n    clear\n  };\n}\n","import { createSSRApp, createApp, nextTick } from \"vue\";\nimport { $fetch } from \"ofetch\";\nimport { baseURL } from \"#build/paths.mjs\";\nimport { createNuxtApp, applyPlugins, normalizePlugins } from \"#app\";\nimport \"#build/css\";\nimport _plugins from \"#build/plugins\";\nimport RootComponent from \"#build/root-component.mjs\";\nimport { appRootId } from \"#build/nuxt.config.mjs\";\nif (!globalThis.$fetch) {\n  globalThis.$fetch = $fetch.create({\n    baseURL: baseURL()\n  });\n}\nlet entry;\nconst plugins = normalizePlugins(_plugins);\nif (process.server) {\n  entry = async function createNuxtAppServer(ssrContext) {\n    const vueApp = createApp(RootComponent);\n    const nuxt = createNuxtApp({ vueApp, ssrContext });\n    try {\n      await applyPlugins(nuxt, plugins);\n      await nuxt.hooks.callHook(\"app:created\", vueApp);\n    } catch (err) {\n      await nuxt.callHook(\"app:error\", err);\n      nuxt.payload.error = nuxt.payload.error || err;\n    }\n    return vueApp;\n  };\n}\nif (process.client) {\n  if (process.dev && import.meta.webpackHot) {\n    import.meta.webpackHot.accept();\n  }\n  entry = async function initApp() {\n    const isSSR = Boolean(window.__NUXT__?.serverRendered);\n    const vueApp = isSSR ? createSSRApp(RootComponent) : createApp(RootComponent);\n    const nuxt = createNuxtApp({ vueApp });\n    try {\n      await applyPlugins(nuxt, plugins);\n    } catch (err) {\n      await nuxt.callHook(\"app:error\", err);\n      nuxt.payload.error = nuxt.payload.error || err;\n    }\n    try {\n      await nuxt.hooks.callHook(\"app:created\", vueApp);\n      await nuxt.hooks.callHook(\"app:beforeMount\", vueApp);\n      vueApp.mount(\"#\" + appRootId);\n      await nuxt.hooks.callHook(\"app:mounted\", vueApp);\n      await nextTick();\n    } catch (err) {\n      await nuxt.callHook(\"app:error\", err);\n      nuxt.payload.error = nuxt.payload.error || err;\n    }\n  };\n  entry().catch((error) => {\n    console.error(\"Error while mounting app:\", error);\n  });\n}\nexport default (ctx) => entry(ctx);\n"],"file":"server.mjs"}